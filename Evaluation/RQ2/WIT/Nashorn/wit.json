{
  "path": "/home/yanghengqin/jdk8u_nashorn/",
  "classes": [
    {
      "path": "/home/yanghengqin/jdk8u_nashorn/src/jdk/nashorn/internal/codegen/CodeGenerator.java",
      "methods": [
        {
          "qualifiedSignature": "jdk.nashorn.internal.codegen.CodeGenerator.Anonymous-4a7c61fb-43f3-4a89-b13f-bb44a1d731a0.enterDefault(jdk.nashorn.internal.ir.Node)",
          "exception": "throw new AssertionError(otherNode.getClass().getName());",
          "pathCojunction": "true",
          "backwardsPathConjunction": "true",
          "simplifiedPathConjunction": "true",
          "z3Program": "from z3 import *\nfrom z3_all_models import *\n\n\nconstraints = [\n  True\n]\n\nsolver = Solver()\nfor constraint in constraints:\n  solver.add(constraint)\n\nmodels = list(all_smt(solver))\nfor model in models: print(model)",
          "soundSymbolic": false,
          "soundBackwards": true,
          "maybe": false,
          "line": 1224,
          "throwingLine": 1226,
          "isStatic": false,
          "targetOnlyArguments": true
        }
      ]
    },
    {
      "path": "/home/yanghengqin/jdk8u_nashorn/src/jdk/nashorn/internal/objects/NativeJavaImporter.java",
      "methods": [
        {
          "qualifiedSignature": "jdk.nashorn.internal.objects.NativeJavaImporter.__noSuchMethod__(java.lang.Object, java.lang.Object...)",
          "exception": "throw typeError(\"not.a.function\", ScriptRuntime.safeToString(args[0]));",
          "pathCojunction": "true",
          "backwardsPathConjunction": "true",
          "simplifiedPathConjunction": "true",
          "z3Program": "from z3 import *\nfrom z3_all_models import *\n\n\nconstraints = [\n  True\n]\n\nsolver = Solver()\nfor constraint in constraints:\n  solver.add(constraint)\n\nmodels = list(all_smt(solver))\nfor model in models: print(model)",
          "soundSymbolic": false,
          "soundBackwards": true,
          "maybe": false,
          "line": 122,
          "throwingLine": 123,
          "isStatic": true,
          "targetOnlyArguments": true
        }
      ]
    },
    {
      "path": "/home/yanghengqin/jdk8u_nashorn/test/src/jdk/nashorn/test/models/LongProvider.java",
      "methods": [
        {
          "qualifiedSignature": "jdk.nashorn.test.models.LongProvider.getLong(java.lang.String)",
          "exception": "throw new RuntimeException(\"Wrong value. Expected \" + str + \", got \" + l)",
          "pathCojunction": "(!(Long.toString(l).equals(str)))",
          "symbolicPathConjunction": "(checkLong(l, str))",
          "backwardsPathConjunction": "(!(Long.toString(Long.parseLong(str)).equals(str)))",
          "simplifiedPathConjunction": "!Long.toString(Long.parseLong(str))_equals",
          "z3Program": "from z3 import *\nfrom z3_all_models import *\n\nstr0 = String('str0')\nl0 = Int('l0')\n\nconstraints = [\n  l0 == Long.parseLong(str0),\n  l0 >= -9223372036854775808, l0 <= 9223372036854775807, # implicit\n  Not(Long.toString(l0).equals(str0))\n]\n\nsolver = Solver()\nfor constraint in constraints:\n  solver.add(constraint)\n\nmodels = list(all_smt(solver))\nfor model in models: print(model)",
          "symPyProgram": "from sympy import Symbol\nfrom sympy import simplify\nfrom sympy.core.relational import Eq, Ne, StrictGreaterThan, StrictLessThan, LessThan, GreaterThan\nfrom sympy.printing import ccode\n\nstr = Symbol('str')\nLong_toString_equals = Symbol('Long_toString_equals')\nLong_toString = Symbol('Long_toString')\nLong_parseLong = Symbol('Long_parseLong')\npath_conjunction = (~(Long_toString_equals))\nprint(ccode(simplify(path_conjunction)))",
          "soundSymbolic": false,
          "soundBackwards": false,
          "maybe": true,
          "line": 42,
          "throwingLine": 44,
          "isStatic": true,
          "targetOnlyArguments": false
        },
        {
          "qualifiedSignature": "jdk.nashorn.test.models.LongProvider.checkLong(long, java.lang.String)",
          "exception": "throw new RuntimeException(\"Wrong value. Expected \" + str + \", got \" + value);",
          "pathCojunction": "(!(Long.toString(value).equals(str)))",
          "symbolicPathConjunction": "(!Long.toString(value).equals(str))",
          "backwardsPathConjunction": "(!(Long.toString(value).equals(str)))",
          "simplifiedPathConjunction": "!Long.toString(value)_equals",
          "z3Program": "from z3 import *\nfrom z3_all_models import *\n\nvalue0 = Int('value0')\nstr0 = String('str0')\n\nconstraints = [\n  value0 >= -9223372036854775808, value0 <= 9223372036854775807, # implicit\n  Not(Long.toString(value0).equals(str0))\n]\n\nsolver = Solver()\nfor constraint in constraints:\n  solver.add(constraint)\n\nmodels = list(all_smt(solver))\nfor model in models: print(model)",
          "symPyProgram": "from sympy import Symbol\nfrom sympy import simplify\nfrom sympy.core.relational import Eq, Ne, StrictGreaterThan, StrictLessThan, LessThan, GreaterThan\nfrom sympy.printing import ccode\n\nvalue = Symbol('value')\nstr = Symbol('str')\nLong_toString_equals = Symbol('Long_toString_equals')\nLong_toString = Symbol('Long_toString')\npath_conjunction = (~(Long_toString_equals))\nprint(ccode(simplify(path_conjunction)))",
          "soundSymbolic": false,
          "soundBackwards": false,
          "maybe": true,
          "line": 52,
          "throwingLine": 54,
          "isStatic": true,
          "targetOnlyArguments": false
        }
      ]
    },
    {
      "path": "/home/yanghengqin/jdk8u_nashorn/src/jdk/nashorn/internal/objects/NativeString.java",
      "methods": [
        {
          "qualifiedSignature": "jdk.nashorn.internal.objects.NativeString.delete(int, boolean)",
          "exception": "throw typeError(\"cant.delete.property\", Integer.toString(key), ScriptRuntime.safeToString(this))",
          "pathCojunction": "(isValidStringIndex(key)) && (strict)",
          "symbolicPathConjunction": "((isValidStringIndex(index)) && (strict))",
          "backwardsPathConjunction": "(isValidStringIndex(key)) && (strict)",
          "simplifiedPathConjunction": "isValidStringIndex(key) && strict",
          "z3Program": "from z3 import *\nfrom z3_all_models import *\n\nkey0 = Int('key0')\nstrict0 = Bool('strict0')\n\nconstraints = [\n  And(isValidStringIndex(key0), strict0)\n]\n\nsolver = Solver()\nfor constraint in constraints:\n  solver.add(constraint)\n\nmodels = list(all_smt(solver))\nfor model in models: print(model)",
          "symPyProgram": "from sympy import Symbol\nfrom sympy import simplify\nfrom sympy.core.relational import Eq, Ne, StrictGreaterThan, StrictLessThan, LessThan, GreaterThan\nfrom sympy.printing import ccode\n\nkey = Symbol('key', integer=True)\nstrict = Symbol('strict')\n_isValidStringIndex = Symbol('_isValidStringIndex')\npath_conjunction = (_isValidStringIndex & strict)\nprint(ccode(simplify(path_conjunction)))",
          "soundSymbolic": true,
          "soundBackwards": true,
          "maybe": true,
          "line": 297,
          "throwingLine": 298,
          "isStatic": false,
          "targetOnlyArguments": true
        },
        {
          "qualifiedSignature": "jdk.nashorn.internal.objects.NativeString.delete(double, boolean)",
          "exception": "throw typeError(\"cant.delete.property\", Integer.toString(index), ScriptRuntime.safeToString(this));",
          "pathCojunction": "(!(JSType.isRepresentableAsInt(key))) && (JSType.isRepresentableAsLong(key)) && (isValidStringIndex(index)) && (strict)",
          "symbolicPathConjunction": "(ArrayIndex.getArrayIndex(key)) && (!(isValidStringIndex(index)) && (strict))",
          "backwardsPathConjunction": "(!(JSType.isRepresentableAsInt(key))) && (JSType.isRepresentableAsLong(key)) && (isValidStringIndex(getArrayIndex((long) key))) && (strict)",
          "simplifiedPathConjunction": "JSType.isRepresentableAsLong(key) && isValidStringIndex(getArrayIndex(key)) && strict && !JSType.isRepresentableAsInt(key)",
          "z3Program": "from z3 import *\nfrom z3_all_models import *\n\nkey0 = Real('key0')\nstrict0 = Bool('strict0')\nindex0 = Int('index0')\n\nconstraints = [\n  index0 == getArrayIndex(key0),\n  And(And(And(Not(JSType.isRepresentableAsInt(key0)), JSType.isRepresentableAsLong(key0)), isValidStringIndex(index0)), strict0)\n]\n\nsolver = Solver()\nfor constraint in constraints:\n  solver.add(constraint)\n\nmodels = list(all_smt(solver))\nfor model in models: print(model)",
          "symPyProgram": "from sympy import Symbol\nfrom sympy import simplify\nfrom sympy.core.relational import Eq, Ne, StrictGreaterThan, StrictLessThan, LessThan, GreaterThan\nfrom sympy.printing import ccode\n\nkey = Symbol('key', integer=True)\nstrict = Symbol('strict')\nJSType_isRepresentableAsInt = Symbol('JSType_isRepresentableAsInt')\nJSType_isRepresentableAsLong = Symbol('JSType_isRepresentableAsLong')\n_isValidStringIndex = Symbol('_isValidStringIndex')\n_getArrayIndex = Symbol('_getArrayIndex')\npath_conjunction = ((((~(JSType_isRepresentableAsInt)) & JSType_isRepresentableAsLong) & _isValidStringIndex) & strict)\nprint(ccode(simplify(path_conjunction)))",
          "soundSymbolic": true,
          "soundBackwards": false,
          "maybe": true,
          "line": 302,
          "throwingLine": 304,
          "isStatic": false,
          "targetOnlyArguments": false
        },
        {
          "qualifiedSignature": "jdk.nashorn.internal.objects.NativeString.delete(double, boolean)",
          "exception": "throw typeError(\"cant.delete.property\", Integer.toString(index), ScriptRuntime.safeToString(this));",
          "pathCojunction": "(!(JSType.isRepresentableAsInt(key))) && (!(JSType.isRepresentableAsLong(key))) && (isValidStringIndex(index)) && (strict)",
          "symbolicPathConjunction": "(ArrayIndex.getArrayIndex(key)) && (!(isValidStringIndex(index)) && (strict))",
          "backwardsPathConjunction": "(!(JSType.isRepresentableAsInt(key))) && (!(JSType.isRepresentableAsLong(key))) && (isValidStringIndex(INVALID_ARRAY_INDEX)) && (strict)",
          "simplifiedPathConjunction": "isValidStringIndex(INVALID_ARRAY_INDEX) && strict && !JSType.isRepresentableAsInt(key) && !JSType.isRepresentableAsLong(key)",
          "z3Program": "from z3 import *\nfrom z3_all_models import *\n\nkey0 = Real('key0')\nstrict0 = Bool('strict0')\nINVALID_ARRAY_INDEX0 = Int('INVALID_ARRAY_INDEX0')\nindex0 = Int('index0')\n\nconstraints = [\n  INVALID_ARRAY_INDEX0 == -1,\n  index0 == INVALID_ARRAY_INDEX0,\n  And(And(And(Not(JSType.isRepresentableAsInt(key0)), Not(JSType.isRepresentableAsLong(key0))), isValidStringIndex(index0)), strict0)\n]\n\nsolver = Solver()\nfor constraint in constraints:\n  solver.add(constraint)\n\nmodels = list(all_smt(solver))\nfor model in models: print(model)",
          "symPyProgram": "from sympy import Symbol\nfrom sympy import simplify\nfrom sympy.core.relational import Eq, Ne, StrictGreaterThan, StrictLessThan, LessThan, GreaterThan\nfrom sympy.printing import ccode\n\nkey = Symbol('key', integer=True)\nstrict = Symbol('strict')\nJSType_isRepresentableAsInt = Symbol('JSType_isRepresentableAsInt')\nJSType_isRepresentableAsLong = Symbol('JSType_isRepresentableAsLong')\n_isValidStringIndex = Symbol('_isValidStringIndex')\npath_conjunction = ((((~(JSType_isRepresentableAsInt)) & (~(JSType_isRepresentableAsLong))) & _isValidStringIndex) & strict)\nprint(ccode(simplify(path_conjunction)))",
          "soundSymbolic": true,
          "soundBackwards": false,
          "maybe": true,
          "line": 302,
          "throwingLine": 304,
          "isStatic": false,
          "targetOnlyArguments": false
        },
        {
          "qualifiedSignature": "jdk.nashorn.internal.objects.NativeString.delete(double, boolean)",
          "exception": "throw typeError(\"cant.delete.property\", Integer.toString(index), ScriptRuntime.safeToString(this));",
          "pathCojunction": "(JSType.isRepresentableAsInt(key)) && (isValidStringIndex(index)) && (strict)",
          "symbolicPathConjunction": "(ArrayIndex.getArrayIndex(key)) && ((isValidStringIndex(index)) && (strict))",
          "backwardsPathConjunction": "(JSType.isRepresentableAsInt(key)) && (isValidStringIndex(getArrayIndex((int) key))) && (strict)",
          "simplifiedPathConjunction": "JSType.isRepresentableAsInt(key) && isValidStringIndex(getArrayIndex(key)) && strict",
          "z3Program": "from z3 import *\nfrom z3_all_models import *\n\nkey0 = Real('key0')\nstrict0 = Bool('strict0')\nindex0 = Int('index0')\n\nconstraints = [\n  index0 == getArrayIndex(key0),\n  And(And(JSType.isRepresentableAsInt(key0), isValidStringIndex(index0)), strict0)\n]\n\nsolver = Solver()\nfor constraint in constraints:\n  solver.add(constraint)\n\nmodels = list(all_smt(solver))\nfor model in models: print(model)",
          "symPyProgram": "from sympy import Symbol\nfrom sympy import simplify\nfrom sympy.core.relational import Eq, Ne, StrictGreaterThan, StrictLessThan, LessThan, GreaterThan\nfrom sympy.printing import ccode\n\nkey = Symbol('key', integer=True)\nstrict = Symbol('strict')\nJSType_isRepresentableAsInt = Symbol('JSType_isRepresentableAsInt')\n_isValidStringIndex = Symbol('_isValidStringIndex')\n_getArrayIndex = Symbol('_getArrayIndex')\npath_conjunction = ((JSType_isRepresentableAsInt & _isValidStringIndex) & strict)\nprint(ccode(simplify(path_conjunction)))",
          "soundSymbolic": true,
          "soundBackwards": false,
          "maybe": true,
          "line": 302,
          "throwingLine": 304,
          "isStatic": false,
          "targetOnlyArguments": false
        }
      ]
    },
    {
      "path": "/home/yanghengqin/jdk8u_nashorn/src/jdk/nashorn/internal/runtime/Context.java",
      "methods": [
        {
          "qualifiedSignature": "jdk.nashorn.internal.runtime.Context.ThrowErrorManager.error(java.lang.String)",
          "exception": "throw new ParserException(message);",
          "pathCojunction": "true",
          "backwardsPathConjunction": "true",
          "simplifiedPathConjunction": "true",
          "z3Program": "from z3 import *\nfrom z3_all_models import *\n\nmessage0 = String('message0')\n\nconstraints = [\n  True\n]\n\nsolver = Solver()\nfor constraint in constraints:\n  solver.add(constraint)\n\nmodels = list(all_smt(solver))\nfor model in models: print(model)",
          "soundSymbolic": false,
          "soundBackwards": true,
          "maybe": false,
          "line": 436,
          "throwingLine": 437,
          "isStatic": false,
          "targetOnlyArguments": true
        },
        {
          "qualifiedSignature": "jdk.nashorn.internal.runtime.Context.ThrowErrorManager.error(jdk.nashorn.internal.runtime.ParserException)",
          "exception": "throw e;",
          "pathCojunction": "true",
          "backwardsPathConjunction": "true",
          "simplifiedPathConjunction": "true",
          "z3Program": "from z3 import *\nfrom z3_all_models import *\n\n\nconstraints = [\n  True\n]\n\nsolver = Solver()\nfor constraint in constraints:\n  solver.add(constraint)\n\nmodels = list(all_smt(solver))\nfor model in models: print(model)",
          "soundSymbolic": false,
          "soundBackwards": true,
          "maybe": false,
          "line": 441,
          "throwingLine": 442,
          "isStatic": false,
          "targetOnlyArguments": true
        }
      ]
    },
    {
      "path": "/home/yanghengqin/jdk8u_nashorn/src/jdk/nashorn/internal/ir/FunctionNode.java",
      "methods": [
        {
          "qualifiedSignature": "jdk.nashorn.internal.ir.FunctionNode.initializeDeserialized(jdk.nashorn.internal.runtime.Source, jdk.nashorn.internal.codegen.Namespace)",
          "exception": "throw new IllegalStateException();",
          "pathCojunction": "(!(source == null || namespace == null)) && (!(this.source == source && this.namespace == namespace)) && (this.source != null || this.namespace != null)",
          "symbolicPathConjunction": "(!(source == null || namespace == null)) && (!(this.source == source && this.namespace == namespace)) && (this.source != null || this.namespace != null)",
          "backwardsPathConjunction": "(!(source == null || namespace == null)) && (!(this.source == source && this.namespace == namespace)) && (this.source != null || this.namespace != null)",
          "z3Program": "from z3 import *\nfrom z3_all_models import *\n\nsource0_isNull = Bool('source0_isNull')\nnamespace0_isNull = Bool('namespace0_isNull')\nthis_source0_isNull = Bool('this_source0_isNull')\nthis_namespace0_isNull = Bool('this_namespace0_isNull')\n\nconstraints = [\n  And(And(Not(Or(source0_isNull, namespace0_isNull)), Not(And(this_source0 == source0, this_namespace0 == namespace0))), Or(Not(this_source0_isNull), Not(this_namespace0_isNull)))\n]\n\nsolver = Solver()\nfor constraint in constraints:\n  solver.add(constraint)\n\nmodels = list(all_smt(solver))\nfor model in models: print(model)",
          "soundSymbolic": true,
          "soundBackwards": true,
          "maybe": true,
          "line": 403,
          "throwingLine": 409,
          "isStatic": false,
          "targetOnlyArguments": true
        },
        {
          "qualifiedSignature": "jdk.nashorn.internal.ir.FunctionNode.initializeDeserialized(jdk.nashorn.internal.runtime.Source, jdk.nashorn.internal.codegen.Namespace)",
          "exception": "throw new IllegalArgumentException();",
          "pathCojunction": "(source == null || namespace == null)",
          "symbolicPathConjunction": "(source == null || namespace == null)",
          "backwardsPathConjunction": "(source == null || namespace == null)",
          "simplifiedPathConjunction": "namespace == null || null == source",
          "z3Inputs": "[namespace0_isNull = False, source0_isNull = True]\n[namespace0_isNull = True]\n",
          "z3Program": "from z3 import *\nfrom z3_all_models import *\n\nsource0_isNull = Bool('source0_isNull')\nnamespace0_isNull = Bool('namespace0_isNull')\n\nconstraints = [\n  Or(source0_isNull, namespace0_isNull)\n]\n\nsolver = Solver()\nfor constraint in constraints:\n  solver.add(constraint)\n\nmodels = list(all_smt(solver))\nfor model in models: print(model)",
          "symPyProgram": "from sympy import Symbol\nfrom sympy import simplify\nfrom sympy.core.relational import Eq, Ne, StrictGreaterThan, StrictLessThan, LessThan, GreaterThan\nfrom sympy.printing import ccode\n\nsource = Symbol('source')\nnamespace = Symbol('namespace')\nnull = Symbol('null')\npath_conjunction = ((Eq(source, null)) | (Eq(namespace, null)))\nprint(ccode(simplify(path_conjunction)))",
          "soundSymbolic": true,
          "soundBackwards": true,
          "maybe": false,
          "line": 403,
          "throwingLine": 405,
          "isStatic": false,
          "targetOnlyArguments": true
        }
      ]
    },
    {
      "path": "/home/yanghengqin/jdk8u_nashorn/src/jdk/nashorn/internal/runtime/PropertyHashMap.java",
      "methods": [
        {
          "qualifiedSignature": "jdk.nashorn.internal.runtime.PropertyHashMap.put(java.lang.String, jdk.nashorn.internal.runtime.Property)",
          "exception": "throw new UnsupportedOperationException(\"Immutable map.\");",
          "pathCojunction": "true",
          "backwardsPathConjunction": "true",
          "simplifiedPathConjunction": "true",
          "z3Program": "from z3 import *\nfrom z3_all_models import *\n\nkey0 = String('key0')\n\nconstraints = [\n  True\n]\n\nsolver = Solver()\nfor constraint in constraints:\n  solver.add(constraint)\n\nmodels = list(all_smt(solver))\nfor model in models: print(model)",
          "soundSymbolic": false,
          "soundBackwards": true,
          "maybe": false,
          "line": 574,
          "throwingLine": 575,
          "isStatic": false,
          "targetOnlyArguments": true
        },
        {
          "qualifiedSignature": "jdk.nashorn.internal.runtime.PropertyHashMap.remove(java.lang.Object)",
          "exception": "throw new UnsupportedOperationException(\"Immutable map.\");",
          "pathCojunction": "true",
          "backwardsPathConjunction": "true",
          "simplifiedPathConjunction": "true",
          "z3Program": "from z3 import *\nfrom z3_all_models import *\n\n\nconstraints = [\n  True\n]\n\nsolver = Solver()\nfor constraint in constraints:\n  solver.add(constraint)\n\nmodels = list(all_smt(solver))\nfor model in models: print(model)",
          "soundSymbolic": false,
          "soundBackwards": true,
          "maybe": false,
          "line": 579,
          "throwingLine": 580,
          "isStatic": false,
          "targetOnlyArguments": true
        },
        {
          "qualifiedSignature": "jdk.nashorn.internal.runtime.PropertyHashMap.putAll(java.util.Map<? extends java.lang.String, ? extends jdk.nashorn.internal.runtime.Property>)",
          "exception": "throw new UnsupportedOperationException(\"Immutable map.\");",
          "pathCojunction": "true",
          "backwardsPathConjunction": "true",
          "simplifiedPathConjunction": "true",
          "z3Program": "from z3 import *\nfrom z3_all_models import *\n\n\nconstraints = [\n  True\n]\n\nsolver = Solver()\nfor constraint in constraints:\n  solver.add(constraint)\n\nmodels = list(all_smt(solver))\nfor model in models: print(model)",
          "soundSymbolic": false,
          "soundBackwards": true,
          "maybe": false,
          "line": 584,
          "throwingLine": 585,
          "isStatic": false,
          "targetOnlyArguments": true
        },
        {
          "qualifiedSignature": "jdk.nashorn.internal.runtime.PropertyHashMap.clear()",
          "exception": "throw new UnsupportedOperationException(\"Immutable map.\");",
          "pathCojunction": "true",
          "backwardsPathConjunction": "true",
          "simplifiedPathConjunction": "true",
          "soundSymbolic": false,
          "soundBackwards": true,
          "maybe": false,
          "line": 589,
          "throwingLine": 590,
          "isStatic": false,
          "targetOnlyArguments": true
        },
        {
          "qualifiedSignature": "jdk.nashorn.internal.runtime.PropertyHashMap.Element.setValue(jdk.nashorn.internal.runtime.Property)",
          "exception": "throw new UnsupportedOperationException(\"Immutable map.\");",
          "pathCojunction": "true",
          "backwardsPathConjunction": "true",
          "simplifiedPathConjunction": "true",
          "z3Program": "from z3 import *\nfrom z3_all_models import *\n\n\nconstraints = [\n  True\n]\n\nsolver = Solver()\nfor constraint in constraints:\n  solver.add(constraint)\n\nmodels = list(all_smt(solver))\nfor model in models: print(model)",
          "soundSymbolic": false,
          "soundBackwards": true,
          "maybe": false,
          "line": 673,
          "throwingLine": 674,
          "isStatic": false,
          "targetOnlyArguments": true
        }
      ]
    },
    {
      "path": "/home/yanghengqin/jdk8u_nashorn/src/jdk/internal/dynalink/DynamicLinkerFactory.java",
      "methods": [
        {
          "qualifiedSignature": "jdk.internal.dynalink.DynamicLinkerFactory.setPrioritizedLinker(jdk.internal.dynalink.linker.GuardingDynamicLinker)",
          "exception": "throw new IllegalArgumentException(\"prioritizedLinker == null\");",
          "pathCojunction": "(prioritizedLinker == null)",
          "symbolicPathConjunction": "(prioritizedLinker == null)",
          "backwardsPathConjunction": "(prioritizedLinker == null)",
          "simplifiedPathConjunction": "null == prioritizedLinker",
          "z3Inputs": "[prioritizedLinker0_isNull = True]\n",
          "z3Program": "from z3 import *\nfrom z3_all_models import *\n\nprioritizedLinker0_isNull = Bool('prioritizedLinker0_isNull')\n\nconstraints = [\n  prioritizedLinker0_isNull\n]\n\nsolver = Solver()\nfor constraint in constraints:\n  solver.add(constraint)\n\nmodels = list(all_smt(solver))\nfor model in models: print(model)",
          "symPyProgram": "from sympy import Symbol\nfrom sympy import simplify\nfrom sympy.core.relational import Eq, Ne, StrictGreaterThan, StrictLessThan, LessThan, GreaterThan\nfrom sympy.printing import ccode\n\nprioritizedLinker = Symbol('prioritizedLinker')\nnull = Symbol('null')\npath_conjunction = (Eq(prioritizedLinker, null))\nprint(ccode(simplify(path_conjunction)))",
          "soundSymbolic": true,
          "soundBackwards": true,
          "maybe": false,
          "line": 183,
          "throwingLine": 185,
          "isStatic": false,
          "targetOnlyArguments": true
        },
        {
          "qualifiedSignature": "jdk.internal.dynalink.DynamicLinkerFactory.setRuntimeContextArgCount(int)",
          "exception": "throw new IllegalArgumentException(\"runtimeContextArgCount < 0\");",
          "pathCojunction": "(runtimeContextArgCount < 0)",
          "symbolicPathConjunction": "(runtimeContextArgCount < 0)",
          "backwardsPathConjunction": "(runtimeContextArgCount < 0)",
          "simplifiedPathConjunction": "runtimeContextArgCount < 0",
          "z3Inputs": "[runtimeContextArgCount0 = -1]\n[runtimeContextArgCount0 = -2]\n[runtimeContextArgCount0 = -3]\n[runtimeContextArgCount0 = -4]\n[runtimeContextArgCount0 = -5]\n[runtimeContextArgCount0 = -6]\n[runtimeContextArgCount0 = -7]\n[runtimeContextArgCount0 = -8]\n[runtimeContextArgCount0 = -9]\n[runtimeContextArgCount0 = -10]\n",
          "z3Program": "from z3 import *\nfrom z3_all_models import *\n\nruntimeContextArgCount0 = Int('runtimeContextArgCount0')\n\nconstraints = [\n  runtimeContextArgCount0 < 0\n]\n\nsolver = Solver()\nfor constraint in constraints:\n  solver.add(constraint)\n\nmodels = list(all_smt(solver))\nfor model in models: print(model)",
          "symPyProgram": "from sympy import Symbol\nfrom sympy import simplify\nfrom sympy.core.relational import Eq, Ne, StrictGreaterThan, StrictLessThan, LessThan, GreaterThan\nfrom sympy.printing import ccode\n\nruntimeContextArgCount = Symbol('runtimeContextArgCount', integer=True)\npath_conjunction = (StrictLessThan(runtimeContextArgCount, 0))\nprint(ccode(simplify(path_conjunction)))",
          "soundSymbolic": true,
          "soundBackwards": true,
          "maybe": false,
          "line": 224,
          "throwingLine": 226,
          "isStatic": false,
          "targetOnlyArguments": true
        },
        {
          "qualifiedSignature": "jdk.internal.dynalink.DynamicLinkerFactory.setUnstableRelinkThreshold(int)",
          "exception": "throw new IllegalArgumentException(\"unstableRelinkThreshold < 0\");",
          "pathCojunction": "(unstableRelinkThreshold < 0)",
          "symbolicPathConjunction": "(unstableRelinkThreshold < 0)",
          "backwardsPathConjunction": "(unstableRelinkThreshold < 0)",
          "simplifiedPathConjunction": "unstableRelinkThreshold < 0",
          "z3Inputs": "[unstableRelinkThreshold0 = -1]\n[unstableRelinkThreshold0 = -2]\n[unstableRelinkThreshold0 = -3]\n[unstableRelinkThreshold0 = -4]\n[unstableRelinkThreshold0 = -5]\n[unstableRelinkThreshold0 = -6]\n[unstableRelinkThreshold0 = -7]\n[unstableRelinkThreshold0 = -8]\n[unstableRelinkThreshold0 = -9]\n[unstableRelinkThreshold0 = -10]\n",
          "z3Program": "from z3 import *\nfrom z3_all_models import *\n\nunstableRelinkThreshold0 = Int('unstableRelinkThreshold0')\n\nconstraints = [\n  unstableRelinkThreshold0 < 0\n]\n\nsolver = Solver()\nfor constraint in constraints:\n  solver.add(constraint)\n\nmodels = list(all_smt(solver))\nfor model in models: print(model)",
          "symPyProgram": "from sympy import Symbol\nfrom sympy import simplify\nfrom sympy.core.relational import Eq, Ne, StrictGreaterThan, StrictLessThan, LessThan, GreaterThan\nfrom sympy.printing import ccode\n\nunstableRelinkThreshold = Symbol('unstableRelinkThreshold', integer=True)\npath_conjunction = (StrictLessThan(unstableRelinkThreshold, 0))\nprint(ccode(simplify(path_conjunction)))",
          "soundSymbolic": true,
          "soundBackwards": true,
          "maybe": false,
          "line": 248,
          "throwingLine": 250,
          "isStatic": false,
          "targetOnlyArguments": true
        }
      ]
    },
    {
      "path": "/home/yanghengqin/jdk8u_nashorn/src/jdk/nashorn/api/scripting/ScriptObjectMirror.java",
      "methods": [
        {
          "qualifiedSignature": "jdk.nashorn.api.scripting.ScriptObjectMirror.containsKey(java.lang.Object)",
          "exception": "throw new NullPointerException(\"key can not be null\")",
          "pathCojunction": "(key == null)",
          "symbolicPathConjunction": "(Objects.requireNonNull(key, \"key can not be null\"))",
          "backwardsPathConjunction": "(key == null)",
          "simplifiedPathConjunction": "key == null",
          "z3Inputs": "[key0_isNull = True]\n",
          "z3Program": "from z3 import *\nfrom z3_all_models import *\n\nkey0_isNull = Bool('key0_isNull')\n\nconstraints = [\n  key0_isNull\n]\n\nsolver = Solver()\nfor constraint in constraints:\n  solver.add(constraint)\n\nmodels = list(all_smt(solver))\nfor model in models: print(model)",
          "symPyProgram": "from sympy import Symbol\nfrom sympy import simplify\nfrom sympy.core.relational import Eq, Ne, StrictGreaterThan, StrictLessThan, LessThan, GreaterThan\nfrom sympy.printing import ccode\n\nkey = Symbol('key')\nnull = Symbol('null')\npath_conjunction = (Eq(key, null))\nprint(ccode(simplify(path_conjunction)))",
          "soundSymbolic": true,
          "soundBackwards": true,
          "maybe": false,
          "line": 343,
          "throwingLine": 344,
          "isStatic": false,
          "targetOnlyArguments": true
        },
        {
          "qualifiedSignature": "jdk.nashorn.api.scripting.ScriptObjectMirror.get(java.lang.Object)",
          "exception": "throw new NullPointerException(\"key can not be null\")",
          "pathCojunction": "(key == null)",
          "symbolicPathConjunction": "(Objects.requireNonNull(key, \"key can not be null\"))",
          "backwardsPathConjunction": "(key == null)",
          "simplifiedPathConjunction": "key == null",
          "z3Inputs": "[key0_isNull = True]\n",
          "z3Program": "from z3 import *\nfrom z3_all_models import *\n\nkey0_isNull = Bool('key0_isNull')\n\nconstraints = [\n  key0_isNull\n]\n\nsolver = Solver()\nfor constraint in constraints:\n  solver.add(constraint)\n\nmodels = list(all_smt(solver))\nfor model in models: print(model)",
          "symPyProgram": "from sympy import Symbol\nfrom sympy import simplify\nfrom sympy.core.relational import Eq, Ne, StrictGreaterThan, StrictLessThan, LessThan, GreaterThan\nfrom sympy.printing import ccode\n\nkey = Symbol('key')\nnull = Symbol('null')\npath_conjunction = (Eq(key, null))\nprint(ccode(simplify(path_conjunction)))",
          "soundSymbolic": true,
          "soundBackwards": true,
          "maybe": false,
          "line": 380,
          "throwingLine": 381,
          "isStatic": false,
          "targetOnlyArguments": true
        }
      ]
    },
    {
      "path": "/home/yanghengqin/jdk8u_nashorn/src/jdk/nashorn/internal/runtime/arrays/SealedArrayFilter.java",
      "methods": [
        {
          "qualifiedSignature": "jdk.nashorn.internal.runtime.arrays.SealedArrayFilter.canDelete(int, boolean)",
          "exception": "throw typeError(\"cant.delete.property\", Long.toString(ArrayIndex.toLongIndex(index)), \"sealed array\")",
          "pathCojunction": "(strict)",
          "symbolicPathConjunction": "(canDelete(ArrayIndex.toLongIndex(index), strict))",
          "backwardsPathConjunction": "(strict)",
          "simplifiedPathConjunction": "strict",
          "z3Inputs": "[strict0 = True]\n",
          "z3Program": "from z3 import *\nfrom z3_all_models import *\n\nindex0 = Int('index0')\nstrict0 = Bool('strict0')\n\nconstraints = [\n  strict0\n]\n\nsolver = Solver()\nfor constraint in constraints:\n  solver.add(constraint)\n\nmodels = list(all_smt(solver))\nfor model in models: print(model)",
          "symPyProgram": "from sympy import Symbol\nfrom sympy import simplify\nfrom sympy.core.relational import Eq, Ne, StrictGreaterThan, StrictLessThan, LessThan, GreaterThan\nfrom sympy.printing import ccode\n\nstrict = Symbol('strict')\npath_conjunction = strict\nprint(ccode(simplify(path_conjunction)))",
          "soundSymbolic": true,
          "soundBackwards": true,
          "maybe": false,
          "line": 52,
          "throwingLine": 53,
          "isStatic": false,
          "targetOnlyArguments": true
        },
        {
          "qualifiedSignature": "jdk.nashorn.internal.runtime.arrays.SealedArrayFilter.canDelete(long, boolean)",
          "exception": "throw typeError(\"cant.delete.property\", Long.toString(longIndex), \"sealed array\");",
          "pathCojunction": "(strict)",
          "symbolicPathConjunction": "(strict)",
          "backwardsPathConjunction": "(strict)",
          "simplifiedPathConjunction": "strict",
          "z3Inputs": "[longIndex0 = -9223372036854775808, strict0 = True]\n[strict0 = True, longIndex0 = 0]\n[strict0 = True, longIndex0 = -1]\n[strict0 = True, longIndex0 = -2]\n[strict0 = True, longIndex0 = -3]\n[strict0 = True, longIndex0 = -4]\n[strict0 = True, longIndex0 = -5]\n[strict0 = True, longIndex0 = -6]\n[strict0 = True, longIndex0 = -7]\n[strict0 = True, longIndex0 = -8]\n",
          "z3Program": "from z3 import *\nfrom z3_all_models import *\n\nlongIndex0 = Int('longIndex0')\nstrict0 = Bool('strict0')\n\nconstraints = [\n  longIndex0 >= -9223372036854775808, longIndex0 <= 9223372036854775807, # implicit\n  strict0\n]\n\nsolver = Solver()\nfor constraint in constraints:\n  solver.add(constraint)\n\nmodels = list(all_smt(solver))\nfor model in models: print(model)",
          "symPyProgram": "from sympy import Symbol\nfrom sympy import simplify\nfrom sympy.core.relational import Eq, Ne, StrictGreaterThan, StrictLessThan, LessThan, GreaterThan\nfrom sympy.printing import ccode\n\nstrict = Symbol('strict')\npath_conjunction = strict\nprint(ccode(simplify(path_conjunction)))",
          "soundSymbolic": true,
          "soundBackwards": true,
          "maybe": false,
          "line": 57,
          "throwingLine": 59,
          "isStatic": false,
          "targetOnlyArguments": true
        }
      ]
    },
    {
      "path": "/home/yanghengqin/jdk8u_nashorn/src/jdk/nashorn/api/scripting/NashornScriptEngine.java",
      "methods": [
        {
          "qualifiedSignature": "jdk.nashorn.api.scripting.NashornScriptEngine.invokeMethod(java.lang.Object, java.lang.String, java.lang.Object...)",
          "exception": "throw new IllegalArgumentException(getMessage(\"thiz.cannot.be.null\"));",
          "pathCojunction": "(thiz == null)",
          "symbolicPathConjunction": "(thiz == null)",
          "backwardsPathConjunction": "(thiz == null)",
          "simplifiedPathConjunction": "null == thiz",
          "z3Inputs": "[thiz0_isNull = True]\n",
          "z3Program": "from z3 import *\nfrom z3_all_models import *\n\nname0 = String('name0')\nthiz0_isNull = Bool('thiz0_isNull')\n\nconstraints = [\n  thiz0_isNull\n]\n\nsolver = Solver()\nfor constraint in constraints:\n  solver.add(constraint)\n\nmodels = list(all_smt(solver))\nfor model in models: print(model)",
          "symPyProgram": "from sympy import Symbol\nfrom sympy import simplify\nfrom sympy.core.relational import Eq, Ne, StrictGreaterThan, StrictLessThan, LessThan, GreaterThan\nfrom sympy.printing import ccode\n\nthiz = Symbol('thiz')\nnull = Symbol('null')\npath_conjunction = (Eq(thiz, null))\nprint(ccode(simplify(path_conjunction)))",
          "soundSymbolic": true,
          "soundBackwards": true,
          "maybe": false,
          "line": 195,
          "throwingLine": 197,
          "isStatic": false,
          "targetOnlyArguments": true
        },
        {
          "qualifiedSignature": "jdk.nashorn.api.scripting.NashornScriptEngine.getInterface(java.lang.Object, java.lang.Class<T>)",
          "exception": "throw new IllegalArgumentException(getMessage(\"thiz.cannot.be.null\"));",
          "pathCojunction": "(thiz == null)",
          "symbolicPathConjunction": "(thiz == null)",
          "backwardsPathConjunction": "(thiz == null)",
          "simplifiedPathConjunction": "null == thiz",
          "z3Inputs": "[thiz0_isNull = True]\n",
          "z3Program": "from z3 import *\nfrom z3_all_models import *\n\nthiz0_isNull = Bool('thiz0_isNull')\n\nconstraints = [\n  thiz0_isNull\n]\n\nsolver = Solver()\nfor constraint in constraints:\n  solver.add(constraint)\n\nmodels = list(all_smt(solver))\nfor model in models: print(model)",
          "symPyProgram": "from sympy import Symbol\nfrom sympy import simplify\nfrom sympy.core.relational import Eq, Ne, StrictGreaterThan, StrictLessThan, LessThan, GreaterThan\nfrom sympy.printing import ccode\n\nthiz = Symbol('thiz')\nnull = Symbol('null')\npath_conjunction = (Eq(thiz, null))\nprint(ccode(simplify(path_conjunction)))",
          "soundSymbolic": true,
          "soundBackwards": true,
          "maybe": false,
          "line": 208,
          "throwingLine": 210,
          "isStatic": false,
          "targetOnlyArguments": true
        }
      ]
    },
    {
      "path": "/home/yanghengqin/jdk8u_nashorn/src/jdk/nashorn/internal/parser/JSONParser.java",
      "methods": [
        {
          "qualifiedSignature": "jdk.nashorn.internal.parser.JSONParser.parse()",
          "exception": "throw expectedError(pos, \"eof\", toString(peek()));",
          "pathCojunction": "(pos < length)",
          "symbolicPathConjunction": "(pos < length)",
          "backwardsPathConjunction": "(pos < length)",
          "simplifiedPathConjunction": "length > pos",
          "z3Program": "from z3 import *\nfrom z3_all_models import *\n\npos0 = Int('pos0')\nlength0 = Int('length0')\n\nconstraints = [\n  value0 == parseLiteral(),\n  pos0 < length0\n]\n\nsolver = Solver()\nfor constraint in constraints:\n  solver.add(constraint)\n\nmodels = list(all_smt(solver))\nfor model in models: print(model)",
          "symPyProgram": "from sympy import Symbol\nfrom sympy import simplify\nfrom sympy.core.relational import Eq, Ne, StrictGreaterThan, StrictLessThan, LessThan, GreaterThan\nfrom sympy.printing import ccode\n\npos = Symbol('pos', integer=True)\nlength = Symbol('length', integer=True)\npath_conjunction = (StrictLessThan(pos, length))\nprint(ccode(simplify(path_conjunction)))",
          "soundSymbolic": false,
          "soundBackwards": true,
          "maybe": true,
          "line": 147,
          "throwingLine": 151,
          "isStatic": false,
          "targetOnlyArguments": false
        }
      ]
    },
    {
      "path": "/home/yanghengqin/jdk8u_nashorn/src/jdk/internal/dynalink/linker/GuardedInvocation.java",
      "methods": [
        {
          "qualifiedSignature": "jdk.internal.dynalink.linker.GuardedInvocation.assertType(java.lang.invoke.MethodType)",
          "exception": "throw new WrongMethodTypeException(\"Expected type: \" + type.changeReturnType(Boolean.TYPE) + \" actual type: \" + guard.type())",
          "pathCojunction": "(!(!invocation.type().equals(type))) && (guard != null) && (!(guard.type().equals(type.changeReturnType(Boolean.TYPE))))",
          "symbolicPathConjunction": "(!(!mh.type().equals(type))) && (guard != null) && (!mh.type().equals(type))",
          "backwardsPathConjunction": "(!(!invocation.type().equals(type))) && (guard != null) && (!(guard.type().equals(type.changeReturnType(Boolean.TYPE))))",
          "simplifiedPathConjunction": "invocation.type()_equals && !guard.type()_equals && guard != null",
          "z3Program": "from z3 import *\nfrom z3_all_models import *\n\nguard0_isNull = Bool('guard0_isNull')\n\nconstraints = [\n  And(And(Not(Not(invocation.type().equals(type0))), Not(guard0_isNull)), Not(guard0.type().equals(type0.changeReturnType(Boolean.TYPE))))\n]\n\nsolver = Solver()\nfor constraint in constraints:\n  solver.add(constraint)\n\nmodels = list(all_smt(solver))\nfor model in models: print(model)",
          "symPyProgram": "from sympy import Symbol\nfrom sympy import simplify\nfrom sympy.core.relational import Eq, Ne, StrictGreaterThan, StrictLessThan, LessThan, GreaterThan\nfrom sympy.printing import ccode\n\ntype = Symbol('type')\nguard = Symbol('guard')\ninvocation_type_equals = Symbol('invocation_type_equals')\ninvocation_type = Symbol('invocation_type')\nguard_type_equals = Symbol('guard_type_equals')\nguard_type = Symbol('guard_type')\ntype_changeReturnType = Symbol('type_changeReturnType')\nnull = Symbol('null')\npath_conjunction = (((~((~(invocation_type_equals)))) & (Ne(guard, null))) & (~(guard_type_equals)))\nprint(ccode(simplify(path_conjunction)))",
          "soundSymbolic": true,
          "soundBackwards": false,
          "maybe": true,
          "line": 258,
          "throwingLine": 261,
          "isStatic": false,
          "targetOnlyArguments": false
        },
        {
          "qualifiedSignature": "jdk.internal.dynalink.linker.GuardedInvocation.assertType(java.lang.invoke.MethodType)",
          "exception": "throw new WrongMethodTypeException(\"Expected type: \" + type + \" actual type: \" + invocation.type())",
          "pathCojunction": "(!(invocation.type().equals(type)))",
          "symbolicPathConjunction": "(!mh.type().equals(type))",
          "backwardsPathConjunction": "(!(invocation.type().equals(type)))",
          "simplifiedPathConjunction": "!invocation.type()_equals",
          "z3Program": "from z3 import *\nfrom z3_all_models import *\n\n\nconstraints = [\n  Not(invocation.type().equals(type0))\n]\n\nsolver = Solver()\nfor constraint in constraints:\n  solver.add(constraint)\n\nmodels = list(all_smt(solver))\nfor model in models: print(model)",
          "symPyProgram": "from sympy import Symbol\nfrom sympy import simplify\nfrom sympy.core.relational import Eq, Ne, StrictGreaterThan, StrictLessThan, LessThan, GreaterThan\nfrom sympy.printing import ccode\n\ntype = Symbol('type')\ninvocation_type_equals = Symbol('invocation_type_equals')\ninvocation_type = Symbol('invocation_type')\npath_conjunction = (~(invocation_type_equals))\nprint(ccode(simplify(path_conjunction)))",
          "soundSymbolic": true,
          "soundBackwards": true,
          "maybe": true,
          "line": 258,
          "throwingLine": 259,
          "isStatic": false,
          "targetOnlyArguments": false
        }
      ]
    },
    {
      "path": "/home/yanghengqin/jdk8u_nashorn/src/jdk/nashorn/internal/runtime/regexp/joni/ast/CClassNode.java",
      "methods": [
        {
          "qualifiedSignature": "jdk.nashorn.internal.runtime.regexp.joni.ast.CClassNode.nextStateClass(jdk.nashorn.internal.runtime.regexp.joni.ast.CClassNode.CCStateArg, jdk.nashorn.internal.runtime.regexp.joni.ScanEnvironment)",
          "exception": "throw new SyntaxException(ErrorMessages.ERR_CHAR_CLASS_VALUE_AT_END_OF_RANGE);",
          "pathCojunction": "(arg.state == CCSTATE.RANGE)",
          "symbolicPathConjunction": "(arg.state == CCSTATE.RANGE)",
          "backwardsPathConjunction": "(arg.state == CCSTATE.RANGE)",
          "z3Program": "from z3 import *\nfrom z3_all_models import *\n\n\nconstraints = [\n  arg_state0 == CCSTATE_RANGE0\n]\n\nsolver = Solver()\nfor constraint in constraints:\n  solver.add(constraint)\n\nmodels = list(all_smt(solver))\nfor model in models: print(model)",
          "soundSymbolic": true,
          "soundBackwards": false,
          "maybe": true,
          "line": 459,
          "throwingLine": 461,
          "isStatic": false,
          "targetOnlyArguments": false
        }
      ]
    },
    {
      "path": "/home/yanghengqin/jdk8u_nashorn/src/jdk/nashorn/internal/runtime/regexp/joni/ScanEnvironment.java",
      "methods": [
        {
          "qualifiedSignature": "jdk.nashorn.internal.runtime.regexp.joni.ScanEnvironment.addMemEntry()",
          "exception": "throw new InternalException(ErrorMessages.ERR_TOO_MANY_CAPTURE_GROUPS);",
          "pathCojunction": "(numMem >= Config.MAX_CAPTURE_GROUP_NUM)",
          "symbolicPathConjunction": "(numMem >= Config.MAX_CAPTURE_GROUP_NUM)",
          "backwardsPathConjunction": "(numMem >= Config.MAX_CAPTURE_GROUP_NUM)",
          "z3Inputs": "[numMem0 = 0, Config_MAX_CAPTURE_GROUP_NUM0 = 0]\n[numMem0 = -1, Config_MAX_CAPTURE_GROUP_NUM0 = -1]\n[numMem0 = -2, Config_MAX_CAPTURE_GROUP_NUM0 = -2]\n[numMem0 = -3, Config_MAX_CAPTURE_GROUP_NUM0 = -3]\n[numMem0 = -4, Config_MAX_CAPTURE_GROUP_NUM0 = -4]\n[numMem0 = -5, Config_MAX_CAPTURE_GROUP_NUM0 = -5]\n[numMem0 = -6, Config_MAX_CAPTURE_GROUP_NUM0 = -6]\n[numMem0 = -7, Config_MAX_CAPTURE_GROUP_NUM0 = -7]\n[numMem0 = -8, Config_MAX_CAPTURE_GROUP_NUM0 = -8]\n[numMem0 = -9, Config_MAX_CAPTURE_GROUP_NUM0 = -9]\n",
          "z3Program": "from z3 import *\nfrom z3_all_models import *\n\nConfig_MAX_CAPTURE_GROUP_NUM0 = Int('Config_MAX_CAPTURE_GROUP_NUM0')\nnumMem0 = Int('numMem0')\n\nconstraints = [\n  numMem0 >= Config_MAX_CAPTURE_GROUP_NUM0\n]\n\nsolver = Solver()\nfor constraint in constraints:\n  solver.add(constraint)\n\nmodels = list(all_smt(solver))\nfor model in models: print(model)",
          "soundSymbolic": true,
          "soundBackwards": false,
          "maybe": true,
          "line": 64,
          "throwingLine": 66,
          "isStatic": false,
          "targetOnlyArguments": false
        },
        {
          "qualifiedSignature": "jdk.nashorn.internal.runtime.regexp.joni.ScanEnvironment.setMemNode(int, jdk.nashorn.internal.runtime.regexp.joni.ast.Node)",
          "exception": "throw new InternalException(ErrorMessages.ERR_PARSER_BUG);",
          "pathCojunction": "(!(numMem >= num))",
          "symbolicPathConjunction": "(!(numMem >= num))",
          "backwardsPathConjunction": "(!(numMem >= num))",
          "simplifiedPathConjunction": "num > numMem",
          "z3Inputs": "[numMem0 = -1, num0 = 0]\n[numMem0 = -2, num0 = -1]\n[numMem0 = -3, num0 = -2]\n[numMem0 = -4, num0 = -3]\n[numMem0 = -5, num0 = -4]\n[numMem0 = -6, num0 = -5]\n[numMem0 = -7, num0 = -6]\n[numMem0 = -8, num0 = -7]\n[numMem0 = -9, num0 = -8]\n[numMem0 = -10, num0 = -9]\n",
          "z3Program": "from z3 import *\nfrom z3_all_models import *\n\nnum0 = Int('num0')\nnumMem0 = Int('numMem0')\n\nconstraints = [\n  Not(numMem0 >= num0)\n]\n\nsolver = Solver()\nfor constraint in constraints:\n  solver.add(constraint)\n\nmodels = list(all_smt(solver))\nfor model in models: print(model)",
          "symPyProgram": "from sympy import Symbol\nfrom sympy import simplify\nfrom sympy.core.relational import Eq, Ne, StrictGreaterThan, StrictLessThan, LessThan, GreaterThan\nfrom sympy.printing import ccode\n\nnum = Symbol('num', integer=True)\nnumMem = Symbol('numMem', integer=True)\npath_conjunction = (~((GreaterThan(numMem, num))))\nprint(ccode(simplify(path_conjunction)))",
          "soundSymbolic": true,
          "soundBackwards": true,
          "maybe": false,
          "line": 79,
          "throwingLine": 83,
          "isStatic": false,
          "targetOnlyArguments": false
        }
      ]
    },
    {
      "path": "/home/yanghengqin/jdk8u_nashorn/src/jdk/nashorn/internal/objects/GenericPropertyDescriptor.java",
      "methods": [
        {
          "qualifiedSignature": "jdk.nashorn.internal.objects.GenericPropertyDescriptor.getValue()",
          "exception": "throw new UnsupportedOperationException(\"value\");",
          "pathCojunction": "true",
          "backwardsPathConjunction": "true",
          "simplifiedPathConjunction": "true",
          "soundSymbolic": false,
          "soundBackwards": true,
          "maybe": false,
          "line": 81,
          "throwingLine": 82,
          "isStatic": false,
          "targetOnlyArguments": true
        },
        {
          "qualifiedSignature": "jdk.nashorn.internal.objects.GenericPropertyDescriptor.getGetter()",
          "exception": "throw new UnsupportedOperationException(\"get\");",
          "pathCojunction": "true",
          "backwardsPathConjunction": "true",
          "simplifiedPathConjunction": "true",
          "soundSymbolic": false,
          "soundBackwards": true,
          "maybe": false,
          "line": 86,
          "throwingLine": 87,
          "isStatic": false,
          "targetOnlyArguments": true
        },
        {
          "qualifiedSignature": "jdk.nashorn.internal.objects.GenericPropertyDescriptor.getSetter()",
          "exception": "throw new UnsupportedOperationException(\"set\");",
          "pathCojunction": "true",
          "backwardsPathConjunction": "true",
          "simplifiedPathConjunction": "true",
          "soundSymbolic": false,
          "soundBackwards": true,
          "maybe": false,
          "line": 91,
          "throwingLine": 92,
          "isStatic": false,
          "targetOnlyArguments": true
        },
        {
          "qualifiedSignature": "jdk.nashorn.internal.objects.GenericPropertyDescriptor.setWritable(boolean)",
          "exception": "throw new UnsupportedOperationException(\"set writable\");",
          "pathCojunction": "true",
          "backwardsPathConjunction": "true",
          "simplifiedPathConjunction": "true",
          "z3Program": "from z3 import *\nfrom z3_all_models import *\n\nflag0 = Bool('flag0')\n\nconstraints = [\n  True\n]\n\nsolver = Solver()\nfor constraint in constraints:\n  solver.add(constraint)\n\nmodels = list(all_smt(solver))\nfor model in models: print(model)",
          "soundSymbolic": false,
          "soundBackwards": true,
          "maybe": false,
          "line": 106,
          "throwingLine": 107,
          "isStatic": false,
          "targetOnlyArguments": true
        },
        {
          "qualifiedSignature": "jdk.nashorn.internal.objects.GenericPropertyDescriptor.setValue(java.lang.Object)",
          "exception": "throw new UnsupportedOperationException(\"set value\");",
          "pathCojunction": "true",
          "backwardsPathConjunction": "true",
          "simplifiedPathConjunction": "true",
          "z3Program": "from z3 import *\nfrom z3_all_models import *\n\n\nconstraints = [\n  True\n]\n\nsolver = Solver()\nfor constraint in constraints:\n  solver.add(constraint)\n\nmodels = list(all_smt(solver))\nfor model in models: print(model)",
          "soundSymbolic": false,
          "soundBackwards": true,
          "maybe": false,
          "line": 111,
          "throwingLine": 112,
          "isStatic": false,
          "targetOnlyArguments": true
        },
        {
          "qualifiedSignature": "jdk.nashorn.internal.objects.GenericPropertyDescriptor.setGetter(java.lang.Object)",
          "exception": "throw new UnsupportedOperationException(\"set getter\");",
          "pathCojunction": "true",
          "backwardsPathConjunction": "true",
          "simplifiedPathConjunction": "true",
          "z3Program": "from z3 import *\nfrom z3_all_models import *\n\n\nconstraints = [\n  True\n]\n\nsolver = Solver()\nfor constraint in constraints:\n  solver.add(constraint)\n\nmodels = list(all_smt(solver))\nfor model in models: print(model)",
          "soundSymbolic": false,
          "soundBackwards": true,
          "maybe": false,
          "line": 116,
          "throwingLine": 117,
          "isStatic": false,
          "targetOnlyArguments": true
        },
        {
          "qualifiedSignature": "jdk.nashorn.internal.objects.GenericPropertyDescriptor.setSetter(java.lang.Object)",
          "exception": "throw new UnsupportedOperationException(\"set setter\");",
          "pathCojunction": "true",
          "backwardsPathConjunction": "true",
          "simplifiedPathConjunction": "true",
          "z3Program": "from z3 import *\nfrom z3_all_models import *\n\n\nconstraints = [\n  True\n]\n\nsolver = Solver()\nfor constraint in constraints:\n  solver.add(constraint)\n\nmodels = list(all_smt(solver))\nfor model in models: print(model)",
          "soundSymbolic": false,
          "soundBackwards": true,
          "maybe": false,
          "line": 121,
          "throwingLine": 122,
          "isStatic": false,
          "targetOnlyArguments": true
        }
      ]
    },
    {
      "path": "/home/yanghengqin/jdk8u_nashorn/src/jdk/nashorn/internal/runtime/ErrorManager.java",
      "methods": [
        {
          "qualifiedSignature": "jdk.nashorn.internal.runtime.ErrorManager.error(jdk.nashorn.internal.runtime.ParserException)",
          "exception": "throw rangeError(\"too.many.errors\", Integer.toString(limit))",
          "pathCojunction": "(!(warningsAsErrors)) && (limit != 0 && errors > limit)",
          "symbolicPathConjunction": "(error(e.getMessage()))",
          "backwardsPathConjunction": "(!(warningsAsErrors)) && (limit != 0 && errors > limit)",
          "simplifiedPathConjunction": "!warningsAsErrors && errors > limit && limit != 0",
          "z3Inputs": "[limit0 = 1, errors0 = 2, warningsAsErrors0 = False]\n[limit0 = -1, errors0 = 0, warningsAsErrors0 = False]\n[limit0 = -2, errors0 = -1, warningsAsErrors0 = False]\n[limit0 = -2, errors0 = 0, warningsAsErrors0 = False]\n[limit0 = -3, errors0 = 0, warningsAsErrors0 = False]\n[limit0 = -4, errors0 = 0, warningsAsErrors0 = False]\n[limit0 = -5, errors0 = 0, warningsAsErrors0 = False]\n[limit0 = -6, errors0 = 0, warningsAsErrors0 = False]\n[limit0 = -7, errors0 = 0, warningsAsErrors0 = False]\n[limit0 = -8, errors0 = 0, warningsAsErrors0 = False]\n",
          "z3Program": "from z3 import *\nfrom z3_all_models import *\n\nwarningsAsErrors0 = Bool('warningsAsErrors0')\nlimit0 = Int('limit0')\nerrors0 = Int('errors0')\n\nconstraints = [\n  And(Not(warningsAsErrors0), And(limit0 != 0, errors0 > limit0))\n]\n\nsolver = Solver()\nfor constraint in constraints:\n  solver.add(constraint)\n\nmodels = list(all_smt(solver))\nfor model in models: print(model)",
          "symPyProgram": "from sympy import Symbol\nfrom sympy import simplify\nfrom sympy.core.relational import Eq, Ne, StrictGreaterThan, StrictLessThan, LessThan, GreaterThan\nfrom sympy.printing import ccode\n\nwarningsAsErrors = Symbol('warningsAsErrors')\nlimit = Symbol('limit', integer=True)\nerrors = Symbol('errors', integer=True)\npath_conjunction = ((~(warningsAsErrors)) & ((Ne(limit, 0)) & (StrictGreaterThan(errors, limit))))\nprint(ccode(simplify(path_conjunction)))",
          "soundSymbolic": true,
          "soundBackwards": true,
          "maybe": false,
          "line": 136,
          "throwingLine": 137,
          "isStatic": false,
          "targetOnlyArguments": false
        },
        {
          "qualifiedSignature": "jdk.nashorn.internal.runtime.ErrorManager.error(jdk.nashorn.internal.runtime.ParserException)",
          "exception": "throw rangeError(\"too.many.errors\", Integer.toString(limit))",
          "pathCojunction": "(warningsAsErrors) && (limit != 0 && count + warnings + warnings > limit)",
          "symbolicPathConjunction": "(error(e.getMessage()))",
          "backwardsPathConjunction": "(warningsAsErrors) && (limit != 0 && count + warnings + warnings + warnings + warnings > limit)",
          "z3Program": "from z3 import *\nfrom z3_all_models import *\n\nwarningsAsErrors0 = Bool('warningsAsErrors0')\nlimit0 = Int('limit0')\ncount0 = Int('count0')\n\nconstraints = [\n  count0 == count + warnings,\n  And(warningsAsErrors0, And(limit0 != 0, count0 + warnings + warnings > limit0))\n]\n\nsolver = Solver()\nfor constraint in constraints:\n  solver.add(constraint)\n\nmodels = list(all_smt(solver))\nfor model in models: print(model)",
          "symPyProgram": "from sympy import Symbol\nfrom sympy import simplify\nfrom sympy.core.relational import Eq, Ne, StrictGreaterThan, StrictLessThan, LessThan, GreaterThan\nfrom sympy.printing import ccode\n\nwarningsAsErrors = Symbol('warningsAsErrors')\nlimit = Symbol('limit', integer=True)\npath_conjunction = (warningsAsErrors & ((Ne(limit, 0)) & (StrictGreaterThan(((((count + warnings) + warnings) + warnings) + warnings), limit))))\nprint(ccode(simplify(path_conjunction)))",
          "soundSymbolic": true,
          "soundBackwards": false,
          "maybe": true,
          "line": 136,
          "throwingLine": 137,
          "isStatic": false,
          "targetOnlyArguments": false
        },
        {
          "qualifiedSignature": "jdk.nashorn.internal.runtime.ErrorManager.error(java.lang.String)",
          "exception": "throw rangeError(\"too.many.errors\", Integer.toString(limit));",
          "pathCojunction": "(warningsAsErrors) && (limit != 0 && count + warnings > limit)",
          "symbolicPathConjunction": "((warningsAsErrors) && (limit != 0 && count + warnings > limit))",
          "backwardsPathConjunction": "(warningsAsErrors) && (limit != 0 && count + warnings + warnings + warnings > limit)",
          "z3Program": "from z3 import *\nfrom z3_all_models import *\n\nmessage0 = String('message0')\nwarningsAsErrors0 = Bool('warningsAsErrors0')\nlimit0 = Int('limit0')\ncount0 = Int('count0')\n\nconstraints = [\n  count0 == count + warnings,\n  And(warningsAsErrors0, And(limit0 != 0, count0 + warnings > limit0))\n]\n\nsolver = Solver()\nfor constraint in constraints:\n  solver.add(constraint)\n\nmodels = list(all_smt(solver))\nfor model in models: print(model)",
          "symPyProgram": "from sympy import Symbol\nfrom sympy import simplify\nfrom sympy.core.relational import Eq, Ne, StrictGreaterThan, StrictLessThan, LessThan, GreaterThan\nfrom sympy.printing import ccode\n\nwarningsAsErrors = Symbol('warningsAsErrors')\nlimit = Symbol('limit', integer=True)\npath_conjunction = (warningsAsErrors & ((Ne(limit, 0)) & (StrictGreaterThan((((count + warnings) + warnings) + warnings), limit))))\nprint(ccode(simplify(path_conjunction)))",
          "soundSymbolic": false,
          "soundBackwards": false,
          "maybe": true,
          "line": 145,
          "throwingLine": 149,
          "isStatic": false,
          "targetOnlyArguments": false
        },
        {
          "qualifiedSignature": "jdk.nashorn.internal.runtime.ErrorManager.error(java.lang.String)",
          "exception": "throw rangeError(\"too.many.errors\", Integer.toString(limit));",
          "pathCojunction": "(!(warningsAsErrors)) && (limit != 0 && errors > limit)",
          "symbolicPathConjunction": "((!(warningsAsErrors)) && (limit != 0 && errors > limit))",
          "backwardsPathConjunction": "(!(warningsAsErrors)) && (limit != 0 && errors > limit)",
          "simplifiedPathConjunction": "!warningsAsErrors && errors > limit && limit != 0",
          "z3Inputs": "[limit0 = 1, errors0 = 2, warningsAsErrors0 = False]\n[limit0 = -1, errors0 = 0, warningsAsErrors0 = False]\n[limit0 = -2, errors0 = -1, warningsAsErrors0 = False]\n[limit0 = -2, errors0 = 0, warningsAsErrors0 = False]\n[limit0 = -3, errors0 = 0, warningsAsErrors0 = False]\n[limit0 = -4, errors0 = 0, warningsAsErrors0 = False]\n[limit0 = -5, errors0 = 0, warningsAsErrors0 = False]\n[limit0 = -6, errors0 = 0, warningsAsErrors0 = False]\n[limit0 = -7, errors0 = 0, warningsAsErrors0 = False]\n[limit0 = -8, errors0 = 0, warningsAsErrors0 = False]\n",
          "z3Program": "from z3 import *\nfrom z3_all_models import *\n\nmessage0 = String('message0')\nwarningsAsErrors0 = Bool('warningsAsErrors0')\nlimit0 = Int('limit0')\nerrors0 = Int('errors0')\n\nconstraints = [\n  And(Not(warningsAsErrors0), And(limit0 != 0, errors0 > limit0))\n]\n\nsolver = Solver()\nfor constraint in constraints:\n  solver.add(constraint)\n\nmodels = list(all_smt(solver))\nfor model in models: print(model)",
          "symPyProgram": "from sympy import Symbol\nfrom sympy import simplify\nfrom sympy.core.relational import Eq, Ne, StrictGreaterThan, StrictLessThan, LessThan, GreaterThan\nfrom sympy.printing import ccode\n\nwarningsAsErrors = Symbol('warningsAsErrors')\nlimit = Symbol('limit', integer=True)\nerrors = Symbol('errors', integer=True)\npath_conjunction = ((~(warningsAsErrors)) & ((Ne(limit, 0)) & (StrictGreaterThan(errors, limit))))\nprint(ccode(simplify(path_conjunction)))",
          "soundSymbolic": false,
          "soundBackwards": true,
          "maybe": false,
          "line": 145,
          "throwingLine": 149,
          "isStatic": false,
          "targetOnlyArguments": false
        },
        {
          "qualifiedSignature": "jdk.nashorn.internal.runtime.ErrorManager.warning(jdk.nashorn.internal.runtime.ParserException)",
          "exception": "throw rangeError(\"too.many.errors\", Integer.toString(limit))",
          "pathCojunction": "(warningsAsErrors) && (limit != 0 && count + warnings + warnings > limit)",
          "symbolicPathConjunction": "(warning(e.getMessage()))",
          "backwardsPathConjunction": "(warningsAsErrors) && (limit != 0 && count + warnings + warnings + warnings + warnings > limit)",
          "z3Program": "from z3 import *\nfrom z3_all_models import *\n\nwarningsAsErrors0 = Bool('warningsAsErrors0')\nlimit0 = Int('limit0')\ncount0 = Int('count0')\n\nconstraints = [\n  count0 == count + warnings,\n  And(warningsAsErrors0, And(limit0 != 0, count0 + warnings + warnings > limit0))\n]\n\nsolver = Solver()\nfor constraint in constraints:\n  solver.add(constraint)\n\nmodels = list(all_smt(solver))\nfor model in models: print(model)",
          "symPyProgram": "from sympy import Symbol\nfrom sympy import simplify\nfrom sympy.core.relational import Eq, Ne, StrictGreaterThan, StrictLessThan, LessThan, GreaterThan\nfrom sympy.printing import ccode\n\nwarningsAsErrors = Symbol('warningsAsErrors')\nlimit = Symbol('limit', integer=True)\npath_conjunction = (warningsAsErrors & ((Ne(limit, 0)) & (StrictGreaterThan(((((count + warnings) + warnings) + warnings) + warnings), limit))))\nprint(ccode(simplify(path_conjunction)))",
          "soundSymbolic": true,
          "soundBackwards": false,
          "maybe": true,
          "line": 157,
          "throwingLine": 158,
          "isStatic": false,
          "targetOnlyArguments": false
        },
        {
          "qualifiedSignature": "jdk.nashorn.internal.runtime.ErrorManager.warning(jdk.nashorn.internal.runtime.ParserException)",
          "exception": "throw rangeError(\"too.many.errors\", Integer.toString(limit))",
          "pathCojunction": "(!(warningsAsErrors)) && (limit != 0 && errors > limit)",
          "symbolicPathConjunction": "(warning(e.getMessage()))",
          "backwardsPathConjunction": "(!(warningsAsErrors)) && (limit != 0 && errors > limit)",
          "simplifiedPathConjunction": "!warningsAsErrors && errors > limit && limit != 0",
          "z3Inputs": "[limit0 = 1, errors0 = 2, warningsAsErrors0 = False]\n[limit0 = -1, errors0 = 0, warningsAsErrors0 = False]\n[limit0 = -2, errors0 = -1, warningsAsErrors0 = False]\n[limit0 = -2, errors0 = 0, warningsAsErrors0 = False]\n[limit0 = -3, errors0 = 0, warningsAsErrors0 = False]\n[limit0 = -4, errors0 = 0, warningsAsErrors0 = False]\n[limit0 = -5, errors0 = 0, warningsAsErrors0 = False]\n[limit0 = -6, errors0 = 0, warningsAsErrors0 = False]\n[limit0 = -7, errors0 = 0, warningsAsErrors0 = False]\n[limit0 = -8, errors0 = 0, warningsAsErrors0 = False]\n",
          "z3Program": "from z3 import *\nfrom z3_all_models import *\n\nwarningsAsErrors0 = Bool('warningsAsErrors0')\nlimit0 = Int('limit0')\nerrors0 = Int('errors0')\n\nconstraints = [\n  And(Not(warningsAsErrors0), And(limit0 != 0, errors0 > limit0))\n]\n\nsolver = Solver()\nfor constraint in constraints:\n  solver.add(constraint)\n\nmodels = list(all_smt(solver))\nfor model in models: print(model)",
          "symPyProgram": "from sympy import Symbol\nfrom sympy import simplify\nfrom sympy.core.relational import Eq, Ne, StrictGreaterThan, StrictLessThan, LessThan, GreaterThan\nfrom sympy.printing import ccode\n\nwarningsAsErrors = Symbol('warningsAsErrors')\nlimit = Symbol('limit', integer=True)\nerrors = Symbol('errors', integer=True)\npath_conjunction = ((~(warningsAsErrors)) & ((Ne(limit, 0)) & (StrictGreaterThan(errors, limit))))\nprint(ccode(simplify(path_conjunction)))",
          "soundSymbolic": true,
          "soundBackwards": true,
          "maybe": false,
          "line": 157,
          "throwingLine": 158,
          "isStatic": false,
          "targetOnlyArguments": false
        },
        {
          "qualifiedSignature": "jdk.nashorn.internal.runtime.ErrorManager.warning(java.lang.String)",
          "exception": "throw rangeError(\"too.many.errors\", Integer.toString(limit));",
          "pathCojunction": "(warningsAsErrors) && (limit != 0 && count + warnings > limit)",
          "symbolicPathConjunction": "((warningsAsErrors) && (limit != 0 && count + warnings + warnings + warnings + warnings + warnings + warnings + warnings + warnings + warnings + warnings + warnings + warnings + warnings + warnings > limit))",
          "backwardsPathConjunction": "(warningsAsErrors) && (limit != 0 && count + warnings + warnings + warnings > limit)",
          "z3Program": "from z3 import *\nfrom z3_all_models import *\n\nmessage0 = String('message0')\nwarningsAsErrors0 = Bool('warningsAsErrors0')\nlimit0 = Int('limit0')\ncount0 = Int('count0')\n\nconstraints = [\n  count0 == count + warnings,\n  And(warningsAsErrors0, And(limit0 != 0, count0 + warnings > limit0))\n]\n\nsolver = Solver()\nfor constraint in constraints:\n  solver.add(constraint)\n\nmodels = list(all_smt(solver))\nfor model in models: print(model)",
          "symPyProgram": "from sympy import Symbol\nfrom sympy import simplify\nfrom sympy.core.relational import Eq, Ne, StrictGreaterThan, StrictLessThan, LessThan, GreaterThan\nfrom sympy.printing import ccode\n\nwarningsAsErrors = Symbol('warningsAsErrors')\nlimit = Symbol('limit', integer=True)\npath_conjunction = (warningsAsErrors & ((Ne(limit, 0)) & (StrictGreaterThan((((count + warnings) + warnings) + warnings), limit))))\nprint(ccode(simplify(path_conjunction)))",
          "soundSymbolic": false,
          "soundBackwards": false,
          "maybe": true,
          "line": 166,
          "throwingLine": 170,
          "isStatic": false,
          "targetOnlyArguments": false
        },
        {
          "qualifiedSignature": "jdk.nashorn.internal.runtime.ErrorManager.warning(java.lang.String)",
          "exception": "throw rangeError(\"too.many.errors\", Integer.toString(limit));",
          "pathCojunction": "(!(warningsAsErrors)) && (limit != 0 && errors > limit)",
          "symbolicPathConjunction": "((!(warningsAsErrors)) && (limit != 0 && errors > limit))",
          "backwardsPathConjunction": "(!(warningsAsErrors)) && (limit != 0 && errors > limit)",
          "simplifiedPathConjunction": "!warningsAsErrors && errors > limit && limit != 0",
          "z3Inputs": "[limit0 = 1, errors0 = 2, warningsAsErrors0 = False]\n[limit0 = -1, errors0 = 0, warningsAsErrors0 = False]\n[limit0 = -2, errors0 = -1, warningsAsErrors0 = False]\n[limit0 = -2, errors0 = 0, warningsAsErrors0 = False]\n[limit0 = -3, errors0 = 0, warningsAsErrors0 = False]\n[limit0 = -4, errors0 = 0, warningsAsErrors0 = False]\n[limit0 = -5, errors0 = 0, warningsAsErrors0 = False]\n[limit0 = -6, errors0 = 0, warningsAsErrors0 = False]\n[limit0 = -7, errors0 = 0, warningsAsErrors0 = False]\n[limit0 = -8, errors0 = 0, warningsAsErrors0 = False]\n",
          "z3Program": "from z3 import *\nfrom z3_all_models import *\n\nmessage0 = String('message0')\nwarningsAsErrors0 = Bool('warningsAsErrors0')\nlimit0 = Int('limit0')\nerrors0 = Int('errors0')\n\nconstraints = [\n  And(Not(warningsAsErrors0), And(limit0 != 0, errors0 > limit0))\n]\n\nsolver = Solver()\nfor constraint in constraints:\n  solver.add(constraint)\n\nmodels = list(all_smt(solver))\nfor model in models: print(model)",
          "symPyProgram": "from sympy import Symbol\nfrom sympy import simplify\nfrom sympy.core.relational import Eq, Ne, StrictGreaterThan, StrictLessThan, LessThan, GreaterThan\nfrom sympy.printing import ccode\n\nwarningsAsErrors = Symbol('warningsAsErrors')\nlimit = Symbol('limit', integer=True)\nerrors = Symbol('errors', integer=True)\npath_conjunction = ((~(warningsAsErrors)) & ((Ne(limit, 0)) & (StrictGreaterThan(errors, limit))))\nprint(ccode(simplify(path_conjunction)))",
          "soundSymbolic": false,
          "soundBackwards": true,
          "maybe": false,
          "line": 166,
          "throwingLine": 170,
          "isStatic": false,
          "targetOnlyArguments": false
        }
      ]
    },
    {
      "path": "/home/yanghengqin/jdk8u_nashorn/src/jdk/nashorn/internal/objects/Global.java",
      "methods": [
        {
          "qualifiedSignature": "jdk.nashorn.internal.objects.Global.toObject(java.lang.Object)",
          "exception": "throw typeError(\"not.an.object\", ScriptRuntime.safeToString(obj));",
          "pathCojunction": "(obj == null || obj == UNDEFINED)",
          "symbolicPathConjunction": "(obj == null || obj == UNDEFINED)",
          "backwardsPathConjunction": "(obj == null || obj == UNDEFINED)",
          "z3Program": "from z3 import *\nfrom z3_all_models import *\n\nobj0_isNull = Bool('obj0_isNull')\n\nconstraints = [\n  Or(obj0_isNull, obj0 == UNDEFINED)\n]\n\nsolver = Solver()\nfor constraint in constraints:\n  solver.add(constraint)\n\nmodels = list(all_smt(solver))\nfor model in models: print(model)",
          "symPyProgram": "from sympy import Symbol\nfrom sympy import simplify\nfrom sympy.core.relational import Eq, Ne, StrictGreaterThan, StrictLessThan, LessThan, GreaterThan\nfrom sympy.printing import ccode\n\nobj = Symbol('obj')\nnull = Symbol('null')\npath_conjunction = ((Eq(obj, null)) | (Eq(obj, UNDEFINED)))\nprint(ccode(simplify(path_conjunction)))",
          "soundSymbolic": true,
          "soundBackwards": false,
          "maybe": true,
          "line": 1945,
          "throwingLine": 1947,
          "isStatic": true,
          "targetOnlyArguments": false
        },
        {
          "qualifiedSignature": "jdk.nashorn.internal.objects.Global.checkObjectCoercible(java.lang.Object)",
          "exception": "throw typeError(\"not.an.object\", ScriptRuntime.safeToString(obj));",
          "pathCojunction": "(obj == null || obj == UNDEFINED)",
          "symbolicPathConjunction": "(obj == null || obj == UNDEFINED)",
          "backwardsPathConjunction": "(obj == null || obj == UNDEFINED)",
          "z3Program": "from z3 import *\nfrom z3_all_models import *\n\nobj0_isNull = Bool('obj0_isNull')\n\nconstraints = [\n  Or(obj0_isNull, obj0 == UNDEFINED)\n]\n\nsolver = Solver()\nfor constraint in constraints:\n  solver.add(constraint)\n\nmodels = list(all_smt(solver))\nfor model in models: print(model)",
          "symPyProgram": "from sympy import Symbol\nfrom sympy import simplify\nfrom sympy.core.relational import Eq, Ne, StrictGreaterThan, StrictLessThan, LessThan, GreaterThan\nfrom sympy.printing import ccode\n\nobj = Symbol('obj')\nnull = Symbol('null')\npath_conjunction = ((Eq(obj, null)) | (Eq(obj, UNDEFINED)))\nprint(ccode(simplify(path_conjunction)))",
          "soundSymbolic": true,
          "soundBackwards": false,
          "maybe": true,
          "line": 2094,
          "throwingLine": 2096,
          "isStatic": true,
          "targetOnlyArguments": false
        }
      ]
    },
    {
      "path": "/home/yanghengqin/jdk8u_nashorn/src/jdk/nashorn/internal/runtime/arrays/JavaArrayIterator.java",
      "methods": [
        {
          "qualifiedSignature": "jdk.nashorn.internal.runtime.arrays.JavaArrayIterator.remove()",
          "exception": "throw new UnsupportedOperationException(\"remove\");",
          "pathCojunction": "true",
          "backwardsPathConjunction": "true",
          "simplifiedPathConjunction": "true",
          "soundSymbolic": false,
          "soundBackwards": true,
          "maybe": false,
          "line": 77,
          "throwingLine": 78,
          "isStatic": false,
          "targetOnlyArguments": true
        }
      ]
    },
    {
      "path": "/home/yanghengqin/jdk8u_nashorn/src/jdk/nashorn/internal/runtime/arrays/EmptyArrayLikeIterator.java",
      "methods": [
        {
          "qualifiedSignature": "jdk.nashorn.internal.runtime.arrays.EmptyArrayLikeIterator.next()",
          "exception": "throw new NoSuchElementException();",
          "pathCojunction": "true",
          "backwardsPathConjunction": "true",
          "simplifiedPathConjunction": "true",
          "soundSymbolic": false,
          "soundBackwards": true,
          "maybe": false,
          "line": 45,
          "throwingLine": 46,
          "isStatic": false,
          "targetOnlyArguments": true
        }
      ]
    },
    {
      "path": "/home/yanghengqin/jdk8u_nashorn/src/jdk/nashorn/internal/runtime/CodeStore.java",
      "methods": [
        {
          "qualifiedSignature": "jdk.nashorn.internal.runtime.CodeStore.DirectoryCodeStore.Anonymous-53311659-0b90-48d7-93bd-62672bdd95a8.run()",
          "exception": "throw new IOException(\"Not a directory: \" + dir.getPath());",
          "pathCojunction": "(!(readOnly)) && (!(!dir.exists() && !dir.mkdirs())) && (!(dir.isDirectory()))",
          "symbolicPathConjunction": "(!(readOnly)) && (!(!dir.exists() && !dir.mkdirs())) && (!dir.isDirectory())",
          "backwardsPathConjunction": "(!(readOnly)) && (!(!dir.exists() && !dir.mkdirs())) && (!(dir.isDirectory()))",
          "z3Program": "from z3 import *\nfrom z3_all_models import *\n\nreadOnly0 = Bool('readOnly0')\n\nconstraints = [\n  dir0 == new File(path, getVersionDir(env)).getAbsoluteFile(),\n  And(And(Not(readOnly0), Not(And(Not(dir0.exists()), Not(dir0.mkdirs())))), Not(dir0.isDirectory()))\n]\n\nsolver = Solver()\nfor constraint in constraints:\n  solver.add(constraint)\n\nmodels = list(all_smt(solver))\nfor model in models: print(model)",
          "symPyProgram": "from sympy import Symbol\nfrom sympy import simplify\nfrom sympy.core.relational import Eq, Ne, StrictGreaterThan, StrictLessThan, LessThan, GreaterThan\nfrom sympy.printing import ccode\n\nreadOnly = Symbol('readOnly')\nnew File(path, getVersionDir(env))_getAbsoluteFile_exists = Symbol('new File(path, getVersionDir(env))_getAbsoluteFile_exists')\nnew File(path, getVersionDir(env))_getAbsoluteFile = Symbol('new File(path, getVersionDir(env))_getAbsoluteFile')\n_getVersionDir = Symbol('_getVersionDir')\nnew File(path, getVersionDir(env))_getAbsoluteFile_mkdirs = Symbol('new File(path, getVersionDir(env))_getAbsoluteFile_mkdirs')\nnew File(path, getVersionDir(env))_getAbsoluteFile_isDirectory = Symbol('new File(path, getVersionDir(env))_getAbsoluteFile_isDirectory')\npath_conjunction = (((~(readOnly)) & (~(((~(new File(path, getVersionDir(env))_getAbsoluteFile_exists)) & (~(new File(path, getVersionDir(env))_getAbsoluteFile_mkdirs)))))) & (~(new File(path, getVersionDir(env))_getAbsoluteFile_isDirectory)))\nprint(ccode(simplify(path_conjunction)))",
          "soundSymbolic": false,
          "soundBackwards": true,
          "maybe": true,
          "line": 244,
          "throwingLine": 255,
          "isStatic": false,
          "targetOnlyArguments": false
        },
        {
          "qualifiedSignature": "jdk.nashorn.internal.runtime.CodeStore.DirectoryCodeStore.Anonymous-53311659-0b90-48d7-93bd-62672bdd95a8.run()",
          "exception": "throw new IOException(\"Directory not readable or writable: \" + dir.getPath());",
          "pathCojunction": "(!(readOnly)) && (!(!dir.exists() && !dir.mkdirs())) && (!(!dir.isDirectory())) && (!dir.canRead() || !dir.canWrite())",
          "symbolicPathConjunction": "(!(readOnly)) && (!(!dir.exists() && !dir.mkdirs())) && (!(!dir.isDirectory())) && (!dir.canRead() || !dir.canWrite())",
          "backwardsPathConjunction": "(!(readOnly)) && (!(!dir.exists() && !dir.mkdirs())) && (!(!dir.isDirectory())) && (!dir.canRead() || !dir.canWrite())",
          "z3Program": "from z3 import *\nfrom z3_all_models import *\n\nreadOnly0 = Bool('readOnly0')\n\nconstraints = [\n  dir0 == new File(path, getVersionDir(env)).getAbsoluteFile(),\n  And(And(And(Not(readOnly0), Not(And(Not(dir0.exists()), Not(dir0.mkdirs())))), Not(Not(dir0.isDirectory()))), Or(Not(dir0.canRead()), Not(dir0.canWrite())))\n]\n\nsolver = Solver()\nfor constraint in constraints:\n  solver.add(constraint)\n\nmodels = list(all_smt(solver))\nfor model in models: print(model)",
          "symPyProgram": "from sympy import Symbol\nfrom sympy import simplify\nfrom sympy.core.relational import Eq, Ne, StrictGreaterThan, StrictLessThan, LessThan, GreaterThan\nfrom sympy.printing import ccode\n\nreadOnly = Symbol('readOnly')\nnew File(path, getVersionDir(env))_getAbsoluteFile_exists = Symbol('new File(path, getVersionDir(env))_getAbsoluteFile_exists')\nnew File(path, getVersionDir(env))_getAbsoluteFile = Symbol('new File(path, getVersionDir(env))_getAbsoluteFile')\n_getVersionDir = Symbol('_getVersionDir')\nnew File(path, getVersionDir(env))_getAbsoluteFile_mkdirs = Symbol('new File(path, getVersionDir(env))_getAbsoluteFile_mkdirs')\nnew File(path, getVersionDir(env))_getAbsoluteFile_isDirectory = Symbol('new File(path, getVersionDir(env))_getAbsoluteFile_isDirectory')\nnew File(path, getVersionDir(env))_getAbsoluteFile_canRead = Symbol('new File(path, getVersionDir(env))_getAbsoluteFile_canRead')\nnew File(path, getVersionDir(env))_getAbsoluteFile_canWrite = Symbol('new File(path, getVersionDir(env))_getAbsoluteFile_canWrite')\npath_conjunction = ((((~(readOnly)) & (~(((~(new File(path, getVersionDir(env))_getAbsoluteFile_exists)) & (~(new File(path, getVersionDir(env))_getAbsoluteFile_mkdirs)))))) & (~((~(new File(path, getVersionDir(env))_getAbsoluteFile_isDirectory))))) & ((~(new File(path, getVersionDir(env))_getAbsoluteFile_canRead)) | (~(new File(path, getVersionDir(env))_getAbsoluteFile_canWrite))))\nprint(ccode(simplify(path_conjunction)))",
          "soundSymbolic": false,
          "soundBackwards": true,
          "maybe": true,
          "line": 244,
          "throwingLine": 257,
          "isStatic": false,
          "targetOnlyArguments": false
        },
        {
          "qualifiedSignature": "jdk.nashorn.internal.runtime.CodeStore.DirectoryCodeStore.Anonymous-53311659-0b90-48d7-93bd-62672bdd95a8.run()",
          "exception": "throw new IOException(\"Could not create directory: \" + dir.getPath());",
          "pathCojunction": "(!(readOnly)) && (!dir.exists() && !dir.mkdirs())",
          "symbolicPathConjunction": "(!(readOnly)) && (!dir.exists() && !dir.mkdirs())",
          "backwardsPathConjunction": "(!(readOnly)) && (!dir.exists() && !dir.mkdirs())",
          "z3Program": "from z3 import *\nfrom z3_all_models import *\n\nreadOnly0 = Bool('readOnly0')\n\nconstraints = [\n  dir0 == new File(path, getVersionDir(env)).getAbsoluteFile(),\n  And(Not(readOnly0), And(Not(dir0.exists()), Not(dir0.mkdirs())))\n]\n\nsolver = Solver()\nfor constraint in constraints:\n  solver.add(constraint)\n\nmodels = list(all_smt(solver))\nfor model in models: print(model)",
          "symPyProgram": "from sympy import Symbol\nfrom sympy import simplify\nfrom sympy.core.relational import Eq, Ne, StrictGreaterThan, StrictLessThan, LessThan, GreaterThan\nfrom sympy.printing import ccode\n\nreadOnly = Symbol('readOnly')\nnew File(path, getVersionDir(env))_getAbsoluteFile_exists = Symbol('new File(path, getVersionDir(env))_getAbsoluteFile_exists')\nnew File(path, getVersionDir(env))_getAbsoluteFile = Symbol('new File(path, getVersionDir(env))_getAbsoluteFile')\n_getVersionDir = Symbol('_getVersionDir')\nnew File(path, getVersionDir(env))_getAbsoluteFile_mkdirs = Symbol('new File(path, getVersionDir(env))_getAbsoluteFile_mkdirs')\npath_conjunction = ((~(readOnly)) & ((~(new File(path, getVersionDir(env))_getAbsoluteFile_exists)) & (~(new File(path, getVersionDir(env))_getAbsoluteFile_mkdirs))))\nprint(ccode(simplify(path_conjunction)))",
          "soundSymbolic": false,
          "soundBackwards": true,
          "maybe": true,
          "line": 244,
          "throwingLine": 253,
          "isStatic": false,
          "targetOnlyArguments": false
        },
        {
          "qualifiedSignature": "jdk.nashorn.internal.runtime.CodeStore.DirectoryCodeStore.Anonymous-53311659-0b90-48d7-93bd-62672bdd95a8.run()",
          "exception": "throw new IOException(\"Directory not readable: \" + dir.getPath());",
          "pathCojunction": "(readOnly) && (!(!dir.exists() || !dir.isDirectory())) && (!(dir.canRead()))",
          "symbolicPathConjunction": "(readOnly) && (!(!dir.exists() || !dir.isDirectory())) && (!dir.canRead())",
          "backwardsPathConjunction": "(readOnly) && (!(!dir.exists() || !dir.isDirectory())) && (!(dir.canRead()))",
          "z3Program": "from z3 import *\nfrom z3_all_models import *\n\nreadOnly0 = Bool('readOnly0')\n\nconstraints = [\n  dir0 == new File(path, getVersionDir(env)).getAbsoluteFile(),\n  And(And(readOnly0, Not(Or(Not(dir0.exists()), Not(dir0.isDirectory())))), Not(dir0.canRead()))\n]\n\nsolver = Solver()\nfor constraint in constraints:\n  solver.add(constraint)\n\nmodels = list(all_smt(solver))\nfor model in models: print(model)",
          "symPyProgram": "from sympy import Symbol\nfrom sympy import simplify\nfrom sympy.core.relational import Eq, Ne, StrictGreaterThan, StrictLessThan, LessThan, GreaterThan\nfrom sympy.printing import ccode\n\nreadOnly = Symbol('readOnly')\nnew File(path, getVersionDir(env))_getAbsoluteFile_exists = Symbol('new File(path, getVersionDir(env))_getAbsoluteFile_exists')\nnew File(path, getVersionDir(env))_getAbsoluteFile = Symbol('new File(path, getVersionDir(env))_getAbsoluteFile')\n_getVersionDir = Symbol('_getVersionDir')\nnew File(path, getVersionDir(env))_getAbsoluteFile_isDirectory = Symbol('new File(path, getVersionDir(env))_getAbsoluteFile_isDirectory')\nnew File(path, getVersionDir(env))_getAbsoluteFile_canRead = Symbol('new File(path, getVersionDir(env))_getAbsoluteFile_canRead')\npath_conjunction = ((readOnly & (~(((~(new File(path, getVersionDir(env))_getAbsoluteFile_exists)) | (~(new File(path, getVersionDir(env))_getAbsoluteFile_isDirectory)))))) & (~(new File(path, getVersionDir(env))_getAbsoluteFile_canRead)))\nprint(ccode(simplify(path_conjunction)))",
          "soundSymbolic": false,
          "soundBackwards": true,
          "maybe": true,
          "line": 244,
          "throwingLine": 250,
          "isStatic": false,
          "targetOnlyArguments": false
        },
        {
          "qualifiedSignature": "jdk.nashorn.internal.runtime.CodeStore.DirectoryCodeStore.Anonymous-53311659-0b90-48d7-93bd-62672bdd95a8.run()",
          "exception": "throw new IOException(\"Not a directory: \" + dir.getPath());",
          "pathCojunction": "(readOnly) && (!dir.exists() || !dir.isDirectory())",
          "symbolicPathConjunction": "(readOnly) && (!dir.exists() || !dir.isDirectory())",
          "backwardsPathConjunction": "(readOnly) && (!dir.exists() || !dir.isDirectory())",
          "z3Program": "from z3 import *\nfrom z3_all_models import *\n\nreadOnly0 = Bool('readOnly0')\n\nconstraints = [\n  dir0 == new File(path, getVersionDir(env)).getAbsoluteFile(),\n  And(readOnly0, Or(Not(dir0.exists()), Not(dir0.isDirectory())))\n]\n\nsolver = Solver()\nfor constraint in constraints:\n  solver.add(constraint)\n\nmodels = list(all_smt(solver))\nfor model in models: print(model)",
          "symPyProgram": "from sympy import Symbol\nfrom sympy import simplify\nfrom sympy.core.relational import Eq, Ne, StrictGreaterThan, StrictLessThan, LessThan, GreaterThan\nfrom sympy.printing import ccode\n\nreadOnly = Symbol('readOnly')\nnew File(path, getVersionDir(env))_getAbsoluteFile_exists = Symbol('new File(path, getVersionDir(env))_getAbsoluteFile_exists')\nnew File(path, getVersionDir(env))_getAbsoluteFile = Symbol('new File(path, getVersionDir(env))_getAbsoluteFile')\n_getVersionDir = Symbol('_getVersionDir')\nnew File(path, getVersionDir(env))_getAbsoluteFile_isDirectory = Symbol('new File(path, getVersionDir(env))_getAbsoluteFile_isDirectory')\npath_conjunction = (readOnly & ((~(new File(path, getVersionDir(env))_getAbsoluteFile_exists)) | (~(new File(path, getVersionDir(env))_getAbsoluteFile_isDirectory))))\nprint(ccode(simplify(path_conjunction)))",
          "soundSymbolic": false,
          "soundBackwards": true,
          "maybe": true,
          "line": 244,
          "throwingLine": 248,
          "isStatic": false,
          "targetOnlyArguments": false
        }
      ]
    },
    {
      "path": "/home/yanghengqin/jdk8u_nashorn/src/jdk/nashorn/internal/runtime/PropertyMap.java",
      "methods": [
        {
          "qualifiedSignature": "jdk.nashorn.internal.runtime.PropertyMap.PropertyMapIterator.next()",
          "exception": "throw new NoSuchElementException();",
          "pathCojunction": "(property == null)",
          "symbolicPathConjunction": "(property == null)",
          "backwardsPathConjunction": "(property == null)",
          "simplifiedPathConjunction": "null == property",
          "z3Inputs": "[property0_isNull = True]\n",
          "z3Program": "from z3 import *\nfrom z3_all_models import *\n\nproperty0_isNull = Bool('property0_isNull')\n\nconstraints = [\n  property0_isNull\n]\n\nsolver = Solver()\nfor constraint in constraints:\n  solver.add(constraint)\n\nmodels = list(all_smt(solver))\nfor model in models: print(model)",
          "symPyProgram": "from sympy import Symbol\nfrom sympy import simplify\nfrom sympy.core.relational import Eq, Ne, StrictGreaterThan, StrictLessThan, LessThan, GreaterThan\nfrom sympy.printing import ccode\n\nproperty = Symbol('property')\nnull = Symbol('null')\npath_conjunction = (Eq(property, null))\nprint(ccode(simplify(path_conjunction)))",
          "soundSymbolic": true,
          "soundBackwards": true,
          "maybe": false,
          "line": 1031,
          "throwingLine": 1033,
          "isStatic": false,
          "targetOnlyArguments": false
        },
        {
          "qualifiedSignature": "jdk.nashorn.internal.runtime.PropertyMap.PropertyMapIterator.remove()",
          "exception": "throw new UnsupportedOperationException(\"remove\");",
          "pathCojunction": "true",
          "backwardsPathConjunction": "true",
          "simplifiedPathConjunction": "true",
          "soundSymbolic": false,
          "soundBackwards": true,
          "maybe": false,
          "line": 1044,
          "throwingLine": 1045,
          "isStatic": false,
          "targetOnlyArguments": true
        }
      ]
    },
    {
      "path": "/home/yanghengqin/jdk8u_nashorn/src/jdk/internal/dynalink/support/TypeConverterFactory.java",
      "methods": [
        {
          "qualifiedSignature": "jdk.internal.dynalink.support.TypeConverterFactory.asType(java.lang.invoke.MethodHandle, java.lang.invoke.MethodType)",
          "exception": "throw new WrongMethodTypeException(\"Parameter counts differ: \" + handle.type() + \" vs. \" + fromType);",
          "pathCojunction": "(l != fromType.parameterCount())",
          "symbolicPathConjunction": "(l != fromType.parameterCount())",
          "backwardsPathConjunction": "(newHandle.type().parameterCount() != fromType.parameterCount())",
          "simplifiedPathConjunction": "fromType.parameterCount() != newHandle.type().parameterCount()",
          "z3Program": "from z3 import *\nfrom z3_all_models import *\n\nl0 = Int('l0')\n\nconstraints = [\n  newHandle0 == handle0,\n  toType0 == newHandle0.type(),\n  l0 == toType0.parameterCount(),\n  l0 != fromType0.parameterCount()\n]\n\nsolver = Solver()\nfor constraint in constraints:\n  solver.add(constraint)\n\nmodels = list(all_smt(solver))\nfor model in models: print(model)",
          "symPyProgram": "from sympy import Symbol\nfrom sympy import simplify\nfrom sympy.core.relational import Eq, Ne, StrictGreaterThan, StrictLessThan, LessThan, GreaterThan\nfrom sympy.printing import ccode\n\nfromType = Symbol('fromType')\nnewHandle_type_parameterCount = Symbol('newHandle_type_parameterCount')\nnewHandle_type = Symbol('newHandle_type')\nfromType_parameterCount = Symbol('fromType_parameterCount')\npath_conjunction = (Ne(newHandle_type_parameterCount, fromType_parameterCount))\nprint(ccode(simplify(path_conjunction)))",
          "soundSymbolic": false,
          "soundBackwards": false,
          "maybe": true,
          "line": 231,
          "throwingLine": 236,
          "isStatic": false,
          "targetOnlyArguments": false
        }
      ]
    },
    {
      "path": "/home/yanghengqin/jdk8u_nashorn/src/jdk/nashorn/internal/objects/NativeArray.java",
      "methods": [
        {
          "qualifiedSignature": "jdk.nashorn.internal.objects.NativeArray.defineOwnProperty(java.lang.String, java.lang.Object, boolean)",
          "exception": "throw typeError(\"cant.redefine.property\", key, ScriptRuntime.safeToString(this));",
          "pathCojunction": "(!(\"length\".equals(key))) && (ArrayIndex.isValidArrayIndex(index)) && (!(longIndex >= oldLen && !oldLenDesc.isWritable())) && (!(succeeded)) && (reject)",
          "symbolicPathConjunction": "(!(\"length\".equals(key))) && (ArrayIndex.isValidArrayIndex(index)) && (!(longIndex >= oldLen && !oldLenDesc.isWritable())) && (!(succeeded)) && (reject)",
          "backwardsPathConjunction": "(!(\"length\".equals(key))) && (ArrayIndex.isValidArrayIndex(ArrayIndex.getArrayIndex(key))) && (!(ArrayIndex.toLongIndex(ArrayIndex.getArrayIndex(key)) >= JSType.toUint32(oldLenDesc.getValue()) && !(PropertyDescriptor) super.getOwnPropertyDescriptor(\"length\").isWritable())) && (!(super.defineOwnProperty(key, toPropertyDescriptor(Global.instance(), propertyDesc), false))) && (reject)",
          "z3Program": "from z3 import *\nfrom z3_all_models import *\n\nkey0 = String('key0')\nreject0 = Bool('reject0')\noldLen0 = Int('oldLen0')\nindex0 = Int('index0')\nlongIndex0 = Int('longIndex0')\nsucceeded0 = Bool('succeeded0')\n\nconstraints = [\n  desc0 == toPropertyDescriptor(Global.instance(), propertyDesc0),\n  oldLenDesc0 == (PropertyDescriptor) super.getOwnPropertyDescriptor(\"length\"),\n  oldLen0 == JSType.toUint32(oldLenDesc0.getValue()),\n  index0 == ArrayIndex.getArrayIndex(key0),\n  longIndex0 == ArrayIndex.toLongIndex(index0),\n  succeeded0 == super.defineOwnProperty(key0, desc0, false),\n  oldLen0 >= -9223372036854775808, oldLen0 <= 9223372036854775807, # implicit\n  longIndex0 >= -9223372036854775808, longIndex0 <= 9223372036854775807, # implicit\n  And(And(And(And(Not(StringVal('length') == key0), ArrayIndex.isValidArrayIndex(index0)), Not(And(longIndex0 >= oldLen0, Not(oldLenDesc0.isWritable())))), Not(succeeded0)), reject0)\n]\n\nsolver = Solver()\nfor constraint in constraints:\n  solver.add(constraint)\n\nmodels = list(all_smt(solver))\nfor model in models: print(model)",
          "soundSymbolic": false,
          "soundBackwards": false,
          "maybe": true,
          "line": 358,
          "throwingLine": 399,
          "isStatic": false,
          "targetOnlyArguments": false
        },
        {
          "qualifiedSignature": "jdk.nashorn.internal.objects.NativeArray.defineOwnProperty(java.lang.String, java.lang.Object, boolean)",
          "exception": "throw typeError(\"property.not.writable\", Long.toString(longIndex), ScriptRuntime.safeToString(this));",
          "pathCojunction": "(!(\"length\".equals(key))) && (ArrayIndex.isValidArrayIndex(index)) && (longIndex >= oldLen && !oldLenDesc.isWritable()) && (reject)",
          "symbolicPathConjunction": "(!(\"length\".equals(key))) && (ArrayIndex.isValidArrayIndex(index)) && (longIndex >= oldLen && !oldLenDesc.isWritable()) && (reject)",
          "backwardsPathConjunction": "(!(\"length\".equals(key))) && (ArrayIndex.isValidArrayIndex(ArrayIndex.getArrayIndex(key))) && (ArrayIndex.toLongIndex(ArrayIndex.getArrayIndex(key)) >= JSType.toUint32(oldLenDesc.getValue()) && !(PropertyDescriptor) super.getOwnPropertyDescriptor(\"length\").isWritable()) && (reject)",
          "z3Program": "from z3 import *\nfrom z3_all_models import *\n\nkey0 = String('key0')\nreject0 = Bool('reject0')\noldLen0 = Int('oldLen0')\nindex0 = Int('index0')\nlongIndex0 = Int('longIndex0')\n\nconstraints = [\n  desc0 == toPropertyDescriptor(Global.instance(), propertyDesc0),\n  oldLenDesc0 == (PropertyDescriptor) super.getOwnPropertyDescriptor(\"length\"),\n  oldLen0 == JSType.toUint32(oldLenDesc0.getValue()),\n  index0 == ArrayIndex.getArrayIndex(key0),\n  longIndex0 == ArrayIndex.toLongIndex(index0),\n  oldLen0 >= -9223372036854775808, oldLen0 <= 9223372036854775807, # implicit\n  longIndex0 >= -9223372036854775808, longIndex0 <= 9223372036854775807, # implicit\n  And(And(And(Not(StringVal('length') == key0), ArrayIndex.isValidArrayIndex(index0)), And(longIndex0 >= oldLen0, Not(oldLenDesc0.isWritable()))), reject0)\n]\n\nsolver = Solver()\nfor constraint in constraints:\n  solver.add(constraint)\n\nmodels = list(all_smt(solver))\nfor model in models: print(model)",
          "soundSymbolic": false,
          "soundBackwards": false,
          "maybe": true,
          "line": 358,
          "throwingLine": 387,
          "isStatic": false,
          "targetOnlyArguments": false
        },
        {
          "qualifiedSignature": "jdk.nashorn.internal.objects.NativeArray.popInt(java.lang.Object)",
          "exception": "throw new ClassCastException(String.valueOf(getClass()));",
          "pathCojunction": "(true)",
          "symbolicPathConjunction": "(getContinuousNonEmptyArrayDataCCE(self, IntElements.class).fastPopInt())",
          "backwardsPathConjunction": "(true)",
          "simplifiedPathConjunction": "true",
          "z3Inputs": "[]\n",
          "z3Program": "from z3 import *\nfrom z3_all_models import *\n\n\nconstraints = [\n  True\n]\n\nsolver = Solver()\nfor constraint in constraints:\n  solver.add(constraint)\n\nmodels = list(all_smt(solver))\nfor model in models: print(model)",
          "symPyProgram": "from sympy import Symbol\nfrom sympy import simplify\nfrom sympy.core.relational import Eq, Ne, StrictGreaterThan, StrictLessThan, LessThan, GreaterThan\nfrom sympy.printing import ccode\n\npath_conjunction = True\nprint(ccode(simplify(path_conjunction)))",
          "soundSymbolic": true,
          "soundBackwards": true,
          "maybe": false,
          "line": 914,
          "throwingLine": 916,
          "isStatic": true,
          "targetOnlyArguments": true
        },
        {
          "qualifiedSignature": "jdk.nashorn.internal.objects.NativeArray.popDouble(java.lang.Object)",
          "exception": "throw new ClassCastException(String.valueOf(getClass()));",
          "pathCojunction": "(true)",
          "symbolicPathConjunction": "(getContinuousNonEmptyArrayDataCCE(self, NumericElements.class).fastPopDouble())",
          "backwardsPathConjunction": "(true)",
          "simplifiedPathConjunction": "true",
          "z3Inputs": "[]\n",
          "z3Program": "from z3 import *\nfrom z3_all_models import *\n\n\nconstraints = [\n  True\n]\n\nsolver = Solver()\nfor constraint in constraints:\n  solver.add(constraint)\n\nmodels = list(all_smt(solver))\nfor model in models: print(model)",
          "symPyProgram": "from sympy import Symbol\nfrom sympy import simplify\nfrom sympy.core.relational import Eq, Ne, StrictGreaterThan, StrictLessThan, LessThan, GreaterThan\nfrom sympy.printing import ccode\n\npath_conjunction = True\nprint(ccode(simplify(path_conjunction)))",
          "soundSymbolic": true,
          "soundBackwards": true,
          "maybe": false,
          "line": 929,
          "throwingLine": 931,
          "isStatic": true,
          "targetOnlyArguments": true
        },
        {
          "qualifiedSignature": "jdk.nashorn.internal.objects.NativeArray.popObject(java.lang.Object)",
          "exception": "throw new ClassCastException(String.valueOf(getClass()));",
          "pathCojunction": "(true)",
          "symbolicPathConjunction": "(getContinuousArrayDataCCE(self, null).fastPopObject())",
          "backwardsPathConjunction": "(true)",
          "simplifiedPathConjunction": "true",
          "z3Inputs": "[]\n",
          "z3Program": "from z3 import *\nfrom z3_all_models import *\n\n\nconstraints = [\n  True\n]\n\nsolver = Solver()\nfor constraint in constraints:\n  solver.add(constraint)\n\nmodels = list(all_smt(solver))\nfor model in models: print(model)",
          "symPyProgram": "from sympy import Symbol\nfrom sympy import simplify\nfrom sympy.core.relational import Eq, Ne, StrictGreaterThan, StrictLessThan, LessThan, GreaterThan\nfrom sympy.printing import ccode\n\npath_conjunction = True\nprint(ccode(simplify(path_conjunction)))",
          "soundSymbolic": true,
          "soundBackwards": true,
          "maybe": false,
          "line": 944,
          "throwingLine": 946,
          "isStatic": true,
          "targetOnlyArguments": true
        },
        {
          "qualifiedSignature": "jdk.nashorn.internal.objects.NativeArray.push(java.lang.Object, int)",
          "exception": "throw new ClassCastException(String.valueOf(getClass()));",
          "pathCojunction": "(true)",
          "symbolicPathConjunction": "(getContinuousArrayDataCCE(self, Integer.class).fastPush(arg))",
          "backwardsPathConjunction": "(true)",
          "simplifiedPathConjunction": "true",
          "z3Inputs": "[]\n",
          "z3Program": "from z3 import *\nfrom z3_all_models import *\n\narg0 = Int('arg0')\n\nconstraints = [\n  True\n]\n\nsolver = Solver()\nfor constraint in constraints:\n  solver.add(constraint)\n\nmodels = list(all_smt(solver))\nfor model in models: print(model)",
          "symPyProgram": "from sympy import Symbol\nfrom sympy import simplify\nfrom sympy.core.relational import Eq, Ne, StrictGreaterThan, StrictLessThan, LessThan, GreaterThan\nfrom sympy.printing import ccode\n\npath_conjunction = True\nprint(ccode(simplify(path_conjunction)))",
          "soundSymbolic": true,
          "soundBackwards": true,
          "maybe": false,
          "line": 993,
          "throwingLine": 994,
          "isStatic": true,
          "targetOnlyArguments": true
        },
        {
          "qualifiedSignature": "jdk.nashorn.internal.objects.NativeArray.push(java.lang.Object, long)",
          "exception": "throw new ClassCastException(String.valueOf(getClass()));",
          "pathCojunction": "(true)",
          "symbolicPathConjunction": "(getContinuousArrayDataCCE(self, Long.class).fastPush(arg))",
          "backwardsPathConjunction": "(true)",
          "simplifiedPathConjunction": "true",
          "z3Inputs": "[arg0 = -9223372036854775808]\n[arg0 = 0]\n[arg0 = -1]\n[arg0 = -2]\n[arg0 = -3]\n[arg0 = -4]\n[arg0 = -5]\n[arg0 = -6]\n[arg0 = -7]\n[arg0 = -8]\n",
          "z3Program": "from z3 import *\nfrom z3_all_models import *\n\narg0 = Int('arg0')\n\nconstraints = [\n  arg0 >= -9223372036854775808, arg0 <= 9223372036854775807, # implicit\n  True\n]\n\nsolver = Solver()\nfor constraint in constraints:\n  solver.add(constraint)\n\nmodels = list(all_smt(solver))\nfor model in models: print(model)",
          "symPyProgram": "from sympy import Symbol\nfrom sympy import simplify\nfrom sympy.core.relational import Eq, Ne, StrictGreaterThan, StrictLessThan, LessThan, GreaterThan\nfrom sympy.printing import ccode\n\npath_conjunction = True\nprint(ccode(simplify(path_conjunction)))",
          "soundSymbolic": true,
          "soundBackwards": true,
          "maybe": false,
          "line": 1007,
          "throwingLine": 1008,
          "isStatic": true,
          "targetOnlyArguments": true
        },
        {
          "qualifiedSignature": "jdk.nashorn.internal.objects.NativeArray.push(java.lang.Object, double)",
          "exception": "throw new ClassCastException(String.valueOf(getClass()));",
          "pathCojunction": "(true)",
          "symbolicPathConjunction": "(getContinuousArrayDataCCE(self, Double.class).fastPush(arg))",
          "backwardsPathConjunction": "(true)",
          "simplifiedPathConjunction": "true",
          "z3Inputs": "[]\n",
          "z3Program": "from z3 import *\nfrom z3_all_models import *\n\narg0 = Real('arg0')\n\nconstraints = [\n  True\n]\n\nsolver = Solver()\nfor constraint in constraints:\n  solver.add(constraint)\n\nmodels = list(all_smt(solver))\nfor model in models: print(model)",
          "symPyProgram": "from sympy import Symbol\nfrom sympy import simplify\nfrom sympy.core.relational import Eq, Ne, StrictGreaterThan, StrictLessThan, LessThan, GreaterThan\nfrom sympy.printing import ccode\n\npath_conjunction = True\nprint(ccode(simplify(path_conjunction)))",
          "soundSymbolic": true,
          "soundBackwards": true,
          "maybe": false,
          "line": 1021,
          "throwingLine": 1022,
          "isStatic": true,
          "targetOnlyArguments": true
        },
        {
          "qualifiedSignature": "jdk.nashorn.internal.objects.NativeArray.pushObject(java.lang.Object, java.lang.Object)",
          "exception": "throw new ClassCastException(String.valueOf(getClass()));",
          "pathCojunction": "(true)",
          "symbolicPathConjunction": "(getContinuousArrayDataCCE(self, Object.class).fastPush(arg))",
          "backwardsPathConjunction": "(true)",
          "simplifiedPathConjunction": "true",
          "z3Inputs": "[]\n",
          "z3Program": "from z3 import *\nfrom z3_all_models import *\n\n\nconstraints = [\n  True\n]\n\nsolver = Solver()\nfor constraint in constraints:\n  solver.add(constraint)\n\nmodels = list(all_smt(solver))\nfor model in models: print(model)",
          "symPyProgram": "from sympy import Symbol\nfrom sympy import simplify\nfrom sympy.core.relational import Eq, Ne, StrictGreaterThan, StrictLessThan, LessThan, GreaterThan\nfrom sympy.printing import ccode\n\npath_conjunction = True\nprint(ccode(simplify(path_conjunction)))",
          "soundSymbolic": true,
          "soundBackwards": true,
          "maybe": false,
          "line": 1035,
          "throwingLine": 1036,
          "isStatic": true,
          "targetOnlyArguments": true
        }
      ]
    },
    {
      "path": "/home/yanghengqin/jdk8u_nashorn/src/jdk/internal/dynalink/support/CallSiteDescriptorFactory.java",
      "methods": [
        {
          "qualifiedSignature": "jdk.internal.dynalink.support.CallSiteDescriptorFactory.create(java.lang.invoke.MethodHandles.Lookup, java.lang.String, java.lang.invoke.MethodType)",
          "exception": "throw new NullPointerException()",
          "pathCojunction": "(name == null)",
          "symbolicPathConjunction": "(Objects.requireNonNull(name))",
          "backwardsPathConjunction": "(name == null)",
          "simplifiedPathConjunction": "name == null",
          "z3Inputs": "[name0_isNull = True]\n",
          "z3Program": "from z3 import *\nfrom z3_all_models import *\n\nname0 = String('name0')\nname0_isNull = Bool('name0_isNull')\n\nconstraints = [\n  name0_isNull\n]\n\nsolver = Solver()\nfor constraint in constraints:\n  solver.add(constraint)\n\nmodels = list(all_smt(solver))\nfor model in models: print(model)",
          "symPyProgram": "from sympy import Symbol\nfrom sympy import simplify\nfrom sympy.core.relational import Eq, Ne, StrictGreaterThan, StrictLessThan, LessThan, GreaterThan\nfrom sympy.printing import ccode\n\nname = Symbol('name')\nnull = Symbol('null')\npath_conjunction = (Eq(name, null))\nprint(ccode(simplify(path_conjunction)))",
          "soundSymbolic": true,
          "soundBackwards": true,
          "maybe": false,
          "line": 126,
          "throwingLine": 127,
          "isStatic": true,
          "targetOnlyArguments": true
        },
        {
          "qualifiedSignature": "jdk.internal.dynalink.support.CallSiteDescriptorFactory.create(java.lang.invoke.MethodHandles.Lookup, java.lang.String, java.lang.invoke.MethodType)",
          "exception": "throw new NullPointerException()",
          "pathCojunction": "(!(name == null)) && (methodType == null)",
          "symbolicPathConjunction": "(Objects.requireNonNull(name)) && (Objects.requireNonNull(methodType))",
          "backwardsPathConjunction": "(!(name == null)) && (methodType == null)",
          "simplifiedPathConjunction": "methodType == null && name != null",
          "z3Inputs": "[name0_isNull = False, methodType0_isNull = True]\n",
          "z3Program": "from z3 import *\nfrom z3_all_models import *\n\nname0 = String('name0')\nname0_isNull = Bool('name0_isNull')\nmethodType0_isNull = Bool('methodType0_isNull')\n\nconstraints = [\n  And(Not(name0_isNull), methodType0_isNull)\n]\n\nsolver = Solver()\nfor constraint in constraints:\n  solver.add(constraint)\n\nmodels = list(all_smt(solver))\nfor model in models: print(model)",
          "symPyProgram": "from sympy import Symbol\nfrom sympy import simplify\nfrom sympy.core.relational import Eq, Ne, StrictGreaterThan, StrictLessThan, LessThan, GreaterThan\nfrom sympy.printing import ccode\n\nname = Symbol('name')\nmethodType = Symbol('methodType')\nnull = Symbol('null')\npath_conjunction = ((~((Eq(name, null)))) & (Eq(methodType, null)))\nprint(ccode(simplify(path_conjunction)))",
          "soundSymbolic": true,
          "soundBackwards": true,
          "maybe": false,
          "line": 126,
          "throwingLine": 128,
          "isStatic": true,
          "targetOnlyArguments": true
        },
        {
          "qualifiedSignature": "jdk.internal.dynalink.support.CallSiteDescriptorFactory.create(java.lang.invoke.MethodHandles.Lookup, java.lang.String, java.lang.invoke.MethodType)",
          "exception": "throw new NullPointerException()",
          "pathCojunction": "(!(name == null)) && (!(methodType == null)) && (lookup == null)",
          "symbolicPathConjunction": "(Objects.requireNonNull(name)) && (Objects.requireNonNull(methodType)) && (Objects.requireNonNull(lookup))",
          "backwardsPathConjunction": "(!(name == null)) && (!(methodType == null)) && (lookup == null)",
          "simplifiedPathConjunction": "lookup == null && methodType != null && name != null",
          "z3Inputs": "[lookup0_isNull = True,\n name0_isNull = False,\n methodType0_isNull = False]\n",
          "z3Program": "from z3 import *\nfrom z3_all_models import *\n\nname0 = String('name0')\nname0_isNull = Bool('name0_isNull')\nmethodType0_isNull = Bool('methodType0_isNull')\nlookup0_isNull = Bool('lookup0_isNull')\n\nconstraints = [\n  And(And(Not(name0_isNull), Not(methodType0_isNull)), lookup0_isNull)\n]\n\nsolver = Solver()\nfor constraint in constraints:\n  solver.add(constraint)\n\nmodels = list(all_smt(solver))\nfor model in models: print(model)",
          "symPyProgram": "from sympy import Symbol\nfrom sympy import simplify\nfrom sympy.core.relational import Eq, Ne, StrictGreaterThan, StrictLessThan, LessThan, GreaterThan\nfrom sympy.printing import ccode\n\nlookup = Symbol('lookup')\nname = Symbol('name')\nmethodType = Symbol('methodType')\nnull = Symbol('null')\npath_conjunction = (((~((Eq(name, null)))) & (~((Eq(methodType, null))))) & (Eq(lookup, null)))\nprint(ccode(simplify(path_conjunction)))",
          "soundSymbolic": true,
          "soundBackwards": true,
          "maybe": false,
          "line": 126,
          "throwingLine": 129,
          "isStatic": true,
          "targetOnlyArguments": true
        }
      ]
    },
    {
      "path": "/home/yanghengqin/jdk8u_nashorn/test/src/jdk/nashorn/api/test/NashornSQLDriver.java",
      "methods": [
        {
          "qualifiedSignature": "jdk.nashorn.api.test.NashornSQLDriver.connect(java.lang.String, java.util.Properties)",
          "exception": "throw new UnsupportedOperationException(\"I am a dummy!!\");",
          "pathCojunction": "true",
          "backwardsPathConjunction": "true",
          "simplifiedPathConjunction": "true",
          "z3Program": "from z3 import *\nfrom z3_all_models import *\n\nurl0 = String('url0')\n\nconstraints = [\n  True\n]\n\nsolver = Solver()\nfor constraint in constraints:\n  solver.add(constraint)\n\nmodels = list(all_smt(solver))\nfor model in models: print(model)",
          "soundSymbolic": false,
          "soundBackwards": true,
          "maybe": false,
          "line": 55,
          "throwingLine": 56,
          "isStatic": false,
          "targetOnlyArguments": true
        },
        {
          "qualifiedSignature": "jdk.nashorn.api.test.NashornSQLDriver.getParentLogger()",
          "exception": "throw new SQLFeatureNotSupportedException();",
          "pathCojunction": "true",
          "backwardsPathConjunction": "true",
          "simplifiedPathConjunction": "true",
          "soundSymbolic": false,
          "soundBackwards": true,
          "maybe": false,
          "line": 81,
          "throwingLine": 82,
          "isStatic": false,
          "targetOnlyArguments": true
        }
      ]
    },
    {
      "path": "/home/yanghengqin/jdk8u_nashorn/src/jdk/nashorn/internal/objects/DataPropertyDescriptor.java",
      "methods": [
        {
          "qualifiedSignature": "jdk.nashorn.internal.objects.DataPropertyDescriptor.getGetter()",
          "exception": "throw new UnsupportedOperationException(\"getter\");",
          "pathCojunction": "true",
          "backwardsPathConjunction": "true",
          "simplifiedPathConjunction": "true",
          "soundSymbolic": false,
          "soundBackwards": true,
          "maybe": false,
          "line": 97,
          "throwingLine": 98,
          "isStatic": false,
          "targetOnlyArguments": true
        },
        {
          "qualifiedSignature": "jdk.nashorn.internal.objects.DataPropertyDescriptor.getSetter()",
          "exception": "throw new UnsupportedOperationException(\"setter\");",
          "pathCojunction": "true",
          "backwardsPathConjunction": "true",
          "simplifiedPathConjunction": "true",
          "soundSymbolic": false,
          "soundBackwards": true,
          "maybe": false,
          "line": 102,
          "throwingLine": 103,
          "isStatic": false,
          "targetOnlyArguments": true
        },
        {
          "qualifiedSignature": "jdk.nashorn.internal.objects.DataPropertyDescriptor.setGetter(java.lang.Object)",
          "exception": "throw new UnsupportedOperationException(\"set getter\");",
          "pathCojunction": "true",
          "backwardsPathConjunction": "true",
          "simplifiedPathConjunction": "true",
          "z3Program": "from z3 import *\nfrom z3_all_models import *\n\n\nconstraints = [\n  True\n]\n\nsolver = Solver()\nfor constraint in constraints:\n  solver.add(constraint)\n\nmodels = list(all_smt(solver))\nfor model in models: print(model)",
          "soundSymbolic": false,
          "soundBackwards": true,
          "maybe": false,
          "line": 127,
          "throwingLine": 128,
          "isStatic": false,
          "targetOnlyArguments": true
        },
        {
          "qualifiedSignature": "jdk.nashorn.internal.objects.DataPropertyDescriptor.setSetter(java.lang.Object)",
          "exception": "throw new UnsupportedOperationException(\"set setter\");",
          "pathCojunction": "true",
          "backwardsPathConjunction": "true",
          "simplifiedPathConjunction": "true",
          "z3Program": "from z3 import *\nfrom z3_all_models import *\n\n\nconstraints = [\n  True\n]\n\nsolver = Solver()\nfor constraint in constraints:\n  solver.add(constraint)\n\nmodels = list(all_smt(solver))\nfor model in models: print(model)",
          "soundSymbolic": false,
          "soundBackwards": true,
          "maybe": false,
          "line": 132,
          "throwingLine": 133,
          "isStatic": false,
          "targetOnlyArguments": true
        }
      ]
    },
    {
      "path": "/home/yanghengqin/jdk8u_nashorn/src/jdk/nashorn/internal/ir/debug/NashornTextifier.java",
      "methods": [
        {
          "qualifiedSignature": "jdk.nashorn.internal.ir.debug.NashornTextifier.visit(java.lang.String, java.lang.Object)",
          "exception": "throw new AssertionError();",
          "pathCojunction": "true",
          "backwardsPathConjunction": "true",
          "simplifiedPathConjunction": "true",
          "z3Program": "from z3 import *\nfrom z3_all_models import *\n\narg00 = String('arg00')\n\nconstraints = [\n  True\n]\n\nsolver = Solver()\nfor constraint in constraints:\n  solver.add(constraint)\n\nmodels = list(all_smt(solver))\nfor model in models: print(model)",
          "soundSymbolic": false,
          "soundBackwards": true,
          "maybe": false,
          "line": 1229,
          "throwingLine": 1230,
          "isStatic": false,
          "targetOnlyArguments": true
        },
        {
          "qualifiedSignature": "jdk.nashorn.internal.ir.debug.NashornTextifier.visitEnum(java.lang.String, java.lang.String, java.lang.String)",
          "exception": "throw new AssertionError();",
          "pathCojunction": "true",
          "backwardsPathConjunction": "true",
          "simplifiedPathConjunction": "true",
          "z3Program": "from z3 import *\nfrom z3_all_models import *\n\narg00 = String('arg00')\narg10 = String('arg10')\narg20 = String('arg20')\n\nconstraints = [\n  True\n]\n\nsolver = Solver()\nfor constraint in constraints:\n  solver.add(constraint)\n\nmodels = list(all_smt(solver))\nfor model in models: print(model)",
          "soundSymbolic": false,
          "soundBackwards": true,
          "maybe": false,
          "line": 1249,
          "throwingLine": 1250,
          "isStatic": false,
          "targetOnlyArguments": true
        },
        {
          "qualifiedSignature": "jdk.nashorn.internal.ir.debug.NashornTextifier.visitInnerClass(java.lang.String, java.lang.String, java.lang.String, int)",
          "exception": "throw new AssertionError();",
          "pathCojunction": "true",
          "backwardsPathConjunction": "true",
          "simplifiedPathConjunction": "true",
          "z3Program": "from z3 import *\nfrom z3_all_models import *\n\narg00 = String('arg00')\narg10 = String('arg10')\narg20 = String('arg20')\narg30 = Int('arg30')\n\nconstraints = [\n  True\n]\n\nsolver = Solver()\nfor constraint in constraints:\n  solver.add(constraint)\n\nmodels = list(all_smt(solver))\nfor model in models: print(model)",
          "soundSymbolic": false,
          "soundBackwards": true,
          "maybe": false,
          "line": 1254,
          "throwingLine": 1255,
          "isStatic": false,
          "targetOnlyArguments": true
        }
      ]
    },
    {
      "path": "/home/yanghengqin/jdk8u_nashorn/src/jdk/nashorn/internal/objects/NativeArrayBuffer.java",
      "methods": [
        {
          "qualifiedSignature": "jdk.nashorn.internal.objects.NativeArrayBuffer.constructor(boolean, java.lang.Object, java.lang.Object...)",
          "exception": "throw typeError(\"constructor.requires.new\", \"ArrayBuffer\");",
          "pathCojunction": "(!(newObj))",
          "symbolicPathConjunction": "(!(newObj))",
          "backwardsPathConjunction": "(!(newObj))",
          "simplifiedPathConjunction": "!newObj",
          "z3Inputs": "[newObj0 = False]\n",
          "z3Program": "from z3 import *\nfrom z3_all_models import *\n\nnewObj0 = Bool('newObj0')\n\nconstraints = [\n  Not(newObj0)\n]\n\nsolver = Solver()\nfor constraint in constraints:\n  solver.add(constraint)\n\nmodels = list(all_smt(solver))\nfor model in models: print(model)",
          "symPyProgram": "from sympy import Symbol\nfrom sympy import simplify\nfrom sympy.core.relational import Eq, Ne, StrictGreaterThan, StrictLessThan, LessThan, GreaterThan\nfrom sympy.printing import ccode\n\nnewObj = Symbol('newObj')\npath_conjunction = (~(newObj))\nprint(ccode(simplify(path_conjunction)))",
          "soundSymbolic": true,
          "soundBackwards": true,
          "maybe": false,
          "line": 98,
          "throwingLine": 100,
          "isStatic": true,
          "targetOnlyArguments": true
        }
      ]
    },
    {
      "path": "/home/yanghengqin/jdk8u_nashorn/src/jdk/nashorn/internal/objects/AccessorPropertyDescriptor.java",
      "methods": [
        {
          "qualifiedSignature": "jdk.nashorn.internal.objects.AccessorPropertyDescriptor.getValue()",
          "exception": "throw new UnsupportedOperationException(\"value\");",
          "pathCojunction": "true",
          "backwardsPathConjunction": "true",
          "simplifiedPathConjunction": "true",
          "soundSymbolic": false,
          "soundBackwards": true,
          "maybe": false,
          "line": 95,
          "throwingLine": 96,
          "isStatic": false,
          "targetOnlyArguments": true
        },
        {
          "qualifiedSignature": "jdk.nashorn.internal.objects.AccessorPropertyDescriptor.setWritable(boolean)",
          "exception": "throw new UnsupportedOperationException(\"set writable\");",
          "pathCojunction": "true",
          "backwardsPathConjunction": "true",
          "simplifiedPathConjunction": "true",
          "z3Program": "from z3 import *\nfrom z3_all_models import *\n\nflag0 = Bool('flag0')\n\nconstraints = [\n  True\n]\n\nsolver = Solver()\nfor constraint in constraints:\n  solver.add(constraint)\n\nmodels = list(all_smt(solver))\nfor model in models: print(model)",
          "soundSymbolic": false,
          "soundBackwards": true,
          "maybe": false,
          "line": 120,
          "throwingLine": 121,
          "isStatic": false,
          "targetOnlyArguments": true
        },
        {
          "qualifiedSignature": "jdk.nashorn.internal.objects.AccessorPropertyDescriptor.setValue(java.lang.Object)",
          "exception": "throw new UnsupportedOperationException(\"set value\");",
          "pathCojunction": "true",
          "backwardsPathConjunction": "true",
          "simplifiedPathConjunction": "true",
          "z3Program": "from z3 import *\nfrom z3_all_models import *\n\n\nconstraints = [\n  True\n]\n\nsolver = Solver()\nfor constraint in constraints:\n  solver.add(constraint)\n\nmodels = list(all_smt(solver))\nfor model in models: print(model)",
          "soundSymbolic": false,
          "soundBackwards": true,
          "maybe": false,
          "line": 125,
          "throwingLine": 126,
          "isStatic": false,
          "targetOnlyArguments": true
        }
      ]
    },
    {
      "path": "/home/yanghengqin/jdk8u_nashorn/src/jdk/nashorn/internal/runtime/linker/ClassAndLoader.java",
      "methods": [
        {
          "qualifiedSignature": "jdk.nashorn.internal.runtime.linker.ClassAndLoader.Anonymous-dc347054-5f42-4d65-8b13-9f55a313ddb9.run()",
          "exception": "throw typeError(\"extend.ambiguous.defining.class\", b.toString());",
          "pathCojunction": "(!(maximumVisibilityLoaders.size() == 1)) && (!(maximumVisibilityLoaders.iterator().hasNext()))",
          "symbolicPathConjunction": "((!(maximumVisibilityLoaders.size() == 1)) && (!(it.hasNext())))",
          "backwardsPathConjunction": "(!(maximumVisibilityLoaders.size() == 1)) && (!(maximumVisibilityLoaders.iterator().hasNext()))",
          "simplifiedPathConjunction": "!maximumVisibilityLoaders.iterator().hasNext() && maximumVisibilityLoaders.size() != 1",
          "z3Program": "from z3 import *\nfrom z3_all_models import *\n\n\nconstraints = [\n  maximumVisibilityLoaders0 == maximumVisibilityLoaders,\n  And(Not(maximumVisibilityLoaders0.size() == 1), Not(maximumVisibilityLoaders0.iterator().hasNext()))\n]\n\nsolver = Solver()\nfor constraint in constraints:\n  solver.add(constraint)\n\nmodels = list(all_smt(solver))\nfor model in models: print(model)",
          "symPyProgram": "from sympy import Symbol\nfrom sympy import simplify\nfrom sympy.core.relational import Eq, Ne, StrictGreaterThan, StrictLessThan, LessThan, GreaterThan\nfrom sympy.printing import ccode\n\nmaximumVisibilityLoaders_size = Symbol('maximumVisibilityLoaders_size')\nmaximumVisibilityLoaders_iterator_hasNext = Symbol('maximumVisibilityLoaders_iterator_hasNext')\nmaximumVisibilityLoaders_iterator = Symbol('maximumVisibilityLoaders_iterator')\npath_conjunction = ((~((Eq(maximumVisibilityLoaders_size, 1)))) & (~(maximumVisibilityLoaders_iterator_hasNext)))\nprint(ccode(simplify(path_conjunction)))",
          "soundSymbolic": true,
          "soundBackwards": false,
          "maybe": true,
          "line": 129,
          "throwingLine": 130,
          "isStatic": false,
          "targetOnlyArguments": false
        }
      ]
    },
    {
      "path": "/home/yanghengqin/jdk8u_nashorn/src/jdk/nashorn/internal/objects/ArrayBufferView.java",
      "methods": [
        {
          "qualifiedSignature": "jdk.nashorn.internal.objects.ArrayBufferView.Factory.construct(int)",
          "exception": "throw rangeError(\"inappropriate.array.buffer.length\", JSType.toString(elementLength));",
          "pathCojunction": "(elementLength > maxElementLength)",
          "symbolicPathConjunction": "(elementLength > maxElementLength)",
          "backwardsPathConjunction": "(elementLength > maxElementLength)",
          "simplifiedPathConjunction": "elementLength > maxElementLength",
          "z3Inputs": "[elementLength0 = 1, maxElementLength0 = 0]\n[maxElementLength0 = -1, elementLength0 = 0]\n[maxElementLength0 = -2, elementLength0 = -1]\n[maxElementLength0 = -3, elementLength0 = -2]\n[maxElementLength0 = -4, elementLength0 = -3]\n[maxElementLength0 = -5, elementLength0 = -4]\n[maxElementLength0 = -6, elementLength0 = -5]\n[maxElementLength0 = -7, elementLength0 = -6]\n[maxElementLength0 = -8, elementLength0 = -7]\n[maxElementLength0 = -9, elementLength0 = -8]\n",
          "z3Program": "from z3 import *\nfrom z3_all_models import *\n\nelementLength0 = Int('elementLength0')\nmaxElementLength0 = Int('maxElementLength0')\n\nconstraints = [\n  elementLength0 > maxElementLength0\n]\n\nsolver = Solver()\nfor constraint in constraints:\n  solver.add(constraint)\n\nmodels = list(all_smt(solver))\nfor model in models: print(model)",
          "symPyProgram": "from sympy import Symbol\nfrom sympy import simplify\nfrom sympy.core.relational import Eq, Ne, StrictGreaterThan, StrictLessThan, LessThan, GreaterThan\nfrom sympy.printing import ccode\n\nelementLength = Symbol('elementLength', integer=True)\nmaxElementLength = Symbol('maxElementLength', integer=True)\npath_conjunction = (StrictGreaterThan(elementLength, maxElementLength))\nprint(ccode(simplify(path_conjunction)))",
          "soundSymbolic": true,
          "soundBackwards": true,
          "maybe": false,
          "line": 174,
          "throwingLine": 176,
          "isStatic": false,
          "targetOnlyArguments": false
        }
      ]
    },
    {
      "path": "/home/yanghengqin/jdk8u_nashorn/src/jdk/nashorn/internal/objects/NativeNumber.java",
      "methods": [
        {
          "qualifiedSignature": "jdk.nashorn.internal.objects.NativeNumber.toFixed(java.lang.Object, int)",
          "exception": "throw rangeError(\"invalid.fraction.digits\", \"toFixed\");",
          "pathCojunction": "(fractionDigits < 0 || fractionDigits > 20)",
          "symbolicPathConjunction": "(fractionDigits < 0 || fractionDigits > 20)",
          "backwardsPathConjunction": "(fractionDigits < 0 || fractionDigits > 20)",
          "simplifiedPathConjunction": "fractionDigits > 20 || fractionDigits < 0",
          "z3Inputs": "[fractionDigits0 = 21]\n[fractionDigits0 = -1]\n[fractionDigits0 = -2]\n[fractionDigits0 = -3]\n[fractionDigits0 = -4]\n[fractionDigits0 = -5]\n[fractionDigits0 = -6]\n[fractionDigits0 = -7]\n[fractionDigits0 = -8]\n[fractionDigits0 = -9]\n",
          "z3Program": "from z3 import *\nfrom z3_all_models import *\n\nfractionDigits0 = Int('fractionDigits0')\n\nconstraints = [\n  Or(fractionDigits0 < 0, fractionDigits0 > 20)\n]\n\nsolver = Solver()\nfor constraint in constraints:\n  solver.add(constraint)\n\nmodels = list(all_smt(solver))\nfor model in models: print(model)",
          "symPyProgram": "from sympy import Symbol\nfrom sympy import simplify\nfrom sympy.core.relational import Eq, Ne, StrictGreaterThan, StrictLessThan, LessThan, GreaterThan\nfrom sympy.printing import ccode\n\nfractionDigits = Symbol('fractionDigits', integer=True)\npath_conjunction = ((StrictLessThan(fractionDigits, 0)) | (StrictGreaterThan(fractionDigits, 20)))\nprint(ccode(simplify(path_conjunction)))",
          "soundSymbolic": true,
          "soundBackwards": true,
          "maybe": false,
          "line": 174,
          "throwingLine": 176,
          "isStatic": true,
          "targetOnlyArguments": true
        },
        {
          "qualifiedSignature": "jdk.nashorn.internal.objects.NativeNumber.toExponential(java.lang.Object, java.lang.Object)",
          "exception": "throw rangeError(\"invalid.fraction.digits\", \"toExponential\");",
          "pathCojunction": "(!(trimZeros)) && (!(Double.isNaN(x))) && (!(Double.isInfinite(x))) && (fractionDigits != UNDEFINED && (f < 0 || f > 20))",
          "symbolicPathConjunction": "(!(trimZeros)) && (!(Double.isNaN(x))) && (!(Double.isInfinite(x))) && (fractionDigits != UNDEFINED && (f < 0 || f > 20))",
          "backwardsPathConjunction": "(!(fractionDigits == UNDEFINED)) && (!(Double.isNaN(getNumberValue(self)))) && (!(Double.isInfinite(getNumberValue(self)))) && (fractionDigits != UNDEFINED && (JSType.toInteger(fractionDigits) < 0 || JSType.toInteger(fractionDigits) > 20))",
          "z3Program": "from z3 import *\nfrom z3_all_models import *\n\nx0 = Real('x0')\ntrimZeros0 = Bool('trimZeros0')\nf0 = Int('f0')\n\nconstraints = [\n  x0 == getNumberValue(self0),\n  trimZeros0 == fractionDigits0 == UNDEFINED,\n  f0 == JSType.toInteger(fractionDigits0),\n  And(And(And(Not(trimZeros0), Not(Double.isNaN(x0))), Not(Double.isInfinite(x0))), And(fractionDigits0 != UNDEFINED, Or(f0 < 0, f0 > 20)))\n]\n\nsolver = Solver()\nfor constraint in constraints:\n  solver.add(constraint)\n\nmodels = list(all_smt(solver))\nfor model in models: print(model)",
          "symPyProgram": "from sympy import Symbol\nfrom sympy import simplify\nfrom sympy.core.relational import Eq, Ne, StrictGreaterThan, StrictLessThan, LessThan, GreaterThan\nfrom sympy.printing import ccode\n\nself = Symbol('self')\nfractionDigits = Symbol('fractionDigits')\nDouble_isNaN = Symbol('Double_isNaN')\n_getNumberValue = Symbol('_getNumberValue')\nDouble_isInfinite = Symbol('Double_isInfinite')\nJSType_toInteger = Symbol('JSType_toInteger')\npath_conjunction = ((((~((Eq(fractionDigits, UNDEFINED)))) & (~(Double_isNaN))) & (~(Double_isInfinite))) & ((Ne(fractionDigits, UNDEFINED)) & ((StrictLessThan(JSType_toInteger, 0)) | (StrictGreaterThan(JSType_toInteger, 20)))))\nprint(ccode(simplify(path_conjunction)))",
          "soundSymbolic": false,
          "soundBackwards": false,
          "maybe": true,
          "line": 206,
          "throwingLine": 218,
          "isStatic": true,
          "targetOnlyArguments": false
        },
        {
          "qualifiedSignature": "jdk.nashorn.internal.objects.NativeNumber.toExponential(java.lang.Object, java.lang.Object)",
          "exception": "throw rangeError(\"invalid.fraction.digits\", \"toExponential\");",
          "pathCojunction": "(trimZeros) && (!(Double.isNaN(x))) && (!(Double.isInfinite(x))) && (fractionDigits != UNDEFINED && (f < 0 || f > 20))",
          "symbolicPathConjunction": "(trimZeros) && (!(Double.isNaN(x))) && (!(Double.isInfinite(x))) && (fractionDigits != UNDEFINED && (f < 0 || f > 20))",
          "backwardsPathConjunction": "(fractionDigits == UNDEFINED) && (!(Double.isNaN(getNumberValue(self)))) && (!(Double.isInfinite(getNumberValue(self)))) && (fractionDigits != UNDEFINED && (16 < 0 || 16 > 20))",
          "z3Program": "from z3 import *\nfrom z3_all_models import *\n\nx0 = Real('x0')\ntrimZeros0 = Bool('trimZeros0')\nf0 = Int('f0')\n\nconstraints = [\n  x0 == getNumberValue(self0),\n  trimZeros0 == fractionDigits0 == UNDEFINED,\n  f0 == 16,\n  And(And(And(trimZeros0, Not(Double.isNaN(x0))), Not(Double.isInfinite(x0))), And(fractionDigits0 != UNDEFINED, Or(f0 < 0, f0 > 20)))\n]\n\nsolver = Solver()\nfor constraint in constraints:\n  solver.add(constraint)\n\nmodels = list(all_smt(solver))\nfor model in models: print(model)",
          "symPyProgram": "from sympy import Symbol\nfrom sympy import simplify\nfrom sympy.core.relational import Eq, Ne, StrictGreaterThan, StrictLessThan, LessThan, GreaterThan\nfrom sympy.printing import ccode\n\nself = Symbol('self')\nfractionDigits = Symbol('fractionDigits')\nDouble_isNaN = Symbol('Double_isNaN')\n_getNumberValue = Symbol('_getNumberValue')\nDouble_isInfinite = Symbol('Double_isInfinite')\npath_conjunction = ((((Eq(fractionDigits, UNDEFINED)) & (~(Double_isNaN))) & (~(Double_isInfinite))) & ((Ne(fractionDigits, UNDEFINED)) & ((StrictLessThan(16, 0)) | (StrictGreaterThan(16, 20)))))\nprint(ccode(simplify(path_conjunction)))",
          "soundSymbolic": false,
          "soundBackwards": false,
          "maybe": true,
          "line": 206,
          "throwingLine": 218,
          "isStatic": true,
          "targetOnlyArguments": false
        },
        {
          "qualifiedSignature": "jdk.nashorn.internal.objects.NativeNumber.toString(java.lang.Object, java.lang.Object)",
          "exception": "throw rangeError(\"invalid.radix\");",
          "pathCojunction": "(radix != UNDEFINED) && (intRadix != 10) && (intRadix < 2 || intRadix > 36)",
          "symbolicPathConjunction": "(radix != UNDEFINED) && (intRadix != 10) && (intRadix < 2 || intRadix > 36)",
          "backwardsPathConjunction": "(radix != UNDEFINED) && (JSType.toInteger(radix) != 10) && (JSType.toInteger(radix) < 2 || JSType.toInteger(radix) > 36)",
          "z3Program": "from z3 import *\nfrom z3_all_models import *\n\nintRadix0 = Int('intRadix0')\n\nconstraints = [\n  intRadix0 == JSType.toInteger(radix0),\n  And(And(radix0 != UNDEFINED, intRadix0 != 10), Or(intRadix0 < 2, intRadix0 > 36))\n]\n\nsolver = Solver()\nfor constraint in constraints:\n  solver.add(constraint)\n\nmodels = list(all_smt(solver))\nfor model in models: print(model)",
          "symPyProgram": "from sympy import Symbol\nfrom sympy import simplify\nfrom sympy.core.relational import Eq, Ne, StrictGreaterThan, StrictLessThan, LessThan, GreaterThan\nfrom sympy.printing import ccode\n\nradix = Symbol('radix')\nJSType_toInteger = Symbol('JSType_toInteger')\npath_conjunction = (((Ne(radix, UNDEFINED)) & (Ne(JSType_toInteger, 10))) & ((StrictLessThan(JSType_toInteger, 2)) | (StrictGreaterThan(JSType_toInteger, 36))))\nprint(ccode(simplify(path_conjunction)))",
          "soundSymbolic": false,
          "soundBackwards": false,
          "maybe": true,
          "line": 282,
          "throwingLine": 287,
          "isStatic": true,
          "targetOnlyArguments": false
        }
      ]
    },
    {
      "path": "/home/yanghengqin/jdk8u_nashorn/src/jdk/nashorn/internal/codegen/LocalVariableTypesCalculator.java",
      "methods": [
        {
          "qualifiedSignature": "jdk.nashorn.internal.codegen.LocalVariableTypesCalculator.TypeHolderExpression.accept(jdk.nashorn.internal.ir.visitor.NodeVisitor<? extends jdk.nashorn.internal.ir.LexicalContext>)",
          "exception": "throw new AssertionError();",
          "pathCojunction": "true",
          "backwardsPathConjunction": "true",
          "simplifiedPathConjunction": "true",
          "z3Program": "from z3 import *\nfrom z3_all_models import *\n\n\nconstraints = [\n  True\n]\n\nsolver = Solver()\nfor constraint in constraints:\n  solver.add(constraint)\n\nmodels = list(all_smt(solver))\nfor model in models: print(model)",
          "soundSymbolic": false,
          "soundBackwards": true,
          "maybe": false,
          "line": 165,
          "throwingLine": 166,
          "isStatic": false,
          "targetOnlyArguments": true
        },
        {
          "qualifiedSignature": "jdk.nashorn.internal.codegen.LocalVariableTypesCalculator.TypeHolderExpression.toString(java.lang.StringBuilder, boolean)",
          "exception": "throw new AssertionError();",
          "pathCojunction": "true",
          "backwardsPathConjunction": "true",
          "simplifiedPathConjunction": "true",
          "z3Program": "from z3 import *\nfrom z3_all_models import *\n\nprintType0 = Bool('printType0')\n\nconstraints = [\n  True\n]\n\nsolver = Solver()\nfor constraint in constraints:\n  solver.add(constraint)\n\nmodels = list(all_smt(solver))\nfor model in models: print(model)",
          "soundSymbolic": false,
          "soundBackwards": true,
          "maybe": false,
          "line": 175,
          "throwingLine": 176,
          "isStatic": false,
          "targetOnlyArguments": true
        },
        {
          "qualifiedSignature": "jdk.nashorn.internal.codegen.LocalVariableTypesCalculator.enterPropertyNode(jdk.nashorn.internal.ir.PropertyNode)",
          "exception": "throw new AssertionError();",
          "pathCojunction": "true",
          "backwardsPathConjunction": "true",
          "simplifiedPathConjunction": "true",
          "z3Program": "from z3 import *\nfrom z3_all_models import *\n\n\nconstraints = [\n  True\n]\n\nsolver = Solver()\nfor constraint in constraints:\n  solver.add(constraint)\n\nmodels = list(all_smt(solver))\nfor model in models: print(model)",
          "soundSymbolic": false,
          "soundBackwards": true,
          "maybe": false,
          "line": 809,
          "throwingLine": 811,
          "isStatic": false,
          "targetOnlyArguments": true
        }
      ]
    },
    {
      "path": "/home/yanghengqin/jdk8u_nashorn/test/src/jdk/nashorn/internal/test/models/InternalRunnable.java",
      "methods": [
        {
          "qualifiedSignature": "jdk.nashorn.internal.test.models.InternalRunnable.restrictedRun()",
          "exception": "throw new AssertionError();",
          "pathCojunction": "true",
          "backwardsPathConjunction": "true",
          "simplifiedPathConjunction": "true",
          "soundSymbolic": false,
          "soundBackwards": true,
          "maybe": false,
          "line": 45,
          "throwingLine": 47,
          "isStatic": false,
          "targetOnlyArguments": true
        },
        {
          "qualifiedSignature": "jdk.nashorn.internal.test.models.InternalRunnable.canNotInvokeThis()",
          "exception": "throw new AssertionError();",
          "pathCojunction": "true",
          "backwardsPathConjunction": "true",
          "simplifiedPathConjunction": "true",
          "soundSymbolic": false,
          "soundBackwards": true,
          "maybe": false,
          "line": 62,
          "throwingLine": 64,
          "isStatic": false,
          "targetOnlyArguments": true
        },
        {
          "qualifiedSignature": "jdk.nashorn.internal.test.models.InternalRunnable.getInvisibleProperty()",
          "exception": "throw new AssertionError();",
          "pathCojunction": "true",
          "backwardsPathConjunction": "true",
          "simplifiedPathConjunction": "true",
          "soundSymbolic": false,
          "soundBackwards": true,
          "maybe": false,
          "line": 67,
          "throwingLine": 69,
          "isStatic": false,
          "targetOnlyArguments": true
        }
      ]
    },
    {
      "path": "/home/yanghengqin/jdk8u_nashorn/src/jdk/nashorn/internal/runtime/ParserException.java",
      "methods": [
        {
          "qualifiedSignature": "jdk.nashorn.internal.runtime.ParserException.throwAsEcmaException()",
          "exception": "throw ECMAErrors.asEcmaException(this);",
          "pathCojunction": "true",
          "backwardsPathConjunction": "true",
          "simplifiedPathConjunction": "true",
          "soundSymbolic": false,
          "soundBackwards": true,
          "maybe": false,
          "line": 106,
          "throwingLine": 107,
          "isStatic": false,
          "targetOnlyArguments": true
        },
        {
          "qualifiedSignature": "jdk.nashorn.internal.runtime.ParserException.throwAsEcmaException(jdk.nashorn.internal.objects.Global)",
          "exception": "throw ECMAErrors.asEcmaException(global, this);",
          "pathCojunction": "true",
          "backwardsPathConjunction": "true",
          "simplifiedPathConjunction": "true",
          "z3Program": "from z3 import *\nfrom z3_all_models import *\n\n\nconstraints = [\n  True\n]\n\nsolver = Solver()\nfor constraint in constraints:\n  solver.add(constraint)\n\nmodels = list(all_smt(solver))\nfor model in models: print(model)",
          "soundSymbolic": false,
          "soundBackwards": true,
          "maybe": false,
          "line": 114,
          "throwingLine": 115,
          "isStatic": false,
          "targetOnlyArguments": true
        }
      ]
    },
    {
      "path": "/home/yanghengqin/jdk8u_nashorn/src/jdk/nashorn/internal/codegen/ApplySpecialization.java",
      "methods": [
        {
          "qualifiedSignature": "jdk.nashorn.internal.codegen.ApplySpecialization.Anonymous-b9f38212-b448-4645-bedc-1e30b4e214f6.leaveIdentNode(jdk.nashorn.internal.ir.IdentNode)",
          "exception": "throw new TransformFailedException(lc.getCurrentFunction(), \"parameter: \" + identNode.getName());",
          "pathCojunction": "(isParam(identNode.getName()))",
          "symbolicPathConjunction": "(isParam(identNode.getName()))",
          "backwardsPathConjunction": "(isParam(identNode.getName()))",
          "simplifiedPathConjunction": "isParam(identNode.getName())",
          "z3Program": "from z3 import *\nfrom z3_all_models import *\n\n\nconstraints = [\n  isParam(identNode0.getName())\n]\n\nsolver = Solver()\nfor constraint in constraints:\n  solver.add(constraint)\n\nmodels = list(all_smt(solver))\nfor model in models: print(model)",
          "symPyProgram": "from sympy import Symbol\nfrom sympy import simplify\nfrom sympy.core.relational import Eq, Ne, StrictGreaterThan, StrictLessThan, LessThan, GreaterThan\nfrom sympy.printing import ccode\n\nidentNode = Symbol('identNode')\n_isParam = Symbol('_isParam')\nidentNode_getName = Symbol('identNode_getName')\npath_conjunction = _isParam\nprint(ccode(simplify(path_conjunction)))",
          "soundSymbolic": false,
          "soundBackwards": true,
          "maybe": true,
          "line": 197,
          "throwingLine": 199,
          "isStatic": false,
          "targetOnlyArguments": true
        }
      ]
    },
    {
      "path": "/home/yanghengqin/jdk8u_nashorn/src/jdk/nashorn/internal/objects/NativeObject.java",
      "methods": [
        {
          "qualifiedSignature": "jdk.nashorn.internal.objects.NativeObject.valueOf(java.lang.Object)",
          "exception": "throw typeError(\"not.an.object\", ScriptRuntime.safeToString(self))",
          "pathCojunction": "(self == null || self == UNDEFINED)",
          "symbolicPathConjunction": "(Global.toObject(self))",
          "backwardsPathConjunction": "(self == null || self == UNDEFINED)",
          "z3Program": "from z3 import *\nfrom z3_all_models import *\n\nself0_isNull = Bool('self0_isNull')\n\nconstraints = [\n  Or(self0_isNull, self0 == UNDEFINED)\n]\n\nsolver = Solver()\nfor constraint in constraints:\n  solver.add(constraint)\n\nmodels = list(all_smt(solver))\nfor model in models: print(model)",
          "symPyProgram": "from sympy import Symbol\nfrom sympy import simplify\nfrom sympy.core.relational import Eq, Ne, StrictGreaterThan, StrictLessThan, LessThan, GreaterThan\nfrom sympy.printing import ccode\n\nself = Symbol('self')\nnull = Symbol('null')\npath_conjunction = ((Eq(self, null)) | (Eq(self, UNDEFINED)))\nprint(ccode(simplify(path_conjunction)))",
          "soundSymbolic": true,
          "soundBackwards": false,
          "maybe": true,
          "line": 528,
          "throwingLine": 529,
          "isStatic": true,
          "targetOnlyArguments": false
        }
      ]
    },
    {
      "path": "/home/yanghengqin/jdk8u_nashorn/src/jdk/nashorn/api/scripting/AbstractJSObject.java",
      "methods": [
        {
          "qualifiedSignature": "jdk.nashorn.api.scripting.AbstractJSObject.call(java.lang.Object, java.lang.Object...)",
          "exception": "throw new UnsupportedOperationException(\"call\");",
          "pathCojunction": "true",
          "backwardsPathConjunction": "true",
          "simplifiedPathConjunction": "true",
          "z3Program": "from z3 import *\nfrom z3_all_models import *\n\n\nconstraints = [\n  True\n]\n\nsolver = Solver()\nfor constraint in constraints:\n  solver.add(constraint)\n\nmodels = list(all_smt(solver))\nfor model in models: print(model)",
          "soundSymbolic": false,
          "soundBackwards": true,
          "maybe": false,
          "line": 56,
          "throwingLine": 57,
          "isStatic": false,
          "targetOnlyArguments": true
        },
        {
          "qualifiedSignature": "jdk.nashorn.api.scripting.AbstractJSObject.newObject(java.lang.Object...)",
          "exception": "throw new UnsupportedOperationException(\"newObject\");",
          "pathCojunction": "true",
          "backwardsPathConjunction": "true",
          "simplifiedPathConjunction": "true",
          "z3Program": "from z3 import *\nfrom z3_all_models import *\n\n\nconstraints = [\n  True\n]\n\nsolver = Solver()\nfor constraint in constraints:\n  solver.add(constraint)\n\nmodels = list(all_smt(solver))\nfor model in models: print(model)",
          "soundSymbolic": false,
          "soundBackwards": true,
          "maybe": false,
          "line": 64,
          "throwingLine": 65,
          "isStatic": false,
          "targetOnlyArguments": true
        },
        {
          "qualifiedSignature": "jdk.nashorn.api.scripting.AbstractJSObject.eval(java.lang.String)",
          "exception": "throw new UnsupportedOperationException(\"eval\");",
          "pathCojunction": "true",
          "backwardsPathConjunction": "true",
          "simplifiedPathConjunction": "true",
          "z3Program": "from z3 import *\nfrom z3_all_models import *\n\ns0 = String('s0')\n\nconstraints = [\n  True\n]\n\nsolver = Solver()\nfor constraint in constraints:\n  solver.add(constraint)\n\nmodels = list(all_smt(solver))\nfor model in models: print(model)",
          "soundSymbolic": false,
          "soundBackwards": true,
          "maybe": false,
          "line": 72,
          "throwingLine": 73,
          "isStatic": false,
          "targetOnlyArguments": true
        },
        {
          "qualifiedSignature": "jdk.nashorn.api.scripting.AbstractJSObject.getMember(java.lang.String)",
          "exception": "throw new NullPointerException()",
          "pathCojunction": "(name == null)",
          "symbolicPathConjunction": "(Objects.requireNonNull(name))",
          "backwardsPathConjunction": "(name == null)",
          "simplifiedPathConjunction": "name == null",
          "z3Inputs": "[name0_isNull = True]\n",
          "z3Program": "from z3 import *\nfrom z3_all_models import *\n\nname0 = String('name0')\nname0_isNull = Bool('name0_isNull')\n\nconstraints = [\n  name0_isNull\n]\n\nsolver = Solver()\nfor constraint in constraints:\n  solver.add(constraint)\n\nmodels = list(all_smt(solver))\nfor model in models: print(model)",
          "symPyProgram": "from sympy import Symbol\nfrom sympy import simplify\nfrom sympy.core.relational import Eq, Ne, StrictGreaterThan, StrictLessThan, LessThan, GreaterThan\nfrom sympy.printing import ccode\n\nname = Symbol('name')\nnull = Symbol('null')\npath_conjunction = (Eq(name, null))\nprint(ccode(simplify(path_conjunction)))",
          "soundSymbolic": true,
          "soundBackwards": true,
          "maybe": false,
          "line": 80,
          "throwingLine": 81,
          "isStatic": false,
          "targetOnlyArguments": true
        },
        {
          "qualifiedSignature": "jdk.nashorn.api.scripting.AbstractJSObject.hasMember(java.lang.String)",
          "exception": "throw new NullPointerException()",
          "pathCojunction": "(name == null)",
          "symbolicPathConjunction": "(Objects.requireNonNull(name))",
          "backwardsPathConjunction": "(name == null)",
          "simplifiedPathConjunction": "name == null",
          "z3Inputs": "[name0_isNull = True]\n",
          "z3Program": "from z3 import *\nfrom z3_all_models import *\n\nname0 = String('name0')\nname0_isNull = Bool('name0_isNull')\n\nconstraints = [\n  name0_isNull\n]\n\nsolver = Solver()\nfor constraint in constraints:\n  solver.add(constraint)\n\nmodels = list(all_smt(solver))\nfor model in models: print(model)",
          "symPyProgram": "from sympy import Symbol\nfrom sympy import simplify\nfrom sympy.core.relational import Eq, Ne, StrictGreaterThan, StrictLessThan, LessThan, GreaterThan\nfrom sympy.printing import ccode\n\nname = Symbol('name')\nnull = Symbol('null')\npath_conjunction = (Eq(name, null))\nprint(ccode(simplify(path_conjunction)))",
          "soundSymbolic": true,
          "soundBackwards": true,
          "maybe": false,
          "line": 97,
          "throwingLine": 98,
          "isStatic": false,
          "targetOnlyArguments": true
        },
        {
          "qualifiedSignature": "jdk.nashorn.api.scripting.AbstractJSObject.removeMember(java.lang.String)",
          "exception": "throw new NullPointerException()",
          "pathCojunction": "(name == null)",
          "symbolicPathConjunction": "(Objects.requireNonNull(name))",
          "backwardsPathConjunction": "(name == null)",
          "simplifiedPathConjunction": "name == null",
          "z3Inputs": "[name0_isNull = True]\n",
          "z3Program": "from z3 import *\nfrom z3_all_models import *\n\nname0 = String('name0')\nname0_isNull = Bool('name0_isNull')\n\nconstraints = [\n  name0_isNull\n]\n\nsolver = Solver()\nfor constraint in constraints:\n  solver.add(constraint)\n\nmodels = list(all_smt(solver))\nfor model in models: print(model)",
          "symPyProgram": "from sympy import Symbol\nfrom sympy import simplify\nfrom sympy.core.relational import Eq, Ne, StrictGreaterThan, StrictLessThan, LessThan, GreaterThan\nfrom sympy.printing import ccode\n\nname = Symbol('name')\nnull = Symbol('null')\npath_conjunction = (Eq(name, null))\nprint(ccode(simplify(path_conjunction)))",
          "soundSymbolic": true,
          "soundBackwards": true,
          "maybe": false,
          "line": 114,
          "throwingLine": 115,
          "isStatic": false,
          "targetOnlyArguments": true
        },
        {
          "qualifiedSignature": "jdk.nashorn.api.scripting.AbstractJSObject.setMember(java.lang.String, java.lang.Object)",
          "exception": "throw new NullPointerException()",
          "pathCojunction": "(name == null)",
          "symbolicPathConjunction": "(Objects.requireNonNull(name))",
          "backwardsPathConjunction": "(name == null)",
          "simplifiedPathConjunction": "name == null",
          "z3Inputs": "[name0_isNull = True]\n",
          "z3Program": "from z3 import *\nfrom z3_all_models import *\n\nname0 = String('name0')\nname0_isNull = Bool('name0_isNull')\n\nconstraints = [\n  name0_isNull\n]\n\nsolver = Solver()\nfor constraint in constraints:\n  solver.add(constraint)\n\nmodels = list(all_smt(solver))\nfor model in models: print(model)",
          "symPyProgram": "from sympy import Symbol\nfrom sympy import simplify\nfrom sympy.core.relational import Eq, Ne, StrictGreaterThan, StrictLessThan, LessThan, GreaterThan\nfrom sympy.printing import ccode\n\nname = Symbol('name')\nnull = Symbol('null')\npath_conjunction = (Eq(name, null))\nprint(ccode(simplify(path_conjunction)))",
          "soundSymbolic": true,
          "soundBackwards": true,
          "maybe": false,
          "line": 123,
          "throwingLine": 124,
          "isStatic": false,
          "targetOnlyArguments": true
        }
      ]
    },
    {
      "path": "/home/yanghengqin/jdk8u_nashorn/src/jdk/nashorn/internal/runtime/arrays/ByteBufferArrayData.java",
      "methods": [
        {
          "qualifiedSignature": "jdk.nashorn.internal.runtime.arrays.ByteBufferArrayData.copy()",
          "exception": "throw unsupported(\"copy\");",
          "pathCojunction": "true",
          "backwardsPathConjunction": "true",
          "simplifiedPathConjunction": "true",
          "soundSymbolic": false,
          "soundBackwards": true,
          "maybe": false,
          "line": 70,
          "throwingLine": 71,
          "isStatic": false,
          "targetOnlyArguments": true
        },
        {
          "qualifiedSignature": "jdk.nashorn.internal.runtime.arrays.ByteBufferArrayData.asObjectArray()",
          "exception": "throw unsupported(\"asObjectArray\");",
          "pathCojunction": "true",
          "backwardsPathConjunction": "true",
          "simplifiedPathConjunction": "true",
          "soundSymbolic": false,
          "soundBackwards": true,
          "maybe": false,
          "line": 75,
          "throwingLine": 76,
          "isStatic": false,
          "targetOnlyArguments": true
        },
        {
          "qualifiedSignature": "jdk.nashorn.internal.runtime.arrays.ByteBufferArrayData.setLength(long)",
          "exception": "throw new UnsupportedOperationException(\"setLength\");",
          "pathCojunction": "true",
          "backwardsPathConjunction": "true",
          "simplifiedPathConjunction": "true",
          "z3Program": "from z3 import *\nfrom z3_all_models import *\n\nlength0 = Int('length0')\n\nconstraints = [\n  length0 >= -9223372036854775808, length0 <= 9223372036854775807, # implicit\n  True\n]\n\nsolver = Solver()\nfor constraint in constraints:\n  solver.add(constraint)\n\nmodels = list(all_smt(solver))\nfor model in models: print(model)",
          "soundSymbolic": false,
          "soundBackwards": true,
          "maybe": false,
          "line": 80,
          "throwingLine": 81,
          "isStatic": false,
          "targetOnlyArguments": true
        },
        {
          "qualifiedSignature": "jdk.nashorn.internal.runtime.arrays.ByteBufferArrayData.shiftLeft(int)",
          "exception": "throw unsupported(\"shiftLeft\");",
          "pathCojunction": "true",
          "backwardsPathConjunction": "true",
          "simplifiedPathConjunction": "true",
          "z3Program": "from z3 import *\nfrom z3_all_models import *\n\nby0 = Int('by0')\n\nconstraints = [\n  True\n]\n\nsolver = Solver()\nfor constraint in constraints:\n  solver.add(constraint)\n\nmodels = list(all_smt(solver))\nfor model in models: print(model)",
          "soundSymbolic": false,
          "soundBackwards": true,
          "maybe": false,
          "line": 85,
          "throwingLine": 86,
          "isStatic": false,
          "targetOnlyArguments": true
        },
        {
          "qualifiedSignature": "jdk.nashorn.internal.runtime.arrays.ByteBufferArrayData.shiftRight(int)",
          "exception": "throw unsupported(\"shiftRight\");",
          "pathCojunction": "true",
          "backwardsPathConjunction": "true",
          "simplifiedPathConjunction": "true",
          "z3Program": "from z3 import *\nfrom z3_all_models import *\n\nby0 = Int('by0')\n\nconstraints = [\n  True\n]\n\nsolver = Solver()\nfor constraint in constraints:\n  solver.add(constraint)\n\nmodels = list(all_smt(solver))\nfor model in models: print(model)",
          "soundSymbolic": false,
          "soundBackwards": true,
          "maybe": false,
          "line": 90,
          "throwingLine": 91,
          "isStatic": false,
          "targetOnlyArguments": true
        },
        {
          "qualifiedSignature": "jdk.nashorn.internal.runtime.arrays.ByteBufferArrayData.ensure(long)",
          "exception": "throw unsupported(\"ensure\");",
          "pathCojunction": "(!(safeIndex < buf.capacity()))",
          "symbolicPathConjunction": "(!(safeIndex < buf.capacity()))",
          "backwardsPathConjunction": "(!(safeIndex < buf.capacity()))",
          "simplifiedPathConjunction": "buf.capacity() <= safeIndex",
          "z3Program": "from z3 import *\nfrom z3_all_models import *\n\nsafeIndex0 = Int('safeIndex0')\n\nconstraints = [\n  safeIndex0 >= -9223372036854775808, safeIndex0 <= 9223372036854775807, # implicit\n  Not(safeIndex0 < buf0.capacity())\n]\n\nsolver = Solver()\nfor constraint in constraints:\n  solver.add(constraint)\n\nmodels = list(all_smt(solver))\nfor model in models: print(model)",
          "symPyProgram": "from sympy import Symbol\nfrom sympy import simplify\nfrom sympy.core.relational import Eq, Ne, StrictGreaterThan, StrictLessThan, LessThan, GreaterThan\nfrom sympy.printing import ccode\n\nsafeIndex = Symbol('safeIndex')\nbuf = Symbol('buf')\nbuf_capacity = Symbol('buf_capacity')\npath_conjunction = (~((StrictLessThan(safeIndex, buf_capacity))))\nprint(ccode(simplify(path_conjunction)))",
          "soundSymbolic": false,
          "soundBackwards": true,
          "maybe": true,
          "line": 95,
          "throwingLine": 100,
          "isStatic": false,
          "targetOnlyArguments": false
        },
        {
          "qualifiedSignature": "jdk.nashorn.internal.runtime.arrays.ByteBufferArrayData.shrink(long)",
          "exception": "throw unsupported(\"shrink\");",
          "pathCojunction": "true",
          "backwardsPathConjunction": "true",
          "simplifiedPathConjunction": "true",
          "z3Program": "from z3 import *\nfrom z3_all_models import *\n\nnewLength0 = Int('newLength0')\n\nconstraints = [\n  newLength0 >= -9223372036854775808, newLength0 <= 9223372036854775807, # implicit\n  True\n]\n\nsolver = Solver()\nfor constraint in constraints:\n  solver.add(constraint)\n\nmodels = list(all_smt(solver))\nfor model in models: print(model)",
          "soundSymbolic": false,
          "soundBackwards": true,
          "maybe": false,
          "line": 104,
          "throwingLine": 105,
          "isStatic": false,
          "targetOnlyArguments": true
        },
        {
          "qualifiedSignature": "jdk.nashorn.internal.runtime.arrays.ByteBufferArrayData.delete(int)",
          "exception": "throw unsupported(\"delete\");",
          "pathCojunction": "true",
          "backwardsPathConjunction": "true",
          "simplifiedPathConjunction": "true",
          "z3Program": "from z3 import *\nfrom z3_all_models import *\n\nindex0 = Int('index0')\n\nconstraints = [\n  True\n]\n\nsolver = Solver()\nfor constraint in constraints:\n  solver.add(constraint)\n\nmodels = list(all_smt(solver))\nfor model in models: print(model)",
          "soundSymbolic": false,
          "soundBackwards": true,
          "maybe": false,
          "line": 161,
          "throwingLine": 162,
          "isStatic": false,
          "targetOnlyArguments": true
        },
        {
          "qualifiedSignature": "jdk.nashorn.internal.runtime.arrays.ByteBufferArrayData.delete(long, long)",
          "exception": "throw unsupported(\"delete\");",
          "pathCojunction": "true",
          "backwardsPathConjunction": "true",
          "simplifiedPathConjunction": "true",
          "z3Program": "from z3 import *\nfrom z3_all_models import *\n\nfromIndex0 = Int('fromIndex0')\ntoIndex0 = Int('toIndex0')\n\nconstraints = [\n  fromIndex0 >= -9223372036854775808, fromIndex0 <= 9223372036854775807, # implicit\n  toIndex0 >= -9223372036854775808, toIndex0 <= 9223372036854775807, # implicit\n  True\n]\n\nsolver = Solver()\nfor constraint in constraints:\n  solver.add(constraint)\n\nmodels = list(all_smt(solver))\nfor model in models: print(model)",
          "soundSymbolic": false,
          "soundBackwards": true,
          "maybe": false,
          "line": 166,
          "throwingLine": 167,
          "isStatic": false,
          "targetOnlyArguments": true
        },
        {
          "qualifiedSignature": "jdk.nashorn.internal.runtime.arrays.ByteBufferArrayData.push(boolean, java.lang.Object...)",
          "exception": "throw unsupported(\"push\");",
          "pathCojunction": "true",
          "backwardsPathConjunction": "true",
          "simplifiedPathConjunction": "true",
          "z3Program": "from z3 import *\nfrom z3_all_models import *\n\nstrict0 = Bool('strict0')\n\nconstraints = [\n  True\n]\n\nsolver = Solver()\nfor constraint in constraints:\n  solver.add(constraint)\n\nmodels = list(all_smt(solver))\nfor model in models: print(model)",
          "soundSymbolic": false,
          "soundBackwards": true,
          "maybe": false,
          "line": 171,
          "throwingLine": 172,
          "isStatic": false,
          "targetOnlyArguments": true
        },
        {
          "qualifiedSignature": "jdk.nashorn.internal.runtime.arrays.ByteBufferArrayData.pop()",
          "exception": "throw unsupported(\"pop\");",
          "pathCojunction": "true",
          "backwardsPathConjunction": "true",
          "simplifiedPathConjunction": "true",
          "soundSymbolic": false,
          "soundBackwards": true,
          "maybe": false,
          "line": 176,
          "throwingLine": 177,
          "isStatic": false,
          "targetOnlyArguments": true
        },
        {
          "qualifiedSignature": "jdk.nashorn.internal.runtime.arrays.ByteBufferArrayData.slice(long, long)",
          "exception": "throw unsupported(\"slice\");",
          "pathCojunction": "true",
          "backwardsPathConjunction": "true",
          "simplifiedPathConjunction": "true",
          "z3Program": "from z3 import *\nfrom z3_all_models import *\n\nfrom0 = Int('from0')\nto0 = Int('to0')\n\nconstraints = [\n  from0 >= -9223372036854775808, from0 <= 9223372036854775807, # implicit\n  to0 >= -9223372036854775808, to0 <= 9223372036854775807, # implicit\n  True\n]\n\nsolver = Solver()\nfor constraint in constraints:\n  solver.add(constraint)\n\nmodels = list(all_smt(solver))\nfor model in models: print(model)",
          "soundSymbolic": false,
          "soundBackwards": true,
          "maybe": false,
          "line": 181,
          "throwingLine": 182,
          "isStatic": false,
          "targetOnlyArguments": true
        },
        {
          "qualifiedSignature": "jdk.nashorn.internal.runtime.arrays.ByteBufferArrayData.convert(java.lang.Class<?>)",
          "exception": "throw unsupported(\"convert\");",
          "pathCojunction": "true",
          "backwardsPathConjunction": "true",
          "simplifiedPathConjunction": "true",
          "z3Program": "from z3 import *\nfrom z3_all_models import *\n\n\nconstraints = [\n  True\n]\n\nsolver = Solver()\nfor constraint in constraints:\n  solver.add(constraint)\n\nmodels = list(all_smt(solver))\nfor model in models: print(model)",
          "soundSymbolic": false,
          "soundBackwards": true,
          "maybe": false,
          "line": 186,
          "throwingLine": 187,
          "isStatic": false,
          "targetOnlyArguments": true
        }
      ]
    },
    {
      "path": "/home/yanghengqin/jdk8u_nashorn/src/jdk/nashorn/internal/runtime/options/Options.java",
      "methods": [
        {
          "qualifiedSignature": "jdk.nashorn.internal.runtime.options.Options.getBooleanProperty(java.lang.String, java.lang.Boolean)",
          "exception": "throw new IllegalArgumentException(name);",
          "pathCojunction": "(!(Objects.requireNonNull(name).startsWith(\"nashorn.\")))",
          "symbolicPathConjunction": "(!Objects.requireNonNull(name).startsWith(\"nashorn.\"))",
          "backwardsPathConjunction": "(!(Objects.requireNonNull(name).startsWith(\"nashorn.\")))",
          "simplifiedPathConjunction": "!Objects.requireNonNull(name)_startsWith",
          "z3Program": "from z3 import *\nfrom z3_all_models import *\n\nname0 = String('name0')\n\nconstraints = [\n  Not(Objects.requireNonNull(name0).startsWith(\"nashorn.\"))\n]\n\nsolver = Solver()\nfor constraint in constraints:\n  solver.add(constraint)\n\nmodels = list(all_smt(solver))\nfor model in models: print(model)",
          "symPyProgram": "from sympy import Symbol\nfrom sympy import simplify\nfrom sympy.core.relational import Eq, Ne, StrictGreaterThan, StrictLessThan, LessThan, GreaterThan\nfrom sympy.printing import ccode\n\nname = Symbol('name')\nObjects_requireNonNull_startsWith = Symbol('Objects_requireNonNull_startsWith')\nObjects_requireNonNull = Symbol('Objects_requireNonNull')\npath_conjunction = (~(Objects_requireNonNull_startsWith))\nprint(ccode(simplify(path_conjunction)))",
          "soundSymbolic": true,
          "soundBackwards": false,
          "maybe": true,
          "line": 152,
          "throwingLine": 153,
          "isStatic": true,
          "targetOnlyArguments": false
        },
        {
          "qualifiedSignature": "jdk.nashorn.internal.runtime.options.Options.getBooleanProperty(java.lang.String, java.lang.Boolean)",
          "exception": "throw new NullPointerException()",
          "pathCojunction": "(name == null)",
          "symbolicPathConjunction": "(!(Objects.requireNonNull(name)))",
          "backwardsPathConjunction": "(name == null)",
          "simplifiedPathConjunction": "name == null",
          "z3Inputs": "[name0_isNull = True]\n",
          "z3Program": "from z3 import *\nfrom z3_all_models import *\n\nname0 = String('name0')\nname0_isNull = Bool('name0_isNull')\n\nconstraints = [\n  name0_isNull\n]\n\nsolver = Solver()\nfor constraint in constraints:\n  solver.add(constraint)\n\nmodels = list(all_smt(solver))\nfor model in models: print(model)",
          "symPyProgram": "from sympy import Symbol\nfrom sympy import simplify\nfrom sympy.core.relational import Eq, Ne, StrictGreaterThan, StrictLessThan, LessThan, GreaterThan\nfrom sympy.printing import ccode\n\nname = Symbol('name')\nnull = Symbol('null')\npath_conjunction = (Eq(name, null))\nprint(ccode(simplify(path_conjunction)))",
          "soundSymbolic": true,
          "soundBackwards": true,
          "maybe": false,
          "line": 152,
          "throwingLine": 153,
          "isStatic": true,
          "targetOnlyArguments": true
        },
        {
          "qualifiedSignature": "jdk.nashorn.internal.runtime.options.Options.getBooleanProperty(java.lang.String)",
          "exception": "throw new NullPointerException()",
          "pathCojunction": "(name == null)",
          "symbolicPathConjunction": "(getBooleanProperty(name, null))",
          "backwardsPathConjunction": "(name == null)",
          "simplifiedPathConjunction": "name == null",
          "z3Inputs": "[name0_isNull = True]\n",
          "z3Program": "from z3 import *\nfrom z3_all_models import *\n\nname0 = String('name0')\nname0_isNull = Bool('name0_isNull')\n\nconstraints = [\n  name0_isNull\n]\n\nsolver = Solver()\nfor constraint in constraints:\n  solver.add(constraint)\n\nmodels = list(all_smt(solver))\nfor model in models: print(model)",
          "symPyProgram": "from sympy import Symbol\nfrom sympy import simplify\nfrom sympy.core.relational import Eq, Ne, StrictGreaterThan, StrictLessThan, LessThan, GreaterThan\nfrom sympy.printing import ccode\n\nname = Symbol('name')\nnull = Symbol('null')\npath_conjunction = (Eq(name, null))\nprint(ccode(simplify(path_conjunction)))",
          "soundSymbolic": true,
          "soundBackwards": true,
          "maybe": false,
          "line": 178,
          "throwingLine": 179,
          "isStatic": true,
          "targetOnlyArguments": true
        },
        {
          "qualifiedSignature": "jdk.nashorn.internal.runtime.options.Options.getBooleanProperty(java.lang.String)",
          "exception": "throw new IllegalArgumentException(name)",
          "pathCojunction": "(!(Objects.requireNonNull(name).startsWith(\"nashorn.\")))",
          "symbolicPathConjunction": "(getBooleanProperty(name, null))",
          "backwardsPathConjunction": "(!(Objects.requireNonNull(name).startsWith(\"nashorn.\")))",
          "simplifiedPathConjunction": "!Objects.requireNonNull(name)_startsWith",
          "z3Program": "from z3 import *\nfrom z3_all_models import *\n\nname0 = String('name0')\n\nconstraints = [\n  Not(Objects.requireNonNull(name0).startsWith(\"nashorn.\"))\n]\n\nsolver = Solver()\nfor constraint in constraints:\n  solver.add(constraint)\n\nmodels = list(all_smt(solver))\nfor model in models: print(model)",
          "symPyProgram": "from sympy import Symbol\nfrom sympy import simplify\nfrom sympy.core.relational import Eq, Ne, StrictGreaterThan, StrictLessThan, LessThan, GreaterThan\nfrom sympy.printing import ccode\n\nname = Symbol('name')\nObjects_requireNonNull_startsWith = Symbol('Objects_requireNonNull_startsWith')\nObjects_requireNonNull = Symbol('Objects_requireNonNull')\npath_conjunction = (~(Objects_requireNonNull_startsWith))\nprint(ccode(simplify(path_conjunction)))",
          "soundSymbolic": true,
          "soundBackwards": false,
          "maybe": true,
          "line": 178,
          "throwingLine": 179,
          "isStatic": true,
          "targetOnlyArguments": false
        },
        {
          "qualifiedSignature": "jdk.nashorn.internal.runtime.options.Options.getStringProperty(java.lang.String, java.lang.String)",
          "exception": "throw new NullPointerException()",
          "pathCojunction": "(name == null)",
          "symbolicPathConjunction": "(!(Objects.requireNonNull(name)))",
          "backwardsPathConjunction": "(name == null)",
          "simplifiedPathConjunction": "name == null",
          "z3Inputs": "[name0_isNull = True]\n",
          "z3Program": "from z3 import *\nfrom z3_all_models import *\n\nname0 = String('name0')\ndefValue0 = String('defValue0')\nname0_isNull = Bool('name0_isNull')\n\nconstraints = [\n  name0_isNull\n]\n\nsolver = Solver()\nfor constraint in constraints:\n  solver.add(constraint)\n\nmodels = list(all_smt(solver))\nfor model in models: print(model)",
          "symPyProgram": "from sympy import Symbol\nfrom sympy import simplify\nfrom sympy.core.relational import Eq, Ne, StrictGreaterThan, StrictLessThan, LessThan, GreaterThan\nfrom sympy.printing import ccode\n\nname = Symbol('name')\nnull = Symbol('null')\npath_conjunction = (Eq(name, null))\nprint(ccode(simplify(path_conjunction)))",
          "soundSymbolic": true,
          "soundBackwards": true,
          "maybe": false,
          "line": 189,
          "throwingLine": 190,
          "isStatic": true,
          "targetOnlyArguments": true
        },
        {
          "qualifiedSignature": "jdk.nashorn.internal.runtime.options.Options.getStringProperty(java.lang.String, java.lang.String)",
          "exception": "throw new IllegalArgumentException(name);",
          "pathCojunction": "(!(Objects.requireNonNull(name).startsWith(\"nashorn.\")))",
          "symbolicPathConjunction": "(!Objects.requireNonNull(name).startsWith(\"nashorn.\"))",
          "backwardsPathConjunction": "(!(Objects.requireNonNull(name).startsWith(\"nashorn.\")))",
          "simplifiedPathConjunction": "!Objects.requireNonNull(name)_startsWith",
          "z3Program": "from z3 import *\nfrom z3_all_models import *\n\nname0 = String('name0')\ndefValue0 = String('defValue0')\n\nconstraints = [\n  Not(Objects.requireNonNull(name0).startsWith(\"nashorn.\"))\n]\n\nsolver = Solver()\nfor constraint in constraints:\n  solver.add(constraint)\n\nmodels = list(all_smt(solver))\nfor model in models: print(model)",
          "symPyProgram": "from sympy import Symbol\nfrom sympy import simplify\nfrom sympy.core.relational import Eq, Ne, StrictGreaterThan, StrictLessThan, LessThan, GreaterThan\nfrom sympy.printing import ccode\n\nname = Symbol('name')\nObjects_requireNonNull_startsWith = Symbol('Objects_requireNonNull_startsWith')\nObjects_requireNonNull = Symbol('Objects_requireNonNull')\npath_conjunction = (~(Objects_requireNonNull_startsWith))\nprint(ccode(simplify(path_conjunction)))",
          "soundSymbolic": true,
          "soundBackwards": false,
          "maybe": true,
          "line": 189,
          "throwingLine": 190,
          "isStatic": true,
          "targetOnlyArguments": false
        },
        {
          "qualifiedSignature": "jdk.nashorn.internal.runtime.options.Options.getIntProperty(java.lang.String, int)",
          "exception": "throw new NullPointerException()",
          "pathCojunction": "(name == null)",
          "symbolicPathConjunction": "(!(Objects.requireNonNull(name)))",
          "backwardsPathConjunction": "(name == null)",
          "simplifiedPathConjunction": "name == null",
          "z3Inputs": "[name0_isNull = True]\n",
          "z3Program": "from z3 import *\nfrom z3_all_models import *\n\nname0 = String('name0')\ndefValue0 = Int('defValue0')\nname0_isNull = Bool('name0_isNull')\n\nconstraints = [\n  name0_isNull\n]\n\nsolver = Solver()\nfor constraint in constraints:\n  solver.add(constraint)\n\nmodels = list(all_smt(solver))\nfor model in models: print(model)",
          "symPyProgram": "from sympy import Symbol\nfrom sympy import simplify\nfrom sympy.core.relational import Eq, Ne, StrictGreaterThan, StrictLessThan, LessThan, GreaterThan\nfrom sympy.printing import ccode\n\nname = Symbol('name')\nnull = Symbol('null')\npath_conjunction = (Eq(name, null))\nprint(ccode(simplify(path_conjunction)))",
          "soundSymbolic": true,
          "soundBackwards": true,
          "maybe": false,
          "line": 212,
          "throwingLine": 213,
          "isStatic": true,
          "targetOnlyArguments": true
        },
        {
          "qualifiedSignature": "jdk.nashorn.internal.runtime.options.Options.getIntProperty(java.lang.String, int)",
          "exception": "throw new IllegalArgumentException(name);",
          "pathCojunction": "(!(Objects.requireNonNull(name).startsWith(\"nashorn.\")))",
          "symbolicPathConjunction": "(!Objects.requireNonNull(name).startsWith(\"nashorn.\"))",
          "backwardsPathConjunction": "(!(Objects.requireNonNull(name).startsWith(\"nashorn.\")))",
          "simplifiedPathConjunction": "!Objects.requireNonNull(name)_startsWith",
          "z3Program": "from z3 import *\nfrom z3_all_models import *\n\nname0 = String('name0')\ndefValue0 = Int('defValue0')\n\nconstraints = [\n  Not(Objects.requireNonNull(name0).startsWith(\"nashorn.\"))\n]\n\nsolver = Solver()\nfor constraint in constraints:\n  solver.add(constraint)\n\nmodels = list(all_smt(solver))\nfor model in models: print(model)",
          "symPyProgram": "from sympy import Symbol\nfrom sympy import simplify\nfrom sympy.core.relational import Eq, Ne, StrictGreaterThan, StrictLessThan, LessThan, GreaterThan\nfrom sympy.printing import ccode\n\nname = Symbol('name')\nObjects_requireNonNull_startsWith = Symbol('Objects_requireNonNull_startsWith')\nObjects_requireNonNull = Symbol('Objects_requireNonNull')\npath_conjunction = (~(Objects_requireNonNull_startsWith))\nprint(ccode(simplify(path_conjunction)))",
          "soundSymbolic": true,
          "soundBackwards": false,
          "maybe": true,
          "line": 212,
          "throwingLine": 213,
          "isStatic": true,
          "targetOnlyArguments": false
        },
        {
          "qualifiedSignature": "jdk.nashorn.internal.runtime.options.Options.process(java.lang.String[])",
          "exception": "throw new IllegalArgumentException(NASHORN_ARGS_PREPEND_PROPERTY)",
          "pathCojunction": "(!(Objects.requireNonNull(NASHORN_ARGS_PREPEND_PROPERTY).startsWith(\"nashorn.\")))",
          "symbolicPathConjunction": "(getStringProperty(sysPropName, null))",
          "backwardsPathConjunction": "(!(Objects.requireNonNull(NASHORN_ARGS_PREPEND_PROPERTY).startsWith(\"nashorn.\")))",
          "simplifiedPathConjunction": "!Objects.requireNonNull(NASHORN_ARGS_PREPEND_PROPERTY).startsWith(\"nashorn.\")",
          "z3Program": "from z3 import *\nfrom z3_all_models import *\n\n\nconstraints = [\n  argList0 == new LinkedList<>(),\n  Not(Objects.requireNonNull(NASHORN_ARGS_PREPEND_PROPERTY).startsWith(\"nashorn.\"))\n]\n\nsolver = Solver()\nfor constraint in constraints:\n  solver.add(constraint)\n\nmodels = list(all_smt(solver))\nfor model in models: print(model)",
          "symPyProgram": "from sympy import Symbol\nfrom sympy import simplify\nfrom sympy.core.relational import Eq, Ne, StrictGreaterThan, StrictLessThan, LessThan, GreaterThan\nfrom sympy.printing import ccode\n\nObjects_requireNonNull_startsWith = Symbol('Objects_requireNonNull_startsWith')\nObjects_requireNonNull = Symbol('Objects_requireNonNull')\npath_conjunction = (~(Objects_requireNonNull_startsWith))\nprint(ccode(simplify(path_conjunction)))",
          "soundSymbolic": true,
          "soundBackwards": false,
          "maybe": true,
          "line": 418,
          "throwingLine": 420,
          "isStatic": false,
          "targetOnlyArguments": false
        }
      ]
    },
    {
      "path": "/home/yanghengqin/jdk8u_nashorn/src/jdk/nashorn/internal/runtime/arrays/TypedArrayData.java",
      "methods": [
        {
          "qualifiedSignature": "jdk.nashorn.internal.runtime.arrays.TypedArrayData.copy()",
          "exception": "throw new UnsupportedOperationException();",
          "pathCojunction": "true",
          "backwardsPathConjunction": "true",
          "simplifiedPathConjunction": "true",
          "soundSymbolic": false,
          "soundBackwards": true,
          "maybe": false,
          "line": 91,
          "throwingLine": 92,
          "isStatic": false,
          "targetOnlyArguments": true
        },
        {
          "qualifiedSignature": "jdk.nashorn.internal.runtime.arrays.TypedArrayData.asObjectArray()",
          "exception": "throw new UnsupportedOperationException();",
          "pathCojunction": "true",
          "backwardsPathConjunction": "true",
          "simplifiedPathConjunction": "true",
          "soundSymbolic": false,
          "soundBackwards": true,
          "maybe": false,
          "line": 96,
          "throwingLine": 97,
          "isStatic": false,
          "targetOnlyArguments": true
        },
        {
          "qualifiedSignature": "jdk.nashorn.internal.runtime.arrays.TypedArrayData.shiftLeft(int)",
          "exception": "throw new UnsupportedOperationException();",
          "pathCojunction": "true",
          "backwardsPathConjunction": "true",
          "simplifiedPathConjunction": "true",
          "z3Program": "from z3 import *\nfrom z3_all_models import *\n\nby0 = Int('by0')\n\nconstraints = [\n  True\n]\n\nsolver = Solver()\nfor constraint in constraints:\n  solver.add(constraint)\n\nmodels = list(all_smt(solver))\nfor model in models: print(model)",
          "soundSymbolic": false,
          "soundBackwards": true,
          "maybe": false,
          "line": 101,
          "throwingLine": 102,
          "isStatic": false,
          "targetOnlyArguments": true
        },
        {
          "qualifiedSignature": "jdk.nashorn.internal.runtime.arrays.TypedArrayData.shiftRight(int)",
          "exception": "throw new UnsupportedOperationException();",
          "pathCojunction": "true",
          "backwardsPathConjunction": "true",
          "simplifiedPathConjunction": "true",
          "z3Program": "from z3 import *\nfrom z3_all_models import *\n\nby0 = Int('by0')\n\nconstraints = [\n  True\n]\n\nsolver = Solver()\nfor constraint in constraints:\n  solver.add(constraint)\n\nmodels = list(all_smt(solver))\nfor model in models: print(model)",
          "soundSymbolic": false,
          "soundBackwards": true,
          "maybe": false,
          "line": 106,
          "throwingLine": 107,
          "isStatic": false,
          "targetOnlyArguments": true
        },
        {
          "qualifiedSignature": "jdk.nashorn.internal.runtime.arrays.TypedArrayData.shrink(long)",
          "exception": "throw new UnsupportedOperationException();",
          "pathCojunction": "true",
          "backwardsPathConjunction": "true",
          "simplifiedPathConjunction": "true",
          "z3Program": "from z3 import *\nfrom z3_all_models import *\n\nnewLength0 = Int('newLength0')\n\nconstraints = [\n  newLength0 >= -9223372036854775808, newLength0 <= 9223372036854775807, # implicit\n  True\n]\n\nsolver = Solver()\nfor constraint in constraints:\n  solver.add(constraint)\n\nmodels = list(all_smt(solver))\nfor model in models: print(model)",
          "soundSymbolic": false,
          "soundBackwards": true,
          "maybe": false,
          "line": 116,
          "throwingLine": 117,
          "isStatic": false,
          "targetOnlyArguments": true
        },
        {
          "qualifiedSignature": "jdk.nashorn.internal.runtime.arrays.TypedArrayData.convert(java.lang.Class<?>)",
          "exception": "throw new UnsupportedOperationException();",
          "pathCojunction": "true",
          "backwardsPathConjunction": "true",
          "simplifiedPathConjunction": "true",
          "z3Program": "from z3 import *\nfrom z3_all_models import *\n\n\nconstraints = [\n  True\n]\n\nsolver = Solver()\nfor constraint in constraints:\n  solver.add(constraint)\n\nmodels = list(all_smt(solver))\nfor model in models: print(model)",
          "soundSymbolic": false,
          "soundBackwards": true,
          "maybe": false,
          "line": 136,
          "throwingLine": 137,
          "isStatic": false,
          "targetOnlyArguments": true
        },
        {
          "qualifiedSignature": "jdk.nashorn.internal.runtime.arrays.TypedArrayData.pop()",
          "exception": "throw new UnsupportedOperationException();",
          "pathCojunction": "true",
          "backwardsPathConjunction": "true",
          "simplifiedPathConjunction": "true",
          "soundSymbolic": false,
          "soundBackwards": true,
          "maybe": false,
          "line": 141,
          "throwingLine": 142,
          "isStatic": false,
          "targetOnlyArguments": true
        },
        {
          "qualifiedSignature": "jdk.nashorn.internal.runtime.arrays.TypedArrayData.slice(long, long)",
          "exception": "throw new UnsupportedOperationException();",
          "pathCojunction": "true",
          "backwardsPathConjunction": "true",
          "simplifiedPathConjunction": "true",
          "z3Program": "from z3 import *\nfrom z3_all_models import *\n\nfrom0 = Int('from0')\nto0 = Int('to0')\n\nconstraints = [\n  from0 >= -9223372036854775808, from0 <= 9223372036854775807, # implicit\n  to0 >= -9223372036854775808, to0 <= 9223372036854775807, # implicit\n  True\n]\n\nsolver = Solver()\nfor constraint in constraints:\n  solver.add(constraint)\n\nmodels = list(all_smt(solver))\nfor model in models: print(model)",
          "soundSymbolic": false,
          "soundBackwards": true,
          "maybe": false,
          "line": 146,
          "throwingLine": 147,
          "isStatic": false,
          "targetOnlyArguments": true
        }
      ]
    },
    {
      "path": "/home/yanghengqin/jdk8u_nashorn/src/jdk/nashorn/internal/runtime/NativeJavaPackage.java",
      "methods": [
        {
          "qualifiedSignature": "jdk.nashorn.internal.runtime.NativeJavaPackage.__noSuchProperty__(java.lang.Object, java.lang.Object)",
          "exception": "throw new AssertionError(\"__noSuchProperty__ placeholder called\");",
          "pathCojunction": "true",
          "backwardsPathConjunction": "true",
          "simplifiedPathConjunction": "true",
          "z3Program": "from z3 import *\nfrom z3_all_models import *\n\n\nconstraints = [\n  True\n]\n\nsolver = Solver()\nfor constraint in constraints:\n  solver.add(constraint)\n\nmodels = list(all_smt(solver))\nfor model in models: print(model)",
          "soundSymbolic": false,
          "soundBackwards": true,
          "maybe": false,
          "line": 176,
          "throwingLine": 177,
          "isStatic": true,
          "targetOnlyArguments": true
        },
        {
          "qualifiedSignature": "jdk.nashorn.internal.runtime.NativeJavaPackage.__noSuchMethod__(java.lang.Object, java.lang.Object...)",
          "exception": "throw new AssertionError(\"__noSuchMethod__ placeholder called\");",
          "pathCojunction": "true",
          "backwardsPathConjunction": "true",
          "simplifiedPathConjunction": "true",
          "z3Program": "from z3 import *\nfrom z3_all_models import *\n\n\nconstraints = [\n  True\n]\n\nsolver = Solver()\nfor constraint in constraints:\n  solver.add(constraint)\n\nmodels = list(all_smt(solver))\nfor model in models: print(model)",
          "soundSymbolic": false,
          "soundBackwards": true,
          "maybe": false,
          "line": 191,
          "throwingLine": 192,
          "isStatic": true,
          "targetOnlyArguments": true
        }
      ]
    },
    {
      "path": "/home/yanghengqin/jdk8u_nashorn/src/jdk/nashorn/internal/runtime/arrays/ContinuousArrayData.java",
      "methods": [
        {
          "qualifiedSignature": "jdk.nashorn.internal.runtime.arrays.ContinuousArrayData.fastPush(int)",
          "exception": "throw new ClassCastException(String.valueOf(getClass()));",
          "pathCojunction": "true",
          "backwardsPathConjunction": "true",
          "simplifiedPathConjunction": "true",
          "z3Program": "from z3 import *\nfrom z3_all_models import *\n\narg0 = Int('arg0')\n\nconstraints = [\n  True\n]\n\nsolver = Solver()\nfor constraint in constraints:\n  solver.add(constraint)\n\nmodels = list(all_smt(solver))\nfor model in models: print(model)",
          "soundSymbolic": false,
          "soundBackwards": true,
          "maybe": false,
          "line": 293,
          "throwingLine": 294,
          "isStatic": false,
          "targetOnlyArguments": true
        },
        {
          "qualifiedSignature": "jdk.nashorn.internal.runtime.arrays.ContinuousArrayData.fastPush(long)",
          "exception": "throw new ClassCastException(String.valueOf(getClass()));",
          "pathCojunction": "true",
          "backwardsPathConjunction": "true",
          "simplifiedPathConjunction": "true",
          "z3Program": "from z3 import *\nfrom z3_all_models import *\n\narg0 = Int('arg0')\n\nconstraints = [\n  arg0 >= -9223372036854775808, arg0 <= 9223372036854775807, # implicit\n  True\n]\n\nsolver = Solver()\nfor constraint in constraints:\n  solver.add(constraint)\n\nmodels = list(all_smt(solver))\nfor model in models: print(model)",
          "soundSymbolic": false,
          "soundBackwards": true,
          "maybe": false,
          "line": 302,
          "throwingLine": 303,
          "isStatic": false,
          "targetOnlyArguments": true
        },
        {
          "qualifiedSignature": "jdk.nashorn.internal.runtime.arrays.ContinuousArrayData.fastPush(double)",
          "exception": "throw new ClassCastException(String.valueOf(getClass()));",
          "pathCojunction": "true",
          "backwardsPathConjunction": "true",
          "simplifiedPathConjunction": "true",
          "z3Program": "from z3 import *\nfrom z3_all_models import *\n\narg0 = Real('arg0')\n\nconstraints = [\n  True\n]\n\nsolver = Solver()\nfor constraint in constraints:\n  solver.add(constraint)\n\nmodels = list(all_smt(solver))\nfor model in models: print(model)",
          "soundSymbolic": false,
          "soundBackwards": true,
          "maybe": false,
          "line": 311,
          "throwingLine": 312,
          "isStatic": false,
          "targetOnlyArguments": true
        },
        {
          "qualifiedSignature": "jdk.nashorn.internal.runtime.arrays.ContinuousArrayData.fastPush(java.lang.Object)",
          "exception": "throw new ClassCastException(String.valueOf(getClass()));",
          "pathCojunction": "true",
          "backwardsPathConjunction": "true",
          "simplifiedPathConjunction": "true",
          "z3Program": "from z3 import *\nfrom z3_all_models import *\n\n\nconstraints = [\n  True\n]\n\nsolver = Solver()\nfor constraint in constraints:\n  solver.add(constraint)\n\nmodels = list(all_smt(solver))\nfor model in models: print(model)",
          "soundSymbolic": false,
          "soundBackwards": true,
          "maybe": false,
          "line": 320,
          "throwingLine": 321,
          "isStatic": false,
          "targetOnlyArguments": true
        },
        {
          "qualifiedSignature": "jdk.nashorn.internal.runtime.arrays.ContinuousArrayData.fastPopInt()",
          "exception": "throw new ClassCastException(String.valueOf(getClass()));",
          "pathCojunction": "true",
          "backwardsPathConjunction": "true",
          "simplifiedPathConjunction": "true",
          "soundSymbolic": false,
          "soundBackwards": true,
          "maybe": false,
          "line": 328,
          "throwingLine": 329,
          "isStatic": false,
          "targetOnlyArguments": true
        },
        {
          "qualifiedSignature": "jdk.nashorn.internal.runtime.arrays.ContinuousArrayData.fastPopDouble()",
          "exception": "throw new ClassCastException(String.valueOf(getClass()));",
          "pathCojunction": "true",
          "backwardsPathConjunction": "true",
          "simplifiedPathConjunction": "true",
          "soundSymbolic": false,
          "soundBackwards": true,
          "maybe": false,
          "line": 336,
          "throwingLine": 337,
          "isStatic": false,
          "targetOnlyArguments": true
        },
        {
          "qualifiedSignature": "jdk.nashorn.internal.runtime.arrays.ContinuousArrayData.fastPopObject()",
          "exception": "throw new ClassCastException(String.valueOf(getClass()));",
          "pathCojunction": "true",
          "backwardsPathConjunction": "true",
          "simplifiedPathConjunction": "true",
          "soundSymbolic": false,
          "soundBackwards": true,
          "maybe": false,
          "line": 344,
          "throwingLine": 345,
          "isStatic": false,
          "targetOnlyArguments": true
        },
        {
          "qualifiedSignature": "jdk.nashorn.internal.runtime.arrays.ContinuousArrayData.fastConcat(jdk.nashorn.internal.runtime.arrays.ContinuousArrayData)",
          "exception": "throw new ClassCastException(String.valueOf(getClass()) + \" != \" + String.valueOf(otherData.getClass()));",
          "pathCojunction": "true",
          "backwardsPathConjunction": "true",
          "simplifiedPathConjunction": "true",
          "z3Program": "from z3 import *\nfrom z3_all_models import *\n\n\nconstraints = [\n  True\n]\n\nsolver = Solver()\nfor constraint in constraints:\n  solver.add(constraint)\n\nmodels = list(all_smt(solver))\nfor model in models: print(model)",
          "soundSymbolic": false,
          "soundBackwards": true,
          "maybe": false,
          "line": 353,
          "throwingLine": 354,
          "isStatic": false,
          "targetOnlyArguments": true
        }
      ]
    },
    {
      "path": "/home/yanghengqin/jdk8u_nashorn/src/jdk/nashorn/internal/runtime/Source.java",
      "methods": [
        {
          "qualifiedSignature": "jdk.nashorn.internal.runtime.Source.readFully(java.io.File)",
          "exception": "throw new IOException(file + \" is not a file\");",
          "pathCojunction": "(!(file.isFile()))",
          "symbolicPathConjunction": "(!file.isFile())",
          "backwardsPathConjunction": "(!(file.isFile()))",
          "simplifiedPathConjunction": "!file.isFile()",
          "z3Program": "from z3 import *\nfrom z3_all_models import *\n\n\nconstraints = [\n  Not(file0.isFile())\n]\n\nsolver = Solver()\nfor constraint in constraints:\n  solver.add(constraint)\n\nmodels = list(all_smt(solver))\nfor model in models: print(model)",
          "symPyProgram": "from sympy import Symbol\nfrom sympy import simplify\nfrom sympy.core.relational import Eq, Ne, StrictGreaterThan, StrictLessThan, LessThan, GreaterThan\nfrom sympy.printing import ccode\n\nfile = Symbol('file')\nfile_isFile = Symbol('file_isFile')\npath_conjunction = (~(file_isFile))\nprint(ccode(simplify(path_conjunction)))",
          "soundSymbolic": false,
          "soundBackwards": true,
          "maybe": true,
          "line": 767,
          "throwingLine": 769,
          "isStatic": true,
          "targetOnlyArguments": true
        },
        {
          "qualifiedSignature": "jdk.nashorn.internal.runtime.Source.readFully(java.io.File, java.nio.charset.Charset)",
          "exception": "throw new IOException(file + \" is not a file\");",
          "pathCojunction": "(!(file.isFile()))",
          "symbolicPathConjunction": "(!file.isFile())",
          "backwardsPathConjunction": "(!(file.isFile()))",
          "simplifiedPathConjunction": "!file.isFile()",
          "z3Program": "from z3 import *\nfrom z3_all_models import *\n\n\nconstraints = [\n  Not(file0.isFile())\n]\n\nsolver = Solver()\nfor constraint in constraints:\n  solver.add(constraint)\n\nmodels = list(all_smt(solver))\nfor model in models: print(model)",
          "symPyProgram": "from sympy import Symbol\nfrom sympy import simplify\nfrom sympy.core.relational import Eq, Ne, StrictGreaterThan, StrictLessThan, LessThan, GreaterThan\nfrom sympy.printing import ccode\n\nfile = Symbol('file')\nfile_isFile = Symbol('file_isFile')\npath_conjunction = (~(file_isFile))\nprint(ccode(simplify(path_conjunction)))",
          "soundSymbolic": false,
          "soundBackwards": true,
          "maybe": true,
          "line": 782,
          "throwingLine": 784,
          "isStatic": true,
          "targetOnlyArguments": true
        }
      ]
    },
    {
      "path": "/home/yanghengqin/jdk8u_nashorn/src/jdk/nashorn/internal/codegen/ObjectClassGenerator.java",
      "methods": [
        {
          "qualifiedSignature": "jdk.nashorn.internal.codegen.ObjectClassGenerator.getFieldCount(java.lang.Class<?>)",
          "exception": "throw new AssertionError(\"Not a structure class: \" + name)",
          "pathCojunction": "(!(name.startsWith(JS_OBJECT_DUAL_FIELD_PREFIX.symbolName()))) && (!(name.startsWith(JS_OBJECT_SINGLE_FIELD_PREFIX.symbolName())))",
          "symbolicPathConjunction": "((!(className.startsWith(JS_OBJECT_DUAL_FIELD_PREFIX.symbolName()))) && (!(className.startsWith(JS_OBJECT_SINGLE_FIELD_PREFIX.symbolName()))))",
          "backwardsPathConjunction": "(!(clazz.getSimpleName().startsWith(JS_OBJECT_DUAL_FIELD_PREFIX.symbolName()))) && (!(clazz.getSimpleName().startsWith(JS_OBJECT_SINGLE_FIELD_PREFIX.symbolName())))",
          "simplifiedPathConjunction": "!clazz.getSimpleName().startsWith(JS_OBJECT_SINGLE_FIELD_PREFIX.symbolName())",
          "z3Program": "from z3 import *\nfrom z3_all_models import *\n\nname0 = String('name0')\n\nconstraints = [\n  name0 == clazz0.getSimpleName(),\n  And(Not(name0.startsWith(JS_OBJECT_DUAL_FIELD_PREFIX.symbolName())), Not(name0.startsWith(JS_OBJECT_SINGLE_FIELD_PREFIX.symbolName())))\n]\n\nsolver = Solver()\nfor constraint in constraints:\n  solver.add(constraint)\n\nmodels = list(all_smt(solver))\nfor model in models: print(model)",
          "symPyProgram": "from sympy import Symbol\nfrom sympy import simplify\nfrom sympy.core.relational import Eq, Ne, StrictGreaterThan, StrictLessThan, LessThan, GreaterThan\nfrom sympy.printing import ccode\n\nclazz = Symbol('clazz')\nclazz_getSimpleName_startsWith = Symbol('clazz_getSimpleName_startsWith')\nclazz_getSimpleName = Symbol('clazz_getSimpleName')\nJS_OBJECT_DUAL_FIELD_PREFIX_symbolName = Symbol('JS_OBJECT_DUAL_FIELD_PREFIX_symbolName')\nJS_OBJECT_SINGLE_FIELD_PREFIX_symbolName = Symbol('JS_OBJECT_SINGLE_FIELD_PREFIX_symbolName')\npath_conjunction = ((~(clazz_getSimpleName_startsWith)) & (~(clazz_getSimpleName_startsWith)))\nprint(ccode(simplify(path_conjunction)))",
          "soundSymbolic": false,
          "soundBackwards": false,
          "maybe": true,
          "line": 209,
          "throwingLine": 211,
          "isStatic": true,
          "targetOnlyArguments": false
        }
      ]
    },
    {
      "path": "/home/yanghengqin/jdk8u_nashorn/src/jdk/nashorn/internal/runtime/arrays/FrozenArrayFilter.java",
      "methods": [
        {
          "qualifiedSignature": "jdk.nashorn.internal.runtime.arrays.FrozenArrayFilter.set(int, int, boolean)",
          "exception": "throw typeError(\"cant.set.property\", Integer.toString(index), \"frozen array\");",
          "pathCojunction": "(strict)",
          "symbolicPathConjunction": "(strict)",
          "backwardsPathConjunction": "(strict)",
          "simplifiedPathConjunction": "strict",
          "z3Inputs": "[strict0 = True]\n",
          "z3Program": "from z3 import *\nfrom z3_all_models import *\n\nindex0 = Int('index0')\nvalue0 = Int('value0')\nstrict0 = Bool('strict0')\n\nconstraints = [\n  strict0\n]\n\nsolver = Solver()\nfor constraint in constraints:\n  solver.add(constraint)\n\nmodels = list(all_smt(solver))\nfor model in models: print(model)",
          "symPyProgram": "from sympy import Symbol\nfrom sympy import simplify\nfrom sympy.core.relational import Eq, Ne, StrictGreaterThan, StrictLessThan, LessThan, GreaterThan\nfrom sympy.printing import ccode\n\nstrict = Symbol('strict')\npath_conjunction = strict\nprint(ccode(simplify(path_conjunction)))",
          "soundSymbolic": true,
          "soundBackwards": true,
          "maybe": false,
          "line": 52,
          "throwingLine": 54,
          "isStatic": false,
          "targetOnlyArguments": true
        },
        {
          "qualifiedSignature": "jdk.nashorn.internal.runtime.arrays.FrozenArrayFilter.set(int, double, boolean)",
          "exception": "throw typeError(\"cant.set.property\", Integer.toString(index), \"frozen array\");",
          "pathCojunction": "(strict)",
          "symbolicPathConjunction": "(strict)",
          "backwardsPathConjunction": "(strict)",
          "simplifiedPathConjunction": "strict",
          "z3Inputs": "[strict0 = True]\n",
          "z3Program": "from z3 import *\nfrom z3_all_models import *\n\nindex0 = Int('index0')\nvalue0 = Real('value0')\nstrict0 = Bool('strict0')\n\nconstraints = [\n  strict0\n]\n\nsolver = Solver()\nfor constraint in constraints:\n  solver.add(constraint)\n\nmodels = list(all_smt(solver))\nfor model in models: print(model)",
          "symPyProgram": "from sympy import Symbol\nfrom sympy import simplify\nfrom sympy.core.relational import Eq, Ne, StrictGreaterThan, StrictLessThan, LessThan, GreaterThan\nfrom sympy.printing import ccode\n\nstrict = Symbol('strict')\npath_conjunction = strict\nprint(ccode(simplify(path_conjunction)))",
          "soundSymbolic": true,
          "soundBackwards": true,
          "maybe": false,
          "line": 60,
          "throwingLine": 62,
          "isStatic": false,
          "targetOnlyArguments": true
        },
        {
          "qualifiedSignature": "jdk.nashorn.internal.runtime.arrays.FrozenArrayFilter.set(int, java.lang.Object, boolean)",
          "exception": "throw typeError(\"cant.set.property\", Integer.toString(index), \"frozen array\");",
          "pathCojunction": "(strict)",
          "symbolicPathConjunction": "(strict)",
          "backwardsPathConjunction": "(strict)",
          "simplifiedPathConjunction": "strict",
          "z3Inputs": "[strict0 = True]\n",
          "z3Program": "from z3 import *\nfrom z3_all_models import *\n\nindex0 = Int('index0')\nstrict0 = Bool('strict0')\n\nconstraints = [\n  strict0\n]\n\nsolver = Solver()\nfor constraint in constraints:\n  solver.add(constraint)\n\nmodels = list(all_smt(solver))\nfor model in models: print(model)",
          "symPyProgram": "from sympy import Symbol\nfrom sympy import simplify\nfrom sympy.core.relational import Eq, Ne, StrictGreaterThan, StrictLessThan, LessThan, GreaterThan\nfrom sympy.printing import ccode\n\nstrict = Symbol('strict')\npath_conjunction = strict\nprint(ccode(simplify(path_conjunction)))",
          "soundSymbolic": true,
          "soundBackwards": true,
          "maybe": false,
          "line": 68,
          "throwingLine": 70,
          "isStatic": false,
          "targetOnlyArguments": true
        }
      ]
    },
    {
      "path": "/home/yanghengqin/jdk8u_nashorn/src/jdk/nashorn/internal/runtime/regexp/joni/CodeRangeBuffer.java",
      "methods": [
        {
          "qualifiedSignature": "jdk.nashorn.internal.runtime.regexp.joni.CodeRangeBuffer.addCodeRangeToBuff(jdk.nashorn.internal.runtime.regexp.joni.CodeRangeBuffer, int, int)",
          "exception": "throw new ValueException(ErrorMessages.ERR_TOO_MANY_MULTI_BYTE_RANGES);",
          "pathCojunction": "(from > to) && (pbuf == null) && (!(low < bound)) && (!(high < bound)) && (n + incN > Config.MAX_MULTI_BYTE_RANGES_NUM)",
          "symbolicPathConjunction": "(from > to) && (pbuf == null) && (!(low < bound)) && (!(high < bound)) && (n + incN > Config.MAX_MULTI_BYTE_RANGES_NUM)",
          "backwardsPathConjunction": "(to > n) && (new CodeRangeBuffer() == null) && (!(0 < n)) && (!(low < n)) && (p[0] + low + 1 - 0 > Config.MAX_MULTI_BYTE_RANGES_NUM)",
          "z3Program": "from z3 import *\nfrom z3_all_models import *\n\nfromp0 = Int('fromp0')\ntop0 = Int('top0')\nn0 = Int('n0')\nfrom0 = Int('from0')\nto0 = Int('to0')\nn1 = Int('n1')\nlow0 = Int('low0')\nbound0 = Int('bound0')\nhigh0 = Int('high0')\nincN0 = Int('incN0')\nConfig_MAX_MULTI_BYTE_RANGES_NUM0 = Int('Config_MAX_MULTI_BYTE_RANGES_NUM0')\npbuf1_isNull = Bool('pbuf1_isNull')\n\nconstraints = [\n  pbuf0 == pbufp0,\n  n0 == from,\n  from0 == to,\n  to0 == n0,\n  pbuf1 == new CodeRangeBuffer(),\n  p0 == pbuf1.p,\n  n1 == p0[0],\n  low0 == 0,\n  bound0 == n1,\n  high0 == low0,\n  incN0 == low0 + 1 - high0,\n  And(And(And(And(from0 > to0, pbuf1_isNull), Not(low0 < bound0)), Not(high0 < bound0)), n1 + incN0 > Config_MAX_MULTI_BYTE_RANGES_NUM0)\n]\n\nsolver = Solver()\nfor constraint in constraints:\n  solver.add(constraint)\n\nmodels = list(all_smt(solver))\nfor model in models: print(model)",
          "soundSymbolic": true,
          "soundBackwards": false,
          "maybe": true,
          "line": 139,
          "throwingLine": 183,
          "isStatic": true,
          "targetOnlyArguments": false
        },
        {
          "qualifiedSignature": "jdk.nashorn.internal.runtime.regexp.joni.CodeRangeBuffer.addCodeRangeToBuff(jdk.nashorn.internal.runtime.regexp.joni.CodeRangeBuffer, int, int)",
          "exception": "throw new ValueException(ErrorMessages.ERR_TOO_MANY_MULTI_BYTE_RANGES);",
          "pathCojunction": "(!(from > to)) && (!(pbuf == null)) && (!(low < bound)) && (!(high < bound)) && (n + incN > Config.MAX_MULTI_BYTE_RANGES_NUM)",
          "symbolicPathConjunction": "(!(from > to)) && (!(pbuf == null)) && (!(low < bound)) && (!(high < bound)) && (n + incN > Config.MAX_MULTI_BYTE_RANGES_NUM)",
          "backwardsPathConjunction": "(!(from > to)) && (!(pbufp == null)) && (!(0 < n)) && (!(low < n)) && (p[0] + low + 1 - 0 > Config.MAX_MULTI_BYTE_RANGES_NUM)",
          "z3Program": "from z3 import *\nfrom z3_all_models import *\n\nfromp0 = Int('fromp0')\ntop0 = Int('top0')\nn0 = Int('n0')\nlow0 = Int('low0')\nbound0 = Int('bound0')\nhigh0 = Int('high0')\nincN0 = Int('incN0')\nConfig_MAX_MULTI_BYTE_RANGES_NUM0 = Int('Config_MAX_MULTI_BYTE_RANGES_NUM0')\npbuf0_isNull = Bool('pbuf0_isNull')\n\nconstraints = [\n  pbuf0 == pbufp0,\n  p0 == pbuf0.p,\n  n0 == p0[0],\n  low0 == 0,\n  bound0 == n0,\n  high0 == low0,\n  incN0 == low0 + 1 - high0,\n  And(And(And(And(Not(from > to), Not(pbuf0_isNull)), Not(low0 < bound0)), Not(high0 < bound0)), n0 + incN0 > Config_MAX_MULTI_BYTE_RANGES_NUM0)\n]\n\nsolver = Solver()\nfor constraint in constraints:\n  solver.add(constraint)\n\nmodels = list(all_smt(solver))\nfor model in models: print(model)",
          "soundSymbolic": true,
          "soundBackwards": false,
          "maybe": true,
          "line": 139,
          "throwingLine": 183,
          "isStatic": true,
          "targetOnlyArguments": false
        },
        {
          "qualifiedSignature": "jdk.nashorn.internal.runtime.regexp.joni.CodeRangeBuffer.addCodeRangeToBuff(jdk.nashorn.internal.runtime.regexp.joni.CodeRangeBuffer, int, int)",
          "exception": "throw new ValueException(ErrorMessages.ERR_TOO_MANY_MULTI_BYTE_RANGES);",
          "pathCojunction": "(!(from > to)) && (pbuf == null) && (!(low < bound)) && (!(high < bound)) && (n + incN > Config.MAX_MULTI_BYTE_RANGES_NUM)",
          "symbolicPathConjunction": "(!(from > to)) && (pbuf == null) && (!(low < bound)) && (!(high < bound)) && (n + incN > Config.MAX_MULTI_BYTE_RANGES_NUM)",
          "backwardsPathConjunction": "(!(from > to)) && (new CodeRangeBuffer() == null) && (!(0 < n)) && (!(low < n)) && (p[0] + low + 1 - 0 > Config.MAX_MULTI_BYTE_RANGES_NUM)",
          "z3Program": "from z3 import *\nfrom z3_all_models import *\n\nfromp0 = Int('fromp0')\ntop0 = Int('top0')\nn0 = Int('n0')\nlow0 = Int('low0')\nbound0 = Int('bound0')\nhigh0 = Int('high0')\nincN0 = Int('incN0')\nConfig_MAX_MULTI_BYTE_RANGES_NUM0 = Int('Config_MAX_MULTI_BYTE_RANGES_NUM0')\npbuf1_isNull = Bool('pbuf1_isNull')\n\nconstraints = [\n  pbuf0 == pbufp0,\n  pbuf1 == new CodeRangeBuffer(),\n  p0 == pbuf1.p,\n  n0 == p0[0],\n  low0 == 0,\n  bound0 == n0,\n  high0 == low0,\n  incN0 == low0 + 1 - high0,\n  And(And(And(And(Not(from > to), pbuf1_isNull), Not(low0 < bound0)), Not(high0 < bound0)), n0 + incN0 > Config_MAX_MULTI_BYTE_RANGES_NUM0)\n]\n\nsolver = Solver()\nfor constraint in constraints:\n  solver.add(constraint)\n\nmodels = list(all_smt(solver))\nfor model in models: print(model)",
          "soundSymbolic": true,
          "soundBackwards": false,
          "maybe": true,
          "line": 139,
          "throwingLine": 183,
          "isStatic": true,
          "targetOnlyArguments": false
        },
        {
          "qualifiedSignature": "jdk.nashorn.internal.runtime.regexp.joni.CodeRangeBuffer.addCodeRangeToBuff(jdk.nashorn.internal.runtime.regexp.joni.CodeRangeBuffer, int, int)",
          "exception": "throw new ValueException(ErrorMessages.ERR_TOO_MANY_MULTI_BYTE_RANGES);",
          "pathCojunction": "(from > to) && (!(pbuf == null)) && (!(low < bound)) && (!(high < bound)) && (n + incN > Config.MAX_MULTI_BYTE_RANGES_NUM)",
          "symbolicPathConjunction": "(from > to) && (!(pbuf == null)) && (!(low < bound)) && (!(high < bound)) && (n + incN > Config.MAX_MULTI_BYTE_RANGES_NUM)",
          "backwardsPathConjunction": "(to > n) && (!(pbufp == null)) && (!(0 < n)) && (!(low < n)) && (p[0] + low + 1 - 0 > Config.MAX_MULTI_BYTE_RANGES_NUM)",
          "z3Program": "from z3 import *\nfrom z3_all_models import *\n\nfromp0 = Int('fromp0')\ntop0 = Int('top0')\nn0 = Int('n0')\nfrom0 = Int('from0')\nto0 = Int('to0')\nn1 = Int('n1')\nlow0 = Int('low0')\nbound0 = Int('bound0')\nhigh0 = Int('high0')\nincN0 = Int('incN0')\nConfig_MAX_MULTI_BYTE_RANGES_NUM0 = Int('Config_MAX_MULTI_BYTE_RANGES_NUM0')\npbuf0_isNull = Bool('pbuf0_isNull')\n\nconstraints = [\n  pbuf0 == pbufp0,\n  n0 == from,\n  from0 == to,\n  to0 == n0,\n  p0 == pbuf0.p,\n  n1 == p0[0],\n  low0 == 0,\n  bound0 == n1,\n  high0 == low0,\n  incN0 == low0 + 1 - high0,\n  And(And(And(And(from0 > to0, Not(pbuf0_isNull)), Not(low0 < bound0)), Not(high0 < bound0)), n1 + incN0 > Config_MAX_MULTI_BYTE_RANGES_NUM0)\n]\n\nsolver = Solver()\nfor constraint in constraints:\n  solver.add(constraint)\n\nmodels = list(all_smt(solver))\nfor model in models: print(model)",
          "soundSymbolic": true,
          "soundBackwards": false,
          "maybe": true,
          "line": 139,
          "throwingLine": 183,
          "isStatic": true,
          "targetOnlyArguments": false
        },
        {
          "qualifiedSignature": "jdk.nashorn.internal.runtime.regexp.joni.CodeRangeBuffer.addCodeRange(jdk.nashorn.internal.runtime.regexp.joni.CodeRangeBuffer, jdk.nashorn.internal.runtime.regexp.joni.ScanEnvironment, int, int)",
          "exception": "throw new ValueException(ErrorMessages.ERR_EMPTY_RANGE_IN_CHAR_CLASS);",
          "pathCojunction": "(from > to) && (!((behavior & ALLOW_EMPTY_RANGE_IN_CC) != 0))",
          "symbolicPathConjunction": "(from > to) && (!(env.syntax.allowEmptyRangeInCC())) && (!(env.syntax.allowEmptyRangeInCC()))",
          "backwardsPathConjunction": "(from > to) && (!((behavior & ALLOW_EMPTY_RANGE_IN_CC) != 0))",
          "z3Program": "from z3 import *\nfrom z3_all_models import *\n\nfrom0 = Int('from0')\nto0 = Int('to0')\nbehavior0 = Int('behavior0')\n\nconstraints = [\n  And(from0 > to0, Not(behavior0 & ALLOW_EMPTY_RANGE_IN_CC != 0))\n]\n\nsolver = Solver()\nfor constraint in constraints:\n  solver.add(constraint)\n\nmodels = list(all_smt(solver))\nfor model in models: print(model)",
          "symPyProgram": "from sympy import Symbol\nfrom sympy import simplify\nfrom sympy.core.relational import Eq, Ne, StrictGreaterThan, StrictLessThan, LessThan, GreaterThan\nfrom sympy.printing import ccode\n\nfrom = Symbol('from', integer=True)\nto = Symbol('to', integer=True)\nbehavior = Symbol('behavior', integer=True)\npath_conjunction = ((StrictGreaterThan(from, to)) & (~((Ne((behavior & ALLOW_EMPTY_RANGE_IN_CC), 0)))))\nprint(ccode(simplify(path_conjunction)))",
          "soundSymbolic": true,
          "soundBackwards": false,
          "maybe": true,
          "line": 218,
          "throwingLine": 223,
          "isStatic": true,
          "targetOnlyArguments": false
        }
      ]
    },
    {
      "path": "/home/yanghengqin/jdk8u_nashorn/src/jdk/nashorn/internal/ir/LexicalContext.java",
      "methods": [
        {
          "qualifiedSignature": "jdk.nashorn.internal.ir.LexicalContext.getFlags(jdk.nashorn.internal.ir.LexicalContextNode)",
          "exception": "throw new AssertionError(\"flag node not on context stack\");",
          "pathCojunction": "(!(i >= 0))",
          "symbolicPathConjunction": "(!(i >= 0))",
          "backwardsPathConjunction": "(!(sp - 1 >= 0))",
          "simplifiedPathConjunction": "sp < 1",
          "z3Inputs": "[i0 = -1, sp0 = 0]\n[i0 = -2, sp0 = -1]\n[i0 = -3, sp0 = -2]\n[i0 = -4, sp0 = -3]\n[i0 = -5, sp0 = -4]\n[i0 = -6, sp0 = -5]\n[i0 = -7, sp0 = -6]\n[i0 = -8, sp0 = -7]\n[i0 = -9, sp0 = -8]\n[i0 = -10, sp0 = -9]\n",
          "z3Program": "from z3 import *\nfrom z3_all_models import *\n\nsp0 = Int('sp0')\ni0 = Int('i0')\n\nconstraints = [\n  i0 == sp0 - 1,\n  Not(i0 >= 0)\n]\n\nsolver = Solver()\nfor constraint in constraints:\n  solver.add(constraint)\n\nmodels = list(all_smt(solver))\nfor model in models: print(model)",
          "symPyProgram": "from sympy import Symbol\nfrom sympy import simplify\nfrom sympy.core.relational import Eq, Ne, StrictGreaterThan, StrictLessThan, LessThan, GreaterThan\nfrom sympy.printing import ccode\n\nsp = Symbol('sp', integer=True)\npath_conjunction = (~((GreaterThan((sp - 1), 0))))\nprint(ccode(simplify(path_conjunction)))",
          "soundSymbolic": true,
          "soundBackwards": true,
          "maybe": false,
          "line": 109,
          "throwingLine": 115,
          "isStatic": false,
          "targetOnlyArguments": false
        },
        {
          "qualifiedSignature": "jdk.nashorn.internal.ir.LexicalContext.getFunctionBody(jdk.nashorn.internal.ir.FunctionNode)",
          "exception": "throw new AssertionError(functionNode.getName() + \" not on context stack\");",
          "pathCojunction": "(!(i >= 0))",
          "symbolicPathConjunction": "(!(i >= 0))",
          "backwardsPathConjunction": "(!(sp - 1 >= 0))",
          "simplifiedPathConjunction": "sp < 1",
          "z3Inputs": "[i0 = -1, sp0 = 0]\n[i0 = -2, sp0 = -1]\n[i0 = -3, sp0 = -2]\n[i0 = -4, sp0 = -3]\n[i0 = -5, sp0 = -4]\n[i0 = -6, sp0 = -5]\n[i0 = -7, sp0 = -6]\n[i0 = -8, sp0 = -7]\n[i0 = -9, sp0 = -8]\n[i0 = -10, sp0 = -9]\n",
          "z3Program": "from z3 import *\nfrom z3_all_models import *\n\nsp0 = Int('sp0')\ni0 = Int('i0')\n\nconstraints = [\n  i0 == sp0 - 1,\n  Not(i0 >= 0)\n]\n\nsolver = Solver()\nfor constraint in constraints:\n  solver.add(constraint)\n\nmodels = list(all_smt(solver))\nfor model in models: print(model)",
          "symPyProgram": "from sympy import Symbol\nfrom sympy import simplify\nfrom sympy.core.relational import Eq, Ne, StrictGreaterThan, StrictLessThan, LessThan, GreaterThan\nfrom sympy.printing import ccode\n\nsp = Symbol('sp', integer=True)\npath_conjunction = (~((GreaterThan((sp - 1), 0))))\nprint(ccode(simplify(path_conjunction)))",
          "soundSymbolic": true,
          "soundBackwards": true,
          "maybe": false,
          "line": 126,
          "throwingLine": 132,
          "isStatic": false,
          "targetOnlyArguments": false
        },
        {
          "qualifiedSignature": "jdk.nashorn.internal.ir.LexicalContext.getAncestorBlocks(jdk.nashorn.internal.ir.Block)",
          "exception": "throw new AssertionError(\"Block is not on the current lexical context stack\");",
          "pathCojunction": "(!(iter.hasNext()))",
          "symbolicPathConjunction": "(getBlocks()) && (!(iter.hasNext()))",
          "backwardsPathConjunction": "(!(new NodeIterator<>(Block.class).hasNext()))",
          "z3Program": "from z3 import *\nfrom z3_all_models import *\n\n\nconstraints = [\n  iter0 == new NodeIterator<>(Block.class),\n  Not(iter0.hasNext())\n]\n\nsolver = Solver()\nfor constraint in constraints:\n  solver.add(constraint)\n\nmodels = list(all_smt(solver))\nfor model in models: print(model)",
          "symPyProgram": "from sympy import Symbol\nfrom sympy import simplify\nfrom sympy.core.relational import Eq, Ne, StrictGreaterThan, StrictLessThan, LessThan, GreaterThan\nfrom sympy.printing import ccode\n\nBUG_IN_SIMPLIFICATION\npath_conjunction = (~(new NodeIterator<>(Block.class)_hasNext))\nprint(ccode(simplify(path_conjunction)))",
          "soundSymbolic": false,
          "soundBackwards": true,
          "maybe": true,
          "line": 337,
          "throwingLine": 345,
          "isStatic": false,
          "targetOnlyArguments": false
        },
        {
          "qualifiedSignature": "jdk.nashorn.internal.ir.LexicalContext.getAncestorBlocks(jdk.nashorn.internal.ir.Block)",
          "exception": "throw new AssertionError(\"Block is not on the current lexical context stack\");",
          "pathCojunction": "(iter.hasNext()) && (!(block == b)) && (!(iter.hasNext()))",
          "symbolicPathConjunction": "(getBlocks()) && (iter.hasNext()) && (!(block == b)) && (!(iter.hasNext()))",
          "backwardsPathConjunction": "(new NodeIterator<>(Block.class).hasNext()) && (!(block == new NodeIterator<>(Block.class).next())) && (!(new NodeIterator<>(Block.class).hasNext()))",
          "z3Program": "from z3 import *\nfrom z3_all_models import *\n\n\nconstraints = [\n  iter0 == new NodeIterator<>(Block.class),\n  b0 == iter0.next(),\n  And(And(iter0.hasNext(), Not(block0 == b0)), Not(iter0.hasNext()))\n]\n\nsolver = Solver()\nfor constraint in constraints:\n  solver.add(constraint)\n\nmodels = list(all_smt(solver))\nfor model in models: print(model)",
          "symPyProgram": "from sympy import Symbol\nfrom sympy import simplify\nfrom sympy.core.relational import Eq, Ne, StrictGreaterThan, StrictLessThan, LessThan, GreaterThan\nfrom sympy.printing import ccode\n\nblock = Symbol('block')\nBUG_IN_SIMPLIFICATION\npath_conjunction = ((new NodeIterator<>(Block.class)_hasNext & (~((Eq(block, new NodeIterator<>(Block.class)_next))))) & (~(new NodeIterator<>(Block.class)_hasNext)))\nprint(ccode(simplify(path_conjunction)))",
          "soundSymbolic": false,
          "soundBackwards": true,
          "maybe": true,
          "line": 337,
          "throwingLine": 345,
          "isStatic": false,
          "targetOnlyArguments": false
        },
        {
          "qualifiedSignature": "jdk.nashorn.internal.ir.LexicalContext.getBlocks(jdk.nashorn.internal.ir.Block)",
          "exception": "throw new AssertionError(\"Block is not on the current lexical context stack\");",
          "pathCojunction": "(new NodeIterator<>(Block.class).hasNext()) && (!(block == iter.next())) && (!(new NodeIterator<>(Block.class).hasNext()))",
          "symbolicPathConjunction": "(getAncestorBlocks(block))",
          "backwardsPathConjunction": "(new NodeIterator<>(Block.class).hasNext()) && (!(block == new NodeIterator<>(Block.class).next())) && (!(new NodeIterator<>(Block.class).hasNext()))",
          "z3Program": "from z3 import *\nfrom z3_all_models import *\n\n\nconstraints = [\n  iter0 == new NodeIterator<>(Block.class),\n  And(And(new NodeIterator<>(Block.class).hasNext(), Not(block0 == iter0.next())), Not(new NodeIterator<>(Block.class).hasNext()))\n]\n\nsolver = Solver()\nfor constraint in constraints:\n  solver.add(constraint)\n\nmodels = list(all_smt(solver))\nfor model in models: print(model)",
          "symPyProgram": "from sympy import Symbol\nfrom sympy import simplify\nfrom sympy.core.relational import Eq, Ne, StrictGreaterThan, StrictLessThan, LessThan, GreaterThan\nfrom sympy.printing import ccode\n\nblock = Symbol('block')\nBUG_IN_SIMPLIFICATION\npath_conjunction = ((new NodeIterator<>(Block.class)_hasNext & (~((Eq(block, new NodeIterator<>(Block.class)_next))))) & (~(new NodeIterator<>(Block.class)_hasNext)))\nprint(ccode(simplify(path_conjunction)))",
          "soundSymbolic": true,
          "soundBackwards": true,
          "maybe": true,
          "line": 356,
          "throwingLine": 357,
          "isStatic": false,
          "targetOnlyArguments": false
        },
        {
          "qualifiedSignature": "jdk.nashorn.internal.ir.LexicalContext.getBlocks(jdk.nashorn.internal.ir.Block)",
          "exception": "throw new AssertionError(\"Block is not on the current lexical context stack\");",
          "pathCojunction": "(!(new NodeIterator<>(Block.class).hasNext()))",
          "symbolicPathConjunction": "(getAncestorBlocks(block))",
          "backwardsPathConjunction": "(!(new NodeIterator<>(Block.class).hasNext()))",
          "z3Program": "from z3 import *\nfrom z3_all_models import *\n\n\nconstraints = [\n  Not(new NodeIterator<>(Block.class).hasNext())\n]\n\nsolver = Solver()\nfor constraint in constraints:\n  solver.add(constraint)\n\nmodels = list(all_smt(solver))\nfor model in models: print(model)",
          "symPyProgram": "from sympy import Symbol\nfrom sympy import simplify\nfrom sympy.core.relational import Eq, Ne, StrictGreaterThan, StrictLessThan, LessThan, GreaterThan\nfrom sympy.printing import ccode\n\nBUG_IN_SIMPLIFICATION\npath_conjunction = (~(new NodeIterator<>(Block.class)_hasNext))\nprint(ccode(simplify(path_conjunction)))",
          "soundSymbolic": true,
          "soundBackwards": true,
          "maybe": true,
          "line": 356,
          "throwingLine": 357,
          "isStatic": false,
          "targetOnlyArguments": true
        },
        {
          "qualifiedSignature": "jdk.nashorn.internal.ir.LexicalContext.Anonymous-ec0a6ed7-d0bc-4dc7-93bf-6d09c25f0563.remove()",
          "exception": "throw new UnsupportedOperationException();",
          "pathCojunction": "true",
          "backwardsPathConjunction": "true",
          "simplifiedPathConjunction": "true",
          "soundSymbolic": false,
          "soundBackwards": true,
          "maybe": false,
          "line": 373,
          "throwingLine": 374,
          "isStatic": false,
          "targetOnlyArguments": true
        },
        {
          "qualifiedSignature": "jdk.nashorn.internal.ir.LexicalContext.getDefiningBlock(jdk.nashorn.internal.ir.Symbol)",
          "exception": "throw new AssertionError(\"Couldn't find symbol \" + name + \" in the context\");",
          "pathCojunction": "(!(it.hasNext()))",
          "symbolicPathConjunction": "(symbol.getName()) && (!(it.hasNext()))",
          "backwardsPathConjunction": "(!(it.hasNext()))",
          "simplifiedPathConjunction": "!it.hasNext()",
          "z3Program": "from z3 import *\nfrom z3_all_models import *\n\nname1 = String('name1')\n\nconstraints = [\n  name1 == name0,\n  Not(it.hasNext())\n]\n\nsolver = Solver()\nfor constraint in constraints:\n  solver.add(constraint)\n\nmodels = list(all_smt(solver))\nfor model in models: print(model)",
          "symPyProgram": "from sympy import Symbol\nfrom sympy import simplify\nfrom sympy.core.relational import Eq, Ne, StrictGreaterThan, StrictLessThan, LessThan, GreaterThan\nfrom sympy.printing import ccode\n\nit_hasNext = Symbol('it_hasNext')\npath_conjunction = (~(it_hasNext))\nprint(ccode(simplify(path_conjunction)))",
          "soundSymbolic": false,
          "soundBackwards": false,
          "maybe": true,
          "line": 430,
          "throwingLine": 438,
          "isStatic": false,
          "targetOnlyArguments": false
        },
        {
          "qualifiedSignature": "jdk.nashorn.internal.ir.LexicalContext.getDefiningBlock(jdk.nashorn.internal.ir.Symbol)",
          "exception": "throw new AssertionError(\"Couldn't find symbol \" + name + \" in the context\");",
          "pathCojunction": "(it.hasNext()) && (!(symbols.get(name) == symbol))",
          "symbolicPathConjunction": "(symbol.getName()) && (it.hasNext()) && (!(next.getExistingSymbol(name))) && (!(next.getExistingSymbol(name) == symbol))",
          "backwardsPathConjunction": "(it.hasNext()) && (!(symbols.get(name) == symbol))",
          "simplifiedPathConjunction": "it.hasNext() && symbol != symbols.get(name)",
          "z3Program": "from z3 import *\nfrom z3_all_models import *\n\nname1 = String('name1')\n\nconstraints = [\n  name1 == name0,\n  next0 == it.next(),\n  And(it.hasNext(), Not(symbols0.get(name1) == symbol0))\n]\n\nsolver = Solver()\nfor constraint in constraints:\n  solver.add(constraint)\n\nmodels = list(all_smt(solver))\nfor model in models: print(model)",
          "symPyProgram": "from sympy import Symbol\nfrom sympy import simplify\nfrom sympy.core.relational import Eq, Ne, StrictGreaterThan, StrictLessThan, LessThan, GreaterThan\nfrom sympy.printing import ccode\n\nsymbol = Symbol('symbol')\nname = Symbol('name')\nsymbols = Symbol('symbols')\nit_hasNext = Symbol('it_hasNext')\nsymbols_get = Symbol('symbols_get')\npath_conjunction = (it_hasNext & (~((Eq(symbols_get, symbol)))))\nprint(ccode(simplify(path_conjunction)))",
          "soundSymbolic": false,
          "soundBackwards": false,
          "maybe": true,
          "line": 430,
          "throwingLine": 438,
          "isStatic": false,
          "targetOnlyArguments": false
        },
        {
          "qualifiedSignature": "jdk.nashorn.internal.ir.LexicalContext.getDefiningFunction(jdk.nashorn.internal.ir.Symbol)",
          "exception": "throw new AssertionError(\"Couldn't find symbol \" + name + \" in the context\");",
          "pathCojunction": "(!(iter.hasNext()))",
          "symbolicPathConjunction": "(symbol.getName()) && (!(iter.hasNext()))",
          "backwardsPathConjunction": "(!(iter.hasNext()))",
          "simplifiedPathConjunction": "!iter.hasNext()",
          "z3Program": "from z3 import *\nfrom z3_all_models import *\n\nname1 = String('name1')\n\nconstraints = [\n  name1 == name0,\n  Not(iter.hasNext())\n]\n\nsolver = Solver()\nfor constraint in constraints:\n  solver.add(constraint)\n\nmodels = list(all_smt(solver))\nfor model in models: print(model)",
          "symPyProgram": "from sympy import Symbol\nfrom sympy import simplify\nfrom sympy.core.relational import Eq, Ne, StrictGreaterThan, StrictLessThan, LessThan, GreaterThan\nfrom sympy.printing import ccode\n\niter_hasNext = Symbol('iter_hasNext')\npath_conjunction = (~(iter_hasNext))\nprint(ccode(simplify(path_conjunction)))",
          "soundSymbolic": false,
          "soundBackwards": false,
          "maybe": true,
          "line": 449,
          "throwingLine": 463,
          "isStatic": false,
          "targetOnlyArguments": false
        },
        {
          "qualifiedSignature": "jdk.nashorn.internal.ir.LexicalContext.NodeIterator.next()",
          "exception": "throw new NoSuchElementException();",
          "pathCojunction": "(next == null)",
          "symbolicPathConjunction": "(next == null)",
          "backwardsPathConjunction": "(next == null)",
          "simplifiedPathConjunction": "next == null",
          "z3Inputs": "[next0_isNull = True]\n",
          "z3Program": "from z3 import *\nfrom z3_all_models import *\n\nnext0_isNull = Bool('next0_isNull')\n\nconstraints = [\n  next0_isNull\n]\n\nsolver = Solver()\nfor constraint in constraints:\n  solver.add(constraint)\n\nmodels = list(all_smt(solver))\nfor model in models: print(model)",
          "symPyProgram": "from sympy import Symbol\nfrom sympy import simplify\nfrom sympy.core.relational import Eq, Ne, StrictGreaterThan, StrictLessThan, LessThan, GreaterThan\nfrom sympy.printing import ccode\n\nnext = Symbol('next')\nnull = Symbol('null')\npath_conjunction = (Eq(next, null))\nprint(ccode(simplify(path_conjunction)))",
          "soundSymbolic": true,
          "soundBackwards": true,
          "maybe": false,
          "line": 759,
          "throwingLine": 761,
          "isStatic": false,
          "targetOnlyArguments": false
        },
        {
          "qualifiedSignature": "jdk.nashorn.internal.ir.LexicalContext.NodeIterator.remove()",
          "exception": "throw new UnsupportedOperationException();",
          "pathCojunction": "true",
          "backwardsPathConjunction": "true",
          "simplifiedPathConjunction": "true",
          "soundSymbolic": false,
          "soundBackwards": true,
          "maybe": false,
          "line": 784,
          "throwingLine": 785,
          "isStatic": false,
          "targetOnlyArguments": true
        }
      ]
    },
    {
      "path": "/home/yanghengqin/jdk8u_nashorn/src/jdk/nashorn/internal/runtime/AccessorProperty.java",
      "methods": [
        {
          "qualifiedSignature": "jdk.nashorn.internal.runtime.AccessorProperty.getOptimisticGetter(java.lang.Class<?>, int)",
          "exception": "throw ECMAErrors.referenceError(\"not.defined\", getKey());",
          "pathCojunction": "(!(objectGetter == null)) && ((flags & NEEDS_DECLARATION) != 0)",
          "symbolicPathConjunction": "(!(objectGetter == null)) && (!(getFlags()) && ((getFlags() & NEEDS_DECLARATION) != 0))",
          "backwardsPathConjunction": "(!(objectGetter == null)) && ((flags & NEEDS_DECLARATION) != 0)",
          "z3Program": "from z3 import *\nfrom z3_all_models import *\n\nprogramPoint0 = Int('programPoint0')\nflags0 = Int('flags0')\nobjectGetter0_isNull = Bool('objectGetter0_isNull')\n\nconstraints = [\n  And(Not(objectGetter0_isNull), flags0 & NEEDS_DECLARATION != 0)\n]\n\nsolver = Solver()\nfor constraint in constraints:\n  solver.add(constraint)\n\nmodels = list(all_smt(solver))\nfor model in models: print(model)",
          "symPyProgram": "from sympy import Symbol\nfrom sympy import simplify\nfrom sympy.core.relational import Eq, Ne, StrictGreaterThan, StrictLessThan, LessThan, GreaterThan\nfrom sympy.printing import ccode\n\nobjectGetter = Symbol('objectGetter')\nflags = Symbol('flags', integer=True)\nnull = Symbol('null')\npath_conjunction = ((~((Eq(objectGetter, null)))) & (Ne((flags & NEEDS_DECLARATION), 0)))\nprint(ccode(simplify(path_conjunction)))",
          "soundSymbolic": true,
          "soundBackwards": false,
          "maybe": true,
          "line": 532,
          "throwingLine": 538,
          "isStatic": false,
          "targetOnlyArguments": false
        }
      ]
    },
    {
      "path": "/home/yanghengqin/jdk8u_nashorn/src/jdk/nashorn/internal/runtime/OptimisticReturnFilters.java",
      "methods": [
        {
          "qualifiedSignature": "jdk.nashorn.internal.runtime.OptimisticReturnFilters.ensureInt(java.lang.Object, int)",
          "exception": "throw UnwarrantedOptimismException.createNarrowest(arg, programPoint);",
          "pathCojunction": "(!(isPrimitiveNumberWrapper(arg)))",
          "symbolicPathConjunction": "(!(isPrimitiveNumberWrapper(arg)))",
          "backwardsPathConjunction": "(!(isPrimitiveNumberWrapper(arg)))",
          "simplifiedPathConjunction": "!isPrimitiveNumberWrapper(arg)",
          "z3Program": "from z3 import *\nfrom z3_all_models import *\n\nprogramPoint0 = Int('programPoint0')\n\nconstraints = [\n  Not(isPrimitiveNumberWrapper(arg0))\n]\n\nsolver = Solver()\nfor constraint in constraints:\n  solver.add(constraint)\n\nmodels = list(all_smt(solver))\nfor model in models: print(model)",
          "symPyProgram": "from sympy import Symbol\nfrom sympy import simplify\nfrom sympy.core.relational import Eq, Ne, StrictGreaterThan, StrictLessThan, LessThan, GreaterThan\nfrom sympy.printing import ccode\n\narg = Symbol('arg')\n_isPrimitiveNumberWrapper = Symbol('_isPrimitiveNumberWrapper')\npath_conjunction = (~(_isPrimitiveNumberWrapper))\nprint(ccode(simplify(path_conjunction)))",
          "soundSymbolic": false,
          "soundBackwards": true,
          "maybe": true,
          "line": 193,
          "throwingLine": 203,
          "isStatic": true,
          "targetOnlyArguments": true
        },
        {
          "qualifiedSignature": "jdk.nashorn.internal.runtime.OptimisticReturnFilters.ensureInt(java.lang.Object, int)",
          "exception": "throw UnwarrantedOptimismException.createNarrowest(arg, programPoint);",
          "pathCojunction": "(isPrimitiveNumberWrapper(arg)) && (!(JSType.isStrictlyRepresentableAsInt(d)))",
          "symbolicPathConjunction": "(isPrimitiveNumberWrapper(arg)) && (!(JSType.isStrictlyRepresentableAsInt(d)))",
          "backwardsPathConjunction": "(isPrimitiveNumberWrapper(arg)) && (!(JSType.isStrictlyRepresentableAsInt(((Number) arg).doubleValue())))",
          "z3Program": "from z3 import *\nfrom z3_all_models import *\n\nprogramPoint0 = Int('programPoint0')\nd0 = Real('d0')\n\nconstraints = [\n  d0 == ((Number) arg0).doubleValue(),\n  And(isPrimitiveNumberWrapper(arg0), Not(JSType.isStrictlyRepresentableAsInt(d0)))\n]\n\nsolver = Solver()\nfor constraint in constraints:\n  solver.add(constraint)\n\nmodels = list(all_smt(solver))\nfor model in models: print(model)",
          "symPyProgram": "from sympy import Symbol\nfrom sympy import simplify\nfrom sympy.core.relational import Eq, Ne, StrictGreaterThan, StrictLessThan, LessThan, GreaterThan\nfrom sympy.printing import ccode\n\narg = Symbol('arg')\n_isPrimitiveNumberWrapper = Symbol('_isPrimitiveNumberWrapper')\nJSType_isStrictlyRepresentableAsInt = Symbol('JSType_isStrictlyRepresentableAsInt')\n((Number) arg)_doubleValue = Symbol('((Number) arg)_doubleValue')\npath_conjunction = (_isPrimitiveNumberWrapper & (~(JSType_isStrictlyRepresentableAsInt)))\nprint(ccode(simplify(path_conjunction)))",
          "soundSymbolic": false,
          "soundBackwards": false,
          "maybe": true,
          "line": 193,
          "throwingLine": 203,
          "isStatic": true,
          "targetOnlyArguments": false
        }
      ]
    },
    {
      "path": "/home/yanghengqin/jdk8u_nashorn/src/jdk/nashorn/internal/runtime/arrays/NonExtensibleArrayFilter.java",
      "methods": [
        {
          "qualifiedSignature": "jdk.nashorn.internal.runtime.arrays.NonExtensibleArrayFilter.set(int, java.lang.Object, boolean)",
          "exception": "throw typeError(Global.instance(), \"object.non.extensible\", String.valueOf(index), ScriptRuntime.safeToString(this));",
          "pathCojunction": "(!(underlying.has(index))) && (!(!strict))",
          "symbolicPathConjunction": "(!(has(index))) && (!(has(index))) && (!(!strict))",
          "backwardsPathConjunction": "(!(underlying.has(index))) && (!(!strict))",
          "simplifiedPathConjunction": "strict && !underlying.has(index)",
          "z3Program": "from z3 import *\nfrom z3_all_models import *\n\nindex0 = Int('index0')\nstrict0 = Bool('strict0')\n\nconstraints = [\n  And(Not(underlying0.has(index0)), Not(Not(strict0)))\n]\n\nsolver = Solver()\nfor constraint in constraints:\n  solver.add(constraint)\n\nmodels = list(all_smt(solver))\nfor model in models: print(model)",
          "symPyProgram": "from sympy import Symbol\nfrom sympy import simplify\nfrom sympy.core.relational import Eq, Ne, StrictGreaterThan, StrictLessThan, LessThan, GreaterThan\nfrom sympy.printing import ccode\n\nindex = Symbol('index', integer=True)\nstrict = Symbol('strict')\nunderlying = Symbol('underlying')\nunderlying_has = Symbol('underlying_has')\npath_conjunction = ((~(underlying_has)) & (~((~(strict)))))\nprint(ccode(simplify(path_conjunction)))",
          "soundSymbolic": true,
          "soundBackwards": false,
          "maybe": true,
          "line": 38,
          "throwingLine": 42,
          "isStatic": false,
          "targetOnlyArguments": false
        },
        {
          "qualifiedSignature": "jdk.nashorn.internal.runtime.arrays.NonExtensibleArrayFilter.set(int, int, boolean)",
          "exception": "throw typeError(Global.instance(), \"object.non.extensible\", String.valueOf(index), ScriptRuntime.safeToString(this));",
          "pathCojunction": "(!(underlying.has(index))) && (!(!strict))",
          "symbolicPathConjunction": "(!(has(index))) && (!(has(index))) && (!(!strict))",
          "backwardsPathConjunction": "(!(underlying.has(index))) && (!(!strict))",
          "simplifiedPathConjunction": "strict && !underlying.has(index)",
          "z3Program": "from z3 import *\nfrom z3_all_models import *\n\nindex0 = Int('index0')\nvalue0 = Int('value0')\nstrict0 = Bool('strict0')\n\nconstraints = [\n  And(Not(underlying0.has(index0)), Not(Not(strict0)))\n]\n\nsolver = Solver()\nfor constraint in constraints:\n  solver.add(constraint)\n\nmodels = list(all_smt(solver))\nfor model in models: print(model)",
          "symPyProgram": "from sympy import Symbol\nfrom sympy import simplify\nfrom sympy.core.relational import Eq, Ne, StrictGreaterThan, StrictLessThan, LessThan, GreaterThan\nfrom sympy.printing import ccode\n\nindex = Symbol('index', integer=True)\nstrict = Symbol('strict')\nunderlying = Symbol('underlying')\nunderlying_has = Symbol('underlying_has')\npath_conjunction = ((~(underlying_has)) & (~((~(strict)))))\nprint(ccode(simplify(path_conjunction)))",
          "soundSymbolic": true,
          "soundBackwards": false,
          "maybe": true,
          "line": 46,
          "throwingLine": 50,
          "isStatic": false,
          "targetOnlyArguments": false
        },
        {
          "qualifiedSignature": "jdk.nashorn.internal.runtime.arrays.NonExtensibleArrayFilter.set(int, double, boolean)",
          "exception": "throw typeError(Global.instance(), \"object.non.extensible\", String.valueOf(index), ScriptRuntime.safeToString(this));",
          "pathCojunction": "(!(underlying.has(index))) && (!(!strict))",
          "symbolicPathConjunction": "(!(has(index))) && (!(has(index))) && (!(!strict))",
          "backwardsPathConjunction": "(!(underlying.has(index))) && (!(!strict))",
          "simplifiedPathConjunction": "strict && !underlying.has(index)",
          "z3Program": "from z3 import *\nfrom z3_all_models import *\n\nindex0 = Int('index0')\nvalue0 = Real('value0')\nstrict0 = Bool('strict0')\n\nconstraints = [\n  And(Not(underlying0.has(index0)), Not(Not(strict0)))\n]\n\nsolver = Solver()\nfor constraint in constraints:\n  solver.add(constraint)\n\nmodels = list(all_smt(solver))\nfor model in models: print(model)",
          "symPyProgram": "from sympy import Symbol\nfrom sympy import simplify\nfrom sympy.core.relational import Eq, Ne, StrictGreaterThan, StrictLessThan, LessThan, GreaterThan\nfrom sympy.printing import ccode\n\nindex = Symbol('index', integer=True)\nstrict = Symbol('strict')\nunderlying = Symbol('underlying')\nunderlying_has = Symbol('underlying_has')\npath_conjunction = ((~(underlying_has)) & (~((~(strict)))))\nprint(ccode(simplify(path_conjunction)))",
          "soundSymbolic": true,
          "soundBackwards": false,
          "maybe": true,
          "line": 54,
          "throwingLine": 58,
          "isStatic": false,
          "targetOnlyArguments": false
        }
      ]
    },
    {
      "path": "/home/yanghengqin/jdk8u_nashorn/src/jdk/nashorn/internal/runtime/arrays/ArrayLikeIterator.java",
      "methods": [
        {
          "qualifiedSignature": "jdk.nashorn.internal.runtime.arrays.ArrayLikeIterator.remove()",
          "exception": "throw new UnsupportedOperationException(\"remove\");",
          "pathCojunction": "true",
          "backwardsPathConjunction": "true",
          "simplifiedPathConjunction": "true",
          "soundSymbolic": false,
          "soundBackwards": true,
          "maybe": false,
          "line": 83,
          "throwingLine": 84,
          "isStatic": false,
          "targetOnlyArguments": true
        }
      ]
    }
  ]
}