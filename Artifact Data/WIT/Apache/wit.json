{
  "path": "/home/yanghengqin/commons-io-commons-io-2.6/",
  "classes": [
    {
      "path": "/home/yanghengqin/commons-io-commons-io-2.6/src/main/java/org/apache/commons/io/input/CharSequenceReader.java",
      "methods": [
        {
          "qualifiedSignature": "org.apache.commons.io.input.CharSequenceReader.read(char[], int, int)",
          "exception": "throw new NullPointerException(\"Character array is missing\");",
          "pathCojunction": "(!(idx >= charSequence.length())) && (array == null)",
          "symbolicPathConjunction": "(!(idx >= charSequence.length())) && (array == null)",
          "backwardsPathConjunction": "(!(idx >= charSequence.length())) && (array == null)",
          "simplifiedPathConjunction": "array == null && charSequence.length() > idx",
          "z3Program": "from z3 import *\nfrom z3_all_models import *\n\noffset0 = Int('offset0')\nlength0 = Int('length0')\nidx0 = Int('idx0')\narray0_isNull = Bool('array0_isNull')\n\nconstraints = [\n  And(Not(idx0 >= charSequence0.length()), array0_isNull)\n]\n\nsolver = Solver()\nfor constraint in constraints:\n  solver.add(constraint)\n\nmodels = list(all_smt(solver))\nfor model in models: print(model)",
          "symPyProgram": "from sympy import Symbol\nfrom sympy import simplify\nfrom sympy.core.relational import Eq, Ne, StrictGreaterThan, StrictLessThan, LessThan, GreaterThan\nfrom sympy.printing import ccode\n\narray = Symbol('array')\nidx = Symbol('idx', integer=True)\ncharSequence = Symbol('charSequence')\ncharSequence_length = Symbol('charSequence_length')\nnull = Symbol('null')\npath_conjunction = ((~((GreaterThan(idx, charSequence_length)))) & (Eq(array, null)))\nprint(ccode(simplify(path_conjunction)))",
          "soundSymbolic": false,
          "soundBackwards": true,
          "maybe": true,
          "line": 102,
          "throwingLine": 107,
          "isStatic": false,
          "targetOnlyArguments": false
        },
        {
          "qualifiedSignature": "org.apache.commons.io.input.CharSequenceReader.read(char[], int, int)",
          "exception": "throw new IndexOutOfBoundsException(\"Array Size=\" + array.length + \", offset=\" + offset + \", length=\" + length);",
          "pathCojunction": "(!(idx >= charSequence.length())) && (!(array == null)) && (length < 0 || offset < 0 || offset + length > array.length)",
          "symbolicPathConjunction": "(!(idx >= charSequence.length())) && (!(array == null)) && (length < 0 || offset < 0 || offset + length > array.length)",
          "backwardsPathConjunction": "(!(idx >= charSequence.length())) && (!(array == null)) && (length < 0 || offset < 0 || offset + length > array.length)",
          "simplifiedPathConjunction": "(array.length < length + offset || length < 0 || offset < 0) && charSequence.length() > idx && array != null",
          "z3Program": "from z3 import *\nfrom z3_all_models import *\n\noffset0 = Int('offset0')\nlength0 = Int('length0')\nidx0 = Int('idx0')\narray0_isNull = Bool('array0_isNull')\narray0_length = Int('array0_length')\n\nconstraints = [\n  array0_length >= 0, # implicit\n  And(And(Not(idx0 >= charSequence0.length()), Not(array0_isNull)), Or(Or(length0 < 0, offset0 < 0), offset0 + length0 > array0_length))\n]\n\nsolver = Solver()\nfor constraint in constraints:\n  solver.add(constraint)\n\nmodels = list(all_smt(solver))\nfor model in models: print(model)",
          "symPyProgram": "from sympy import Symbol\nfrom sympy import simplify\nfrom sympy.core.relational import Eq, Ne, StrictGreaterThan, StrictLessThan, LessThan, GreaterThan\nfrom sympy.printing import ccode\n\narray = Symbol('array')\noffset = Symbol('offset', integer=True)\nlength = Symbol('length', integer=True)\nidx = Symbol('idx', integer=True)\ncharSequence = Symbol('charSequence')\narray_length = Symbol('array_length', integer=True)\ncharSequence_length = Symbol('charSequence_length')\nnull = Symbol('null')\npath_conjunction = (((~((GreaterThan(idx, charSequence_length)))) & (~((Eq(array, null))))) & (((StrictLessThan(length, 0)) | (StrictLessThan(offset, 0))) | (StrictGreaterThan((offset + length), array_length))))\nprint(ccode(simplify(path_conjunction)))",
          "soundSymbolic": false,
          "soundBackwards": true,
          "maybe": true,
          "line": 102,
          "throwingLine": 110,
          "isStatic": false,
          "targetOnlyArguments": false
        },
        {
          "qualifiedSignature": "org.apache.commons.io.input.CharSequenceReader.skip(long)",
          "exception": "throw new IllegalArgumentException(\"Number of characters to skip is less than zero: \" + n);",
          "pathCojunction": "(n < 0)",
          "symbolicPathConjunction": "(n < 0)",
          "backwardsPathConjunction": "(n < 0)",
          "simplifiedPathConjunction": "n < 0",
          "z3Inputs": "[n0 = -9223372036854775808]\n[n0 = -1]\n[n0 = -2]\n[n0 = -3]\n[n0 = -4]\n[n0 = -5]\n[n0 = -6]\n[n0 = -7]\n[n0 = -8]\n[n0 = -9]\n",
          "z3Program": "from z3 import *\nfrom z3_all_models import *\n\nn0 = Int('n0')\n\nconstraints = [\n  n0 >= -9223372036854775808, n0 <= 9223372036854775807, # implicit\n  n0 < 0\n]\n\nsolver = Solver()\nfor constraint in constraints:\n  solver.add(constraint)\n\nmodels = list(all_smt(solver))\nfor model in models: print(model)",
          "symPyProgram": "from sympy import Symbol\nfrom sympy import simplify\nfrom sympy.core.relational import Eq, Ne, StrictGreaterThan, StrictLessThan, LessThan, GreaterThan\nfrom sympy.printing import ccode\n\nn = Symbol('n')\npath_conjunction = (StrictLessThan(n, 0))\nprint(ccode(simplify(path_conjunction)))",
          "soundSymbolic": true,
          "soundBackwards": true,
          "maybe": false,
          "line": 141,
          "throwingLine": 143,
          "isStatic": false,
          "targetOnlyArguments": true
        }
      ]
    },
    {
      "path": "/home/yanghengqin/commons-io-commons-io-2.6/src/main/java/org/apache/commons/io/FileCleaningTracker.java",
      "methods": [
        {
          "qualifiedSignature": "org.apache.commons.io.FileCleaningTracker.track(java.io.File, java.lang.Object)",
          "exception": "throw new IllegalStateException(\"No new trackers can be added once exitWhenFinished() is called\")",
          "pathCojunction": "(!(file == null)) && (exitWhenFinished)",
          "symbolicPathConjunction": "(track(file, marker, null))",
          "backwardsPathConjunction": "(!(file == null)) && (exitWhenFinished)",
          "simplifiedPathConjunction": "exitWhenFinished && file != null",
          "z3Inputs": "[file0_isNull = False, exitWhenFinished0 = True]\n",
          "z3Program": "from z3 import *\nfrom z3_all_models import *\n\nexitWhenFinished0 = Bool('exitWhenFinished0')\nfile0_isNull = Bool('file0_isNull')\n\nconstraints = [\n  And(Not(file0_isNull), exitWhenFinished0)\n]\n\nsolver = Solver()\nfor constraint in constraints:\n  solver.add(constraint)\n\nmodels = list(all_smt(solver))\nfor model in models: print(model)",
          "symPyProgram": "from sympy import Symbol\nfrom sympy import simplify\nfrom sympy.core.relational import Eq, Ne, StrictGreaterThan, StrictLessThan, LessThan, GreaterThan\nfrom sympy.printing import ccode\n\nfile = Symbol('file')\nexitWhenFinished = Symbol('exitWhenFinished')\nnull = Symbol('null')\npath_conjunction = ((~((Eq(file, null)))) & exitWhenFinished)\nprint(ccode(simplify(path_conjunction)))",
          "soundSymbolic": true,
          "soundBackwards": true,
          "maybe": false,
          "line": 78,
          "throwingLine": 79,
          "isStatic": false,
          "targetOnlyArguments": false
        },
        {
          "qualifiedSignature": "org.apache.commons.io.FileCleaningTracker.track(java.io.File, java.lang.Object)",
          "exception": "throw new NullPointerException(\"The file must not be null\")",
          "pathCojunction": "(file == null)",
          "symbolicPathConjunction": "(track(file, marker, null))",
          "backwardsPathConjunction": "(file == null)",
          "simplifiedPathConjunction": "file == null",
          "z3Inputs": "[file0_isNull = True]\n",
          "z3Program": "from z3 import *\nfrom z3_all_models import *\n\nfile0_isNull = Bool('file0_isNull')\n\nconstraints = [\n  file0_isNull\n]\n\nsolver = Solver()\nfor constraint in constraints:\n  solver.add(constraint)\n\nmodels = list(all_smt(solver))\nfor model in models: print(model)",
          "symPyProgram": "from sympy import Symbol\nfrom sympy import simplify\nfrom sympy.core.relational import Eq, Ne, StrictGreaterThan, StrictLessThan, LessThan, GreaterThan\nfrom sympy.printing import ccode\n\nfile = Symbol('file')\nnull = Symbol('null')\npath_conjunction = (Eq(file, null))\nprint(ccode(simplify(path_conjunction)))",
          "soundSymbolic": true,
          "soundBackwards": true,
          "maybe": false,
          "line": 78,
          "throwingLine": 79,
          "isStatic": false,
          "targetOnlyArguments": true
        },
        {
          "qualifiedSignature": "org.apache.commons.io.FileCleaningTracker.track(java.io.File, java.lang.Object, org.apache.commons.io.FileDeleteStrategy)",
          "exception": "throw new IllegalStateException(\"No new trackers can be added once exitWhenFinished() is called\")",
          "pathCojunction": "(!(file == null)) && (exitWhenFinished)",
          "symbolicPathConjunction": "(!(file == null)) && (!(exitWhenFinished))",
          "backwardsPathConjunction": "(!(file == null)) && (exitWhenFinished)",
          "simplifiedPathConjunction": "exitWhenFinished && file != null",
          "z3Inputs": "[file0_isNull = False, exitWhenFinished0 = True]\n",
          "z3Program": "from z3 import *\nfrom z3_all_models import *\n\nexitWhenFinished0 = Bool('exitWhenFinished0')\nfile0_isNull = Bool('file0_isNull')\n\nconstraints = [\n  And(Not(file0_isNull), exitWhenFinished0)\n]\n\nsolver = Solver()\nfor constraint in constraints:\n  solver.add(constraint)\n\nmodels = list(all_smt(solver))\nfor model in models: print(model)",
          "symPyProgram": "from sympy import Symbol\nfrom sympy import simplify\nfrom sympy.core.relational import Eq, Ne, StrictGreaterThan, StrictLessThan, LessThan, GreaterThan\nfrom sympy.printing import ccode\n\nfile = Symbol('file')\nexitWhenFinished = Symbol('exitWhenFinished')\nnull = Symbol('null')\npath_conjunction = ((~((Eq(file, null)))) & exitWhenFinished)\nprint(ccode(simplify(path_conjunction)))",
          "soundSymbolic": true,
          "soundBackwards": true,
          "maybe": false,
          "line": 92,
          "throwingLine": 96,
          "isStatic": false,
          "targetOnlyArguments": false
        },
        {
          "qualifiedSignature": "org.apache.commons.io.FileCleaningTracker.track(java.io.File, java.lang.Object, org.apache.commons.io.FileDeleteStrategy)",
          "exception": "throw new NullPointerException(\"The file must not be null\");",
          "pathCojunction": "(file == null)",
          "symbolicPathConjunction": "(file == null)",
          "backwardsPathConjunction": "(file == null)",
          "simplifiedPathConjunction": "file == null",
          "z3Inputs": "[file0_isNull = True]\n",
          "z3Program": "from z3 import *\nfrom z3_all_models import *\n\nfile0_isNull = Bool('file0_isNull')\n\nconstraints = [\n  file0_isNull\n]\n\nsolver = Solver()\nfor constraint in constraints:\n  solver.add(constraint)\n\nmodels = list(all_smt(solver))\nfor model in models: print(model)",
          "symPyProgram": "from sympy import Symbol\nfrom sympy import simplify\nfrom sympy.core.relational import Eq, Ne, StrictGreaterThan, StrictLessThan, LessThan, GreaterThan\nfrom sympy.printing import ccode\n\nfile = Symbol('file')\nnull = Symbol('null')\npath_conjunction = (Eq(file, null))\nprint(ccode(simplify(path_conjunction)))",
          "soundSymbolic": true,
          "soundBackwards": true,
          "maybe": false,
          "line": 92,
          "throwingLine": 94,
          "isStatic": false,
          "targetOnlyArguments": true
        },
        {
          "qualifiedSignature": "org.apache.commons.io.FileCleaningTracker.track(java.lang.String, java.lang.Object)",
          "exception": "throw new NullPointerException(\"The path must not be null\")",
          "pathCojunction": "(path == null)",
          "symbolicPathConjunction": "(track(path, marker, null))",
          "backwardsPathConjunction": "(path == null)",
          "simplifiedPathConjunction": "null == path",
          "z3Inputs": "[path0_isNull = True]\n",
          "z3Program": "from z3 import *\nfrom z3_all_models import *\n\npath0 = String('path0')\npath0_isNull = Bool('path0_isNull')\n\nconstraints = [\n  path0_isNull\n]\n\nsolver = Solver()\nfor constraint in constraints:\n  solver.add(constraint)\n\nmodels = list(all_smt(solver))\nfor model in models: print(model)",
          "symPyProgram": "from sympy import Symbol\nfrom sympy import simplify\nfrom sympy.core.relational import Eq, Ne, StrictGreaterThan, StrictLessThan, LessThan, GreaterThan\nfrom sympy.printing import ccode\n\npath = Symbol('path')\nnull = Symbol('null')\npath_conjunction = (Eq(path, null))\nprint(ccode(simplify(path_conjunction)))",
          "soundSymbolic": true,
          "soundBackwards": true,
          "maybe": false,
          "line": 108,
          "throwingLine": 109,
          "isStatic": false,
          "targetOnlyArguments": true
        },
        {
          "qualifiedSignature": "org.apache.commons.io.FileCleaningTracker.track(java.lang.String, java.lang.Object)",
          "exception": "throw new IllegalStateException(\"No new trackers can be added once exitWhenFinished() is called\")",
          "pathCojunction": "(!(path == null)) && (exitWhenFinished)",
          "symbolicPathConjunction": "(track(path, marker, null))",
          "backwardsPathConjunction": "(!(path == null)) && (exitWhenFinished)",
          "simplifiedPathConjunction": "exitWhenFinished && null != path",
          "z3Inputs": "[path0_isNull = False, exitWhenFinished0 = True]\n",
          "z3Program": "from z3 import *\nfrom z3_all_models import *\n\npath0 = String('path0')\nexitWhenFinished0 = Bool('exitWhenFinished0')\npath0_isNull = Bool('path0_isNull')\n\nconstraints = [\n  And(Not(path0_isNull), exitWhenFinished0)\n]\n\nsolver = Solver()\nfor constraint in constraints:\n  solver.add(constraint)\n\nmodels = list(all_smt(solver))\nfor model in models: print(model)",
          "symPyProgram": "from sympy import Symbol\nfrom sympy import simplify\nfrom sympy.core.relational import Eq, Ne, StrictGreaterThan, StrictLessThan, LessThan, GreaterThan\nfrom sympy.printing import ccode\n\npath = Symbol('path')\nexitWhenFinished = Symbol('exitWhenFinished')\nnull = Symbol('null')\npath_conjunction = ((~((Eq(path, null)))) & exitWhenFinished)\nprint(ccode(simplify(path_conjunction)))",
          "soundSymbolic": true,
          "soundBackwards": true,
          "maybe": false,
          "line": 108,
          "throwingLine": 109,
          "isStatic": false,
          "targetOnlyArguments": false
        },
        {
          "qualifiedSignature": "org.apache.commons.io.FileCleaningTracker.track(java.lang.String, java.lang.Object, org.apache.commons.io.FileDeleteStrategy)",
          "exception": "throw new IllegalStateException(\"No new trackers can be added once exitWhenFinished() is called\");",
          "pathCojunction": "(!(path == null)) && (exitWhenFinished)",
          "symbolicPathConjunction": "(!(path == null)) && (!(exitWhenFinished))",
          "backwardsPathConjunction": "(!(path == null)) && (exitWhenFinished)",
          "simplifiedPathConjunction": "exitWhenFinished && null != path",
          "z3Inputs": "[path0_isNull = False, exitWhenFinished0 = True]\n",
          "z3Program": "from z3 import *\nfrom z3_all_models import *\n\npath0 = String('path0')\nexitWhenFinished0 = Bool('exitWhenFinished0')\npath0_isNull = Bool('path0_isNull')\n\nconstraints = [\n  And(Not(path0_isNull), exitWhenFinished0)\n]\n\nsolver = Solver()\nfor constraint in constraints:\n  solver.add(constraint)\n\nmodels = list(all_smt(solver))\nfor model in models: print(model)",
          "symPyProgram": "from sympy import Symbol\nfrom sympy import simplify\nfrom sympy.core.relational import Eq, Ne, StrictGreaterThan, StrictLessThan, LessThan, GreaterThan\nfrom sympy.printing import ccode\n\npath = Symbol('path')\nexitWhenFinished = Symbol('exitWhenFinished')\nnull = Symbol('null')\npath_conjunction = ((~((Eq(path, null)))) & exitWhenFinished)\nprint(ccode(simplify(path_conjunction)))",
          "soundSymbolic": true,
          "soundBackwards": true,
          "maybe": false,
          "line": 122,
          "throwingLine": 126,
          "isStatic": false,
          "targetOnlyArguments": false
        },
        {
          "qualifiedSignature": "org.apache.commons.io.FileCleaningTracker.track(java.lang.String, java.lang.Object, org.apache.commons.io.FileDeleteStrategy)",
          "exception": "throw new NullPointerException(\"The path must not be null\");",
          "pathCojunction": "(path == null)",
          "symbolicPathConjunction": "(path == null)",
          "backwardsPathConjunction": "(path == null)",
          "simplifiedPathConjunction": "null == path",
          "z3Inputs": "[path0_isNull = True]\n",
          "z3Program": "from z3 import *\nfrom z3_all_models import *\n\npath0 = String('path0')\npath0_isNull = Bool('path0_isNull')\n\nconstraints = [\n  path0_isNull\n]\n\nsolver = Solver()\nfor constraint in constraints:\n  solver.add(constraint)\n\nmodels = list(all_smt(solver))\nfor model in models: print(model)",
          "symPyProgram": "from sympy import Symbol\nfrom sympy import simplify\nfrom sympy.core.relational import Eq, Ne, StrictGreaterThan, StrictLessThan, LessThan, GreaterThan\nfrom sympy.printing import ccode\n\npath = Symbol('path')\nnull = Symbol('null')\npath_conjunction = (Eq(path, null))\nprint(ccode(simplify(path_conjunction)))",
          "soundSymbolic": true,
          "soundBackwards": true,
          "maybe": false,
          "line": 122,
          "throwingLine": 124,
          "isStatic": false,
          "targetOnlyArguments": true
        }
      ]
    },
    {
      "path": "/home/yanghengqin/commons-io-commons-io-2.6/src/main/java/org/apache/commons/io/input/ReaderInputStream.java",
      "methods": [
        {
          "qualifiedSignature": "org.apache.commons.io.input.ReaderInputStream.read(byte[], int, int)",
          "exception": "throw new NullPointerException(\"Byte array must not be null\");",
          "pathCojunction": "(b == null)",
          "symbolicPathConjunction": "(b == null)",
          "backwardsPathConjunction": "(b == null)",
          "simplifiedPathConjunction": "b == null",
          "z3Inputs": "[b0_isNull = True]\n",
          "z3Program": "from z3 import *\nfrom z3_all_models import *\n\noff0 = Int('off0')\nlen0 = Int('len0')\nb0_isNull = Bool('b0_isNull')\n\nconstraints = [\n  b0_isNull\n]\n\nsolver = Solver()\nfor constraint in constraints:\n  solver.add(constraint)\n\nmodels = list(all_smt(solver))\nfor model in models: print(model)",
          "symPyProgram": "from sympy import Symbol\nfrom sympy import simplify\nfrom sympy.core.relational import Eq, Ne, StrictGreaterThan, StrictLessThan, LessThan, GreaterThan\nfrom sympy.printing import ccode\n\nb = Symbol('b')\nnull = Symbol('null')\npath_conjunction = (Eq(b, null))\nprint(ccode(simplify(path_conjunction)))",
          "soundSymbolic": true,
          "soundBackwards": true,
          "maybe": false,
          "line": 226,
          "throwingLine": 228,
          "isStatic": false,
          "targetOnlyArguments": true
        },
        {
          "qualifiedSignature": "org.apache.commons.io.input.ReaderInputStream.read(byte[], int, int)",
          "exception": "throw new IndexOutOfBoundsException(\"Array Size=\" + b.length + \", offset=\" + off + \", length=\" + len);",
          "pathCojunction": "(!(b == null)) && (len < 0 || off < 0 || (off + len) > b.length)",
          "symbolicPathConjunction": "(!(b == null)) && (len < 0 || off < 0 || (off + len) > b.length)",
          "backwardsPathConjunction": "(!(b == null)) && (len < 0 || off < 0 || (off + len) > b.length)",
          "simplifiedPathConjunction": "(b.length < len + off || len < 0 || off < 0) && b != null",
          "z3Inputs": "[off0 = -1, b0_length = 0, len0 = 2, b0_isNull = False]\n[off0 = 1, b0_isNull = False, b0_length = 1, len0 = 1]\n[b0_isNull = False, b0_length = 0, len0 = -1]\n[off0 = 0, b0_isNull = False, b0_length = 0, len0 = -2]\n[b0_isNull = False, b0_length = 0, len0 = -3]\n[b0_isNull = False, b0_length = 0, len0 = -4]\n[off0 = 1, b0_isNull = False, b0_length = 0, len0 = -5]\n[b0_isNull = False, b0_length = 0, len0 = -6]\n[b0_isNull = False, b0_length = 0, len0 = -7]\n[b0_isNull = False, b0_length = 0, len0 = -8]\n",
          "z3Program": "from z3 import *\nfrom z3_all_models import *\n\noff0 = Int('off0')\nlen0 = Int('len0')\nb0_isNull = Bool('b0_isNull')\nb0_length = Int('b0_length')\n\nconstraints = [\n  b0_length >= 0, # implicit\n  And(Not(b0_isNull), Or(Or(len0 < 0, off0 < 0), off0 + len0 > b0_length))\n]\n\nsolver = Solver()\nfor constraint in constraints:\n  solver.add(constraint)\n\nmodels = list(all_smt(solver))\nfor model in models: print(model)",
          "symPyProgram": "from sympy import Symbol\nfrom sympy import simplify\nfrom sympy.core.relational import Eq, Ne, StrictGreaterThan, StrictLessThan, LessThan, GreaterThan\nfrom sympy.printing import ccode\n\nb = Symbol('b')\noff = Symbol('off', integer=True)\nlen = Symbol('len', integer=True)\nb_length = Symbol('b_length', integer=True)\nnull = Symbol('null')\npath_conjunction = ((~((Eq(b, null)))) & (((StrictLessThan(len, 0)) | (StrictLessThan(off, 0))) | (StrictGreaterThan((off + len), b_length))))\nprint(ccode(simplify(path_conjunction)))",
          "soundSymbolic": true,
          "soundBackwards": true,
          "maybe": false,
          "line": 226,
          "throwingLine": 231,
          "isStatic": false,
          "targetOnlyArguments": true
        },
        {
          "qualifiedSignature": "org.apache.commons.io.input.ReaderInputStream.read(byte[])",
          "exception": "throw new NullPointerException(\"Byte array must not be null\")",
          "pathCojunction": "(b == null)",
          "symbolicPathConjunction": "(read(b, 0, b.length))",
          "backwardsPathConjunction": "(b == null)",
          "simplifiedPathConjunction": "b == null",
          "z3Inputs": "[b0_isNull = True]\n",
          "z3Program": "from z3 import *\nfrom z3_all_models import *\n\nb0_isNull = Bool('b0_isNull')\n\nconstraints = [\n  b0_isNull\n]\n\nsolver = Solver()\nfor constraint in constraints:\n  solver.add(constraint)\n\nmodels = list(all_smt(solver))\nfor model in models: print(model)",
          "symPyProgram": "from sympy import Symbol\nfrom sympy import simplify\nfrom sympy.core.relational import Eq, Ne, StrictGreaterThan, StrictLessThan, LessThan, GreaterThan\nfrom sympy.printing import ccode\n\nb = Symbol('b')\nnull = Symbol('null')\npath_conjunction = (Eq(b, null))\nprint(ccode(simplify(path_conjunction)))",
          "soundSymbolic": true,
          "soundBackwards": true,
          "maybe": false,
          "line": 264,
          "throwingLine": 265,
          "isStatic": false,
          "targetOnlyArguments": true
        }
      ]
    },
    {
      "path": "/home/yanghengqin/commons-io-commons-io-2.6/src/main/java/org/apache/commons/io/input/UnixLineEndingInputStream.java",
      "methods": [
        {
          "qualifiedSignature": "org.apache.commons.io.input.UnixLineEndingInputStream.mark(int)",
          "exception": "throw new UnsupportedOperationException(\"Mark notsupported\");",
          "pathCojunction": "true",
          "backwardsPathConjunction": "true",
          "simplifiedPathConjunction": "true",
          "z3Program": "from z3 import *\nfrom z3_all_models import *\n\nreadlimit0 = Int('readlimit0')\n\nconstraints = [\n  True\n]\n\nsolver = Solver()\nfor constraint in constraints:\n  solver.add(constraint)\n\nmodels = list(all_smt(solver))\nfor model in models: print(model)",
          "soundSymbolic": false,
          "soundBackwards": true,
          "maybe": false,
          "line": 125,
          "throwingLine": 126,
          "isStatic": false,
          "targetOnlyArguments": true
        }
      ]
    },
    {
      "path": "/home/yanghengqin/commons-io-commons-io-2.6/src/main/java/org/apache/commons/io/output/WriterOutputStream.java",
      "methods": [
        {
          "qualifiedSignature": "org.apache.commons.io.output.WriterOutputStream.write(byte[], int, int)",
          "exception": "throw new IOException(\"Unexpected coder result\")",
          "pathCojunction": "(len > 0) && (true) && (!(decoder.decode(decoderIn, decoderOut, endOfInput).isOverflow())) && (!(decoder.decode(decoderIn, decoderOut, endOfInput).isUnderflow()))",
          "symbolicPathConjunction": "(len > 0) && ((true) && (!(coderResult.isOverflow())) && (!(coderResult.isUnderflow())))",
          "backwardsPathConjunction": "(len > 0) && (true) && (!(decoder.decode(decoderIn, decoderOut, endOfInput).isOverflow())) && (!(decoder.decode(decoderIn, decoderOut, endOfInput).isUnderflow()))",
          "simplifiedPathConjunction": "!decoder.decode(ByteBuffer.allocate(128), decoderOut, endOfInput).isOverflow() && !decoder.decode(ByteBuffer.allocate(128), decoderOut, endOfInput).isUnderflow() && len > 0",
          "z3Program": "from z3 import *\nfrom z3_all_models import *\n\noff0 = Int('off0')\nlen0 = Int('len0')\nc0 = Int('c0')\nendOfInput0 = Bool('endOfInput0')\n\nconstraints = [\n  decoderIn0 == ByteBuffer.allocate(128),\n  c0 == Math.min(len0, decoderIn0.remaining()),\n  And(And(And(len0 > 0, True), Not(decoder.decode(decoderIn0, decoderOut, endOfInput0).isOverflow())), Not(decoder.decode(decoderIn0, decoderOut, endOfInput0).isUnderflow()))\n]\n\nsolver = Solver()\nfor constraint in constraints:\n  solver.add(constraint)\n\nmodels = list(all_smt(solver))\nfor model in models: print(model)",
          "symPyProgram": "from sympy import Symbol\nfrom sympy import simplify\nfrom sympy.core.relational import Eq, Ne, StrictGreaterThan, StrictLessThan, LessThan, GreaterThan\nfrom sympy.printing import ccode\n\nlen = Symbol('len', integer=True)\nendOfInput = Symbol('endOfInput')\ndecoder_decode_isOverflow = Symbol('decoder_decode_isOverflow')\ndecoder_decode = Symbol('decoder_decode')\nByteBuffer_allocate = Symbol('ByteBuffer_allocate')\ndecoder_decode_isUnderflow = Symbol('decoder_decode_isUnderflow')\npath_conjunction = ((((StrictGreaterThan(len, 0)) & True) & (~(decoder_decode_isOverflow))) & (~(decoder_decode_isUnderflow)))\nprint(ccode(simplify(path_conjunction)))",
          "soundSymbolic": false,
          "soundBackwards": false,
          "maybe": true,
          "line": 215,
          "throwingLine": 219,
          "isStatic": false,
          "targetOnlyArguments": false
        },
        {
          "qualifiedSignature": "org.apache.commons.io.output.WriterOutputStream.write(byte[])",
          "exception": "throw new IOException(\"Unexpected coder result\")",
          "pathCojunction": "(b.length > 0) && (true) && (!(decoder.decode(ByteBuffer.allocate(128), decoderOut, endOfInput).isOverflow())) && (!(decoder.decode(ByteBuffer.allocate(128), decoderOut, endOfInput).isUnderflow()))",
          "symbolicPathConjunction": "(write(b, 0, b.length))",
          "backwardsPathConjunction": "(b.length > 0) && (true) && (!(decoder.decode(ByteBuffer.allocate(128), decoderOut, endOfInput).isOverflow())) && (!(decoder.decode(ByteBuffer.allocate(128), decoderOut, endOfInput).isUnderflow()))",
          "simplifiedPathConjunction": "!decoder.decode(ByteBuffer.allocate(128), decoderOut, endOfInput).isOverflow() && !decoder.decode(ByteBuffer.allocate(128), decoderOut, endOfInput).isUnderflow() && b.length > 0",
          "z3Program": "from z3 import *\nfrom z3_all_models import *\n\nendOfInput0 = Bool('endOfInput0')\nb0_length = Int('b0_length')\n\nconstraints = [\n  b0_length >= 0, # implicit\n  And(And(And(b0_length > 0, True), Not(decoder.decode(ByteBuffer.allocate(128), decoderOut, endOfInput0).isOverflow())), Not(decoder.decode(ByteBuffer.allocate(128), decoderOut, endOfInput0).isUnderflow()))\n]\n\nsolver = Solver()\nfor constraint in constraints:\n  solver.add(constraint)\n\nmodels = list(all_smt(solver))\nfor model in models: print(model)",
          "symPyProgram": "from sympy import Symbol\nfrom sympy import simplify\nfrom sympy.core.relational import Eq, Ne, StrictGreaterThan, StrictLessThan, LessThan, GreaterThan\nfrom sympy.printing import ccode\n\nb = Symbol('b')\nendOfInput = Symbol('endOfInput')\nb_length = Symbol('b_length', integer=True)\ndecoder_decode_isOverflow = Symbol('decoder_decode_isOverflow')\ndecoder_decode = Symbol('decoder_decode')\nByteBuffer_allocate = Symbol('ByteBuffer_allocate')\ndecoder_decode_isUnderflow = Symbol('decoder_decode_isUnderflow')\npath_conjunction = ((((StrictGreaterThan(b_length, 0)) & True) & (~(decoder_decode_isOverflow))) & (~(decoder_decode_isUnderflow)))\nprint(ccode(simplify(path_conjunction)))",
          "soundSymbolic": true,
          "soundBackwards": false,
          "maybe": true,
          "line": 235,
          "throwingLine": 236,
          "isStatic": false,
          "targetOnlyArguments": false
        },
        {
          "qualifiedSignature": "org.apache.commons.io.output.WriterOutputStream.write(int)",
          "exception": "throw new IOException(\"Unexpected coder result\")",
          "pathCojunction": "(1 > 0) && (true) && (!(decoder.decode(ByteBuffer.allocate(128), decoderOut, endOfInput).isOverflow())) && (!(decoder.decode(ByteBuffer.allocate(128), decoderOut, endOfInput).isUnderflow()))",
          "symbolicPathConjunction": "(write(new byte[] { (byte) b }, 0, 1))",
          "backwardsPathConjunction": "(1 > 0) && (true) && (!(decoder.decode(ByteBuffer.allocate(128), decoderOut, endOfInput).isOverflow())) && (!(decoder.decode(ByteBuffer.allocate(128), decoderOut, endOfInput).isUnderflow()))",
          "simplifiedPathConjunction": "!decoder.decode(ByteBuffer.allocate(128), decoderOut, endOfInput).isOverflow() && !decoder.decode(ByteBuffer.allocate(128), decoderOut, endOfInput).isUnderflow()",
          "z3Program": "from z3 import *\nfrom z3_all_models import *\n\nb0 = Int('b0')\nendOfInput0 = Bool('endOfInput0')\n\nconstraints = [\n  And(And(And(1 > 0, True), Not(decoder.decode(ByteBuffer.allocate(128), decoderOut, endOfInput0).isOverflow())), Not(decoder.decode(ByteBuffer.allocate(128), decoderOut, endOfInput0).isUnderflow()))\n]\n\nsolver = Solver()\nfor constraint in constraints:\n  solver.add(constraint)\n\nmodels = list(all_smt(solver))\nfor model in models: print(model)",
          "symPyProgram": "from sympy import Symbol\nfrom sympy import simplify\nfrom sympy.core.relational import Eq, Ne, StrictGreaterThan, StrictLessThan, LessThan, GreaterThan\nfrom sympy.printing import ccode\n\nendOfInput = Symbol('endOfInput')\ndecoder_decode_isOverflow = Symbol('decoder_decode_isOverflow')\ndecoder_decode = Symbol('decoder_decode')\nByteBuffer_allocate = Symbol('ByteBuffer_allocate')\ndecoder_decode_isUnderflow = Symbol('decoder_decode_isUnderflow')\npath_conjunction = ((((StrictGreaterThan(1, 0)) & True) & (~(decoder_decode_isOverflow))) & (~(decoder_decode_isUnderflow)))\nprint(ccode(simplify(path_conjunction)))",
          "soundSymbolic": true,
          "soundBackwards": false,
          "maybe": true,
          "line": 246,
          "throwingLine": 247,
          "isStatic": false,
          "targetOnlyArguments": false
        },
        {
          "qualifiedSignature": "org.apache.commons.io.output.WriterOutputStream.close()",
          "exception": "throw new IOException(\"Unexpected coder result\")",
          "pathCojunction": "(true) && (!(decoder.decode(decoderIn, decoderOut, endOfInput).isOverflow())) && (!(decoder.decode(decoderIn, decoderOut, endOfInput).isUnderflow()))",
          "symbolicPathConjunction": "((true) && (!(coderResult.isOverflow())) && (!(coderResult.isUnderflow())))",
          "backwardsPathConjunction": "(true) && (!(decoder.decode(decoderIn, decoderOut, endOfInput).isOverflow())) && (!(decoder.decode(decoderIn, decoderOut, endOfInput).isUnderflow()))",
          "simplifiedPathConjunction": "!decoder.decode(decoderIn, decoderOut, endOfInput)_isOverflow && !decoder.decode(decoderIn, decoderOut, endOfInput).isUnderflow()",
          "z3Program": "from z3 import *\nfrom z3_all_models import *\n\nendOfInput0 = Bool('endOfInput0')\n\nconstraints = [\n  And(And(True, Not(decoder.decode(decoderIn, decoderOut, endOfInput0).isOverflow())), Not(decoder.decode(decoderIn, decoderOut, endOfInput0).isUnderflow()))\n]\n\nsolver = Solver()\nfor constraint in constraints:\n  solver.add(constraint)\n\nmodels = list(all_smt(solver))\nfor model in models: print(model)",
          "symPyProgram": "from sympy import Symbol\nfrom sympy import simplify\nfrom sympy.core.relational import Eq, Ne, StrictGreaterThan, StrictLessThan, LessThan, GreaterThan\nfrom sympy.printing import ccode\n\nendOfInput = Symbol('endOfInput')\ndecoder_decode_isOverflow = Symbol('decoder_decode_isOverflow')\ndecoder_decode = Symbol('decoder_decode')\ndecoder_decode_isUnderflow = Symbol('decoder_decode_isUnderflow')\npath_conjunction = ((True & (~(decoder_decode_isOverflow))) & (~(decoder_decode_isUnderflow)))\nprint(ccode(simplify(path_conjunction)))",
          "soundSymbolic": true,
          "soundBackwards": false,
          "maybe": true,
          "line": 269,
          "throwingLine": 270,
          "isStatic": false,
          "targetOnlyArguments": false
        }
      ]
    },
    {
      "path": "/home/yanghengqin/commons-io-commons-io-2.6/src/main/java/org/apache/commons/io/EndianUtils.java",
      "methods": [
        {
          "qualifiedSignature": "org.apache.commons.io.EndianUtils.readSwappedShort(java.io.InputStream)",
          "exception": "throw new EOFException(\"Unexpected EOF reached\");",
          "pathCojunction": "(EOF == input.read())",
          "symbolicPathConjunction": "(EOF == input.read())",
          "backwardsPathConjunction": "(EOF == input.read())",
          "z3Program": "from z3 import *\nfrom z3_all_models import *\n\n\nconstraints = [\n  EOF == input0.read()\n]\n\nsolver = Solver()\nfor constraint in constraints:\n  solver.add(constraint)\n\nmodels = list(all_smt(solver))\nfor model in models: print(model)",
          "symPyProgram": "from sympy import Symbol\nfrom sympy import simplify\nfrom sympy.core.relational import Eq, Ne, StrictGreaterThan, StrictLessThan, LessThan, GreaterThan\nfrom sympy.printing import ccode\n\ninput = Symbol('input')\ninput_read = Symbol('input_read')\npath_conjunction = (Eq(EOF, input_read))\nprint(ccode(simplify(path_conjunction)))",
          "soundSymbolic": true,
          "soundBackwards": false,
          "maybe": true,
          "line": 292,
          "throwingLine": 293,
          "isStatic": true,
          "targetOnlyArguments": false
        },
        {
          "qualifiedSignature": "org.apache.commons.io.EndianUtils.readSwappedShort(java.io.InputStream)",
          "exception": "throw new EOFException(\"Unexpected EOF reached\");",
          "pathCojunction": "(!(EOF == input.read())) && (EOF == input.read())",
          "symbolicPathConjunction": "(!(EOF == input.read())) && (EOF == input.read())",
          "backwardsPathConjunction": "(!(EOF == input.read())) && (EOF == input.read())",
          "z3Program": "from z3 import *\nfrom z3_all_models import *\n\nvalue0 = Int('value0')\n\nconstraints = [\n  value0 == input0.read(),\n  And(Not(EOF == input0.read()), EOF == input0.read())\n]\n\nsolver = Solver()\nfor constraint in constraints:\n  solver.add(constraint)\n\nmodels = list(all_smt(solver))\nfor model in models: print(model)",
          "symPyProgram": "from sympy import Symbol\nfrom sympy import simplify\nfrom sympy.core.relational import Eq, Ne, StrictGreaterThan, StrictLessThan, LessThan, GreaterThan\nfrom sympy.printing import ccode\n\ninput = Symbol('input')\ninput_read = Symbol('input_read')\npath_conjunction = ((~((Eq(EOF, input_read)))) & (Eq(EOF, input_read)))\nprint(ccode(simplify(path_conjunction)))",
          "soundSymbolic": true,
          "soundBackwards": false,
          "maybe": true,
          "line": 292,
          "throwingLine": 293,
          "isStatic": true,
          "targetOnlyArguments": false
        },
        {
          "qualifiedSignature": "org.apache.commons.io.EndianUtils.readSwappedUnsignedShort(java.io.InputStream)",
          "exception": "throw new EOFException(\"Unexpected EOF reached\");",
          "pathCojunction": "(!(EOF == input.read())) && (EOF == input.read())",
          "symbolicPathConjunction": "(!(EOF == input.read())) && (EOF == input.read())",
          "backwardsPathConjunction": "(!(EOF == input.read())) && (EOF == input.read())",
          "z3Program": "from z3 import *\nfrom z3_all_models import *\n\nvalue0 = Int('value0')\nvalue10 = Int('value10')\n\nconstraints = [\n  value0 == input0.read(),\n  value10 == value0,\n  And(Not(EOF == input0.read()), EOF == input0.read())\n]\n\nsolver = Solver()\nfor constraint in constraints:\n  solver.add(constraint)\n\nmodels = list(all_smt(solver))\nfor model in models: print(model)",
          "symPyProgram": "from sympy import Symbol\nfrom sympy import simplify\nfrom sympy.core.relational import Eq, Ne, StrictGreaterThan, StrictLessThan, LessThan, GreaterThan\nfrom sympy.printing import ccode\n\ninput = Symbol('input')\ninput_read = Symbol('input_read')\npath_conjunction = ((~((Eq(EOF, input_read)))) & (Eq(EOF, input_read)))\nprint(ccode(simplify(path_conjunction)))",
          "soundSymbolic": true,
          "soundBackwards": false,
          "maybe": true,
          "line": 306,
          "throwingLine": 308,
          "isStatic": true,
          "targetOnlyArguments": false
        },
        {
          "qualifiedSignature": "org.apache.commons.io.EndianUtils.readSwappedUnsignedShort(java.io.InputStream)",
          "exception": "throw new EOFException(\"Unexpected EOF reached\");",
          "pathCojunction": "(EOF == input.read())",
          "symbolicPathConjunction": "(EOF == input.read())",
          "backwardsPathConjunction": "(EOF == input.read())",
          "z3Program": "from z3 import *\nfrom z3_all_models import *\n\n\nconstraints = [\n  EOF == input0.read()\n]\n\nsolver = Solver()\nfor constraint in constraints:\n  solver.add(constraint)\n\nmodels = list(all_smt(solver))\nfor model in models: print(model)",
          "symPyProgram": "from sympy import Symbol\nfrom sympy import simplify\nfrom sympy.core.relational import Eq, Ne, StrictGreaterThan, StrictLessThan, LessThan, GreaterThan\nfrom sympy.printing import ccode\n\ninput = Symbol('input')\ninput_read = Symbol('input_read')\npath_conjunction = (Eq(EOF, input_read))\nprint(ccode(simplify(path_conjunction)))",
          "soundSymbolic": true,
          "soundBackwards": false,
          "maybe": true,
          "line": 306,
          "throwingLine": 307,
          "isStatic": true,
          "targetOnlyArguments": false
        },
        {
          "qualifiedSignature": "org.apache.commons.io.EndianUtils.readSwappedInteger(java.io.InputStream)",
          "exception": "throw new EOFException(\"Unexpected EOF reached\");",
          "pathCojunction": "(!(EOF == input.read())) && (!(EOF == input.read())) && (EOF == input.read())",
          "symbolicPathConjunction": "(!(EOF == input.read())) && (!(EOF == input.read())) && (EOF == input.read())",
          "backwardsPathConjunction": "(!(EOF == input.read())) && (!(EOF == input.read())) && (EOF == input.read())",
          "z3Program": "from z3 import *\nfrom z3_all_models import *\n\nvalue0 = Int('value0')\nvalue10 = Int('value10')\nvalue20 = Int('value20')\n\nconstraints = [\n  value0 == input0.read(),\n  value10 == value0,\n  value20 == value0,\n  And(And(Not(EOF == input0.read()), Not(EOF == input0.read())), EOF == input0.read())\n]\n\nsolver = Solver()\nfor constraint in constraints:\n  solver.add(constraint)\n\nmodels = list(all_smt(solver))\nfor model in models: print(model)",
          "symPyProgram": "from sympy import Symbol\nfrom sympy import simplify\nfrom sympy.core.relational import Eq, Ne, StrictGreaterThan, StrictLessThan, LessThan, GreaterThan\nfrom sympy.printing import ccode\n\ninput = Symbol('input')\ninput_read = Symbol('input_read')\npath_conjunction = (((~((Eq(EOF, input_read)))) & (~((Eq(EOF, input_read))))) & (Eq(EOF, input_read)))\nprint(ccode(simplify(path_conjunction)))",
          "soundSymbolic": true,
          "soundBackwards": false,
          "maybe": true,
          "line": 339,
          "throwingLine": 342,
          "isStatic": true,
          "targetOnlyArguments": false
        },
        {
          "qualifiedSignature": "org.apache.commons.io.EndianUtils.readSwappedInteger(java.io.InputStream)",
          "exception": "throw new EOFException(\"Unexpected EOF reached\");",
          "pathCojunction": "(!(EOF == input.read())) && (!(EOF == input.read())) && (!(EOF == input.read())) && (EOF == input.read())",
          "symbolicPathConjunction": "(!(EOF == input.read())) && (!(EOF == input.read())) && (!(EOF == input.read())) && (EOF == input.read())",
          "backwardsPathConjunction": "(!(EOF == input.read())) && (!(EOF == input.read())) && (!(EOF == input.read())) && (EOF == input.read())",
          "z3Program": "from z3 import *\nfrom z3_all_models import *\n\nvalue0 = Int('value0')\nvalue10 = Int('value10')\nvalue20 = Int('value20')\nvalue30 = Int('value30')\n\nconstraints = [\n  value0 == input0.read(),\n  value10 == value0,\n  value20 == value0,\n  value30 == value0,\n  And(And(And(Not(EOF == input0.read()), Not(EOF == input0.read())), Not(EOF == input0.read())), EOF == input0.read())\n]\n\nsolver = Solver()\nfor constraint in constraints:\n  solver.add(constraint)\n\nmodels = list(all_smt(solver))\nfor model in models: print(model)",
          "symPyProgram": "from sympy import Symbol\nfrom sympy import simplify\nfrom sympy.core.relational import Eq, Ne, StrictGreaterThan, StrictLessThan, LessThan, GreaterThan\nfrom sympy.printing import ccode\n\ninput = Symbol('input')\ninput_read = Symbol('input_read')\npath_conjunction = ((((~((Eq(EOF, input_read)))) & (~((Eq(EOF, input_read))))) & (~((Eq(EOF, input_read))))) & (Eq(EOF, input_read)))\nprint(ccode(simplify(path_conjunction)))",
          "soundSymbolic": true,
          "soundBackwards": false,
          "maybe": true,
          "line": 339,
          "throwingLine": 343,
          "isStatic": true,
          "targetOnlyArguments": false
        },
        {
          "qualifiedSignature": "org.apache.commons.io.EndianUtils.readSwappedInteger(java.io.InputStream)",
          "exception": "throw new EOFException(\"Unexpected EOF reached\");",
          "pathCojunction": "(EOF == input.read())",
          "symbolicPathConjunction": "(EOF == input.read())",
          "backwardsPathConjunction": "(EOF == input.read())",
          "z3Program": "from z3 import *\nfrom z3_all_models import *\n\n\nconstraints = [\n  EOF == input0.read()\n]\n\nsolver = Solver()\nfor constraint in constraints:\n  solver.add(constraint)\n\nmodels = list(all_smt(solver))\nfor model in models: print(model)",
          "symPyProgram": "from sympy import Symbol\nfrom sympy import simplify\nfrom sympy.core.relational import Eq, Ne, StrictGreaterThan, StrictLessThan, LessThan, GreaterThan\nfrom sympy.printing import ccode\n\ninput = Symbol('input')\ninput_read = Symbol('input_read')\npath_conjunction = (Eq(EOF, input_read))\nprint(ccode(simplify(path_conjunction)))",
          "soundSymbolic": true,
          "soundBackwards": false,
          "maybe": true,
          "line": 339,
          "throwingLine": 340,
          "isStatic": true,
          "targetOnlyArguments": false
        },
        {
          "qualifiedSignature": "org.apache.commons.io.EndianUtils.readSwappedInteger(java.io.InputStream)",
          "exception": "throw new EOFException(\"Unexpected EOF reached\");",
          "pathCojunction": "(!(EOF == input.read())) && (EOF == input.read())",
          "symbolicPathConjunction": "(!(EOF == input.read())) && (EOF == input.read())",
          "backwardsPathConjunction": "(!(EOF == input.read())) && (EOF == input.read())",
          "z3Program": "from z3 import *\nfrom z3_all_models import *\n\nvalue0 = Int('value0')\nvalue10 = Int('value10')\n\nconstraints = [\n  value0 == input0.read(),\n  value10 == value0,\n  And(Not(EOF == input0.read()), EOF == input0.read())\n]\n\nsolver = Solver()\nfor constraint in constraints:\n  solver.add(constraint)\n\nmodels = list(all_smt(solver))\nfor model in models: print(model)",
          "symPyProgram": "from sympy import Symbol\nfrom sympy import simplify\nfrom sympy.core.relational import Eq, Ne, StrictGreaterThan, StrictLessThan, LessThan, GreaterThan\nfrom sympy.printing import ccode\n\ninput = Symbol('input')\ninput_read = Symbol('input_read')\npath_conjunction = ((~((Eq(EOF, input_read)))) & (Eq(EOF, input_read)))\nprint(ccode(simplify(path_conjunction)))",
          "soundSymbolic": true,
          "soundBackwards": false,
          "maybe": true,
          "line": 339,
          "throwingLine": 341,
          "isStatic": true,
          "targetOnlyArguments": false
        },
        {
          "qualifiedSignature": "org.apache.commons.io.EndianUtils.readSwappedUnsignedInteger(java.io.InputStream)",
          "exception": "throw new EOFException(\"Unexpected EOF reached\");",
          "pathCojunction": "(!(EOF == input.read())) && (!(EOF == input.read())) && (!(EOF == input.read())) && (EOF == input.read())",
          "symbolicPathConjunction": "(!(EOF == input.read())) && (!(EOF == input.read())) && (!(EOF == input.read())) && (EOF == input.read())",
          "backwardsPathConjunction": "(!(EOF == input.read())) && (!(EOF == input.read())) && (!(EOF == input.read())) && (EOF == input.read())",
          "z3Program": "from z3 import *\nfrom z3_all_models import *\n\nvalue0 = Int('value0')\nvalue10 = Int('value10')\nvalue20 = Int('value20')\nvalue30 = Int('value30')\n\nconstraints = [\n  value0 == input0.read(),\n  value10 == value0,\n  value20 == value0,\n  value30 == value0,\n  And(And(And(Not(EOF == input0.read()), Not(EOF == input0.read())), Not(EOF == input0.read())), EOF == input0.read())\n]\n\nsolver = Solver()\nfor constraint in constraints:\n  solver.add(constraint)\n\nmodels = list(all_smt(solver))\nfor model in models: print(model)",
          "symPyProgram": "from sympy import Symbol\nfrom sympy import simplify\nfrom sympy.core.relational import Eq, Ne, StrictGreaterThan, StrictLessThan, LessThan, GreaterThan\nfrom sympy.printing import ccode\n\ninput = Symbol('input')\ninput_read = Symbol('input_read')\npath_conjunction = ((((~((Eq(EOF, input_read)))) & (~((Eq(EOF, input_read))))) & (~((Eq(EOF, input_read))))) & (Eq(EOF, input_read)))\nprint(ccode(simplify(path_conjunction)))",
          "soundSymbolic": true,
          "soundBackwards": false,
          "maybe": true,
          "line": 360,
          "throwingLine": 364,
          "isStatic": true,
          "targetOnlyArguments": false
        },
        {
          "qualifiedSignature": "org.apache.commons.io.EndianUtils.readSwappedUnsignedInteger(java.io.InputStream)",
          "exception": "throw new EOFException(\"Unexpected EOF reached\");",
          "pathCojunction": "(!(EOF == input.read())) && (!(EOF == input.read())) && (EOF == input.read())",
          "symbolicPathConjunction": "(!(EOF == input.read())) && (!(EOF == input.read())) && (EOF == input.read())",
          "backwardsPathConjunction": "(!(EOF == input.read())) && (!(EOF == input.read())) && (EOF == input.read())",
          "z3Program": "from z3 import *\nfrom z3_all_models import *\n\nvalue0 = Int('value0')\nvalue10 = Int('value10')\nvalue20 = Int('value20')\n\nconstraints = [\n  value0 == input0.read(),\n  value10 == value0,\n  value20 == value0,\n  And(And(Not(EOF == input0.read()), Not(EOF == input0.read())), EOF == input0.read())\n]\n\nsolver = Solver()\nfor constraint in constraints:\n  solver.add(constraint)\n\nmodels = list(all_smt(solver))\nfor model in models: print(model)",
          "symPyProgram": "from sympy import Symbol\nfrom sympy import simplify\nfrom sympy.core.relational import Eq, Ne, StrictGreaterThan, StrictLessThan, LessThan, GreaterThan\nfrom sympy.printing import ccode\n\ninput = Symbol('input')\ninput_read = Symbol('input_read')\npath_conjunction = (((~((Eq(EOF, input_read)))) & (~((Eq(EOF, input_read))))) & (Eq(EOF, input_read)))\nprint(ccode(simplify(path_conjunction)))",
          "soundSymbolic": true,
          "soundBackwards": false,
          "maybe": true,
          "line": 360,
          "throwingLine": 363,
          "isStatic": true,
          "targetOnlyArguments": false
        },
        {
          "qualifiedSignature": "org.apache.commons.io.EndianUtils.readSwappedUnsignedInteger(java.io.InputStream)",
          "exception": "throw new EOFException(\"Unexpected EOF reached\");",
          "pathCojunction": "(EOF == input.read())",
          "symbolicPathConjunction": "(EOF == input.read())",
          "backwardsPathConjunction": "(EOF == input.read())",
          "z3Program": "from z3 import *\nfrom z3_all_models import *\n\n\nconstraints = [\n  EOF == input0.read()\n]\n\nsolver = Solver()\nfor constraint in constraints:\n  solver.add(constraint)\n\nmodels = list(all_smt(solver))\nfor model in models: print(model)",
          "symPyProgram": "from sympy import Symbol\nfrom sympy import simplify\nfrom sympy.core.relational import Eq, Ne, StrictGreaterThan, StrictLessThan, LessThan, GreaterThan\nfrom sympy.printing import ccode\n\ninput = Symbol('input')\ninput_read = Symbol('input_read')\npath_conjunction = (Eq(EOF, input_read))\nprint(ccode(simplify(path_conjunction)))",
          "soundSymbolic": true,
          "soundBackwards": false,
          "maybe": true,
          "line": 360,
          "throwingLine": 361,
          "isStatic": true,
          "targetOnlyArguments": false
        },
        {
          "qualifiedSignature": "org.apache.commons.io.EndianUtils.readSwappedUnsignedInteger(java.io.InputStream)",
          "exception": "throw new EOFException(\"Unexpected EOF reached\");",
          "pathCojunction": "(!(EOF == input.read())) && (EOF == input.read())",
          "symbolicPathConjunction": "(!(EOF == input.read())) && (EOF == input.read())",
          "backwardsPathConjunction": "(!(EOF == input.read())) && (EOF == input.read())",
          "z3Program": "from z3 import *\nfrom z3_all_models import *\n\nvalue0 = Int('value0')\nvalue10 = Int('value10')\n\nconstraints = [\n  value0 == input0.read(),\n  value10 == value0,\n  And(Not(EOF == input0.read()), EOF == input0.read())\n]\n\nsolver = Solver()\nfor constraint in constraints:\n  solver.add(constraint)\n\nmodels = list(all_smt(solver))\nfor model in models: print(model)",
          "symPyProgram": "from sympy import Symbol\nfrom sympy import simplify\nfrom sympy.core.relational import Eq, Ne, StrictGreaterThan, StrictLessThan, LessThan, GreaterThan\nfrom sympy.printing import ccode\n\ninput = Symbol('input')\ninput_read = Symbol('input_read')\npath_conjunction = ((~((Eq(EOF, input_read)))) & (Eq(EOF, input_read)))\nprint(ccode(simplify(path_conjunction)))",
          "soundSymbolic": true,
          "soundBackwards": false,
          "maybe": true,
          "line": 360,
          "throwingLine": 362,
          "isStatic": true,
          "targetOnlyArguments": false
        }
      ]
    },
    {
      "path": "/home/yanghengqin/commons-io-commons-io-2.6/src/main/java/org/apache/commons/io/FileUtils.java",
      "methods": [
        {
          "qualifiedSignature": "org.apache.commons.io.FileUtils.openInputStream(java.io.File)",
          "exception": "throw new IOException(\"File '\" + file + \"' exists but is a directory\");",
          "pathCojunction": "(file.exists()) && (file.isDirectory())",
          "symbolicPathConjunction": "(file.exists()) && (file.isDirectory())",
          "backwardsPathConjunction": "(file.exists()) && (file.isDirectory())",
          "simplifiedPathConjunction": "file.exists() && file.isDirectory()",
          "z3Program": "from z3 import *\nfrom z3_all_models import *\n\n\nconstraints = [\n  And(file0.exists(), file0.isDirectory())\n]\n\nsolver = Solver()\nfor constraint in constraints:\n  solver.add(constraint)\n\nmodels = list(all_smt(solver))\nfor model in models: print(model)",
          "symPyProgram": "from sympy import Symbol\nfrom sympy import simplify\nfrom sympy.core.relational import Eq, Ne, StrictGreaterThan, StrictLessThan, LessThan, GreaterThan\nfrom sympy.printing import ccode\n\nfile = Symbol('file')\nfile_exists = Symbol('file_exists')\nfile_isDirectory = Symbol('file_isDirectory')\npath_conjunction = (file_exists & file_isDirectory)\nprint(ccode(simplify(path_conjunction)))",
          "soundSymbolic": false,
          "soundBackwards": true,
          "maybe": true,
          "line": 288,
          "throwingLine": 291,
          "isStatic": true,
          "targetOnlyArguments": true
        },
        {
          "qualifiedSignature": "org.apache.commons.io.FileUtils.openInputStream(java.io.File)",
          "exception": "throw new IOException(\"File '\" + file + \"' cannot be read\");",
          "pathCojunction": "(file.exists()) && (!(file.isDirectory())) && (file.canRead() == false)",
          "symbolicPathConjunction": "(file.exists()) && (!(file.isDirectory())) && (file.canRead() == false)",
          "backwardsPathConjunction": "(file.exists()) && (!(file.isDirectory())) && (file.canRead() == false)",
          "simplifiedPathConjunction": "file.exists() && !file.canRead() && !file.isDirectory()",
          "z3Program": "from z3 import *\nfrom z3_all_models import *\n\n\nconstraints = [\n  And(And(file0.exists(), Not(file0.isDirectory())), file0.canRead() == False)\n]\n\nsolver = Solver()\nfor constraint in constraints:\n  solver.add(constraint)\n\nmodels = list(all_smt(solver))\nfor model in models: print(model)",
          "symPyProgram": "from sympy import Symbol\nfrom sympy import simplify\nfrom sympy.core.relational import Eq, Ne, StrictGreaterThan, StrictLessThan, LessThan, GreaterThan\nfrom sympy.printing import ccode\n\nfile = Symbol('file')\nfile_exists = Symbol('file_exists')\nfile_isDirectory = Symbol('file_isDirectory')\nfile_canRead = Symbol('file_canRead')\npath_conjunction = ((file_exists & (~(file_isDirectory))) & (~(file_canRead)))\nprint(ccode(simplify(path_conjunction)))",
          "soundSymbolic": false,
          "soundBackwards": true,
          "maybe": true,
          "line": 288,
          "throwingLine": 294,
          "isStatic": true,
          "targetOnlyArguments": true
        },
        {
          "qualifiedSignature": "org.apache.commons.io.FileUtils.openInputStream(java.io.File)",
          "exception": "throw new FileNotFoundException(\"File '\" + file + \"' does not exist\");",
          "pathCojunction": "(!(file.exists()))",
          "symbolicPathConjunction": "(!(file.exists()))",
          "backwardsPathConjunction": "(!(file.exists()))",
          "simplifiedPathConjunction": "!file.exists()",
          "z3Program": "from z3 import *\nfrom z3_all_models import *\n\n\nconstraints = [\n  Not(file0.exists())\n]\n\nsolver = Solver()\nfor constraint in constraints:\n  solver.add(constraint)\n\nmodels = list(all_smt(solver))\nfor model in models: print(model)",
          "symPyProgram": "from sympy import Symbol\nfrom sympy import simplify\nfrom sympy.core.relational import Eq, Ne, StrictGreaterThan, StrictLessThan, LessThan, GreaterThan\nfrom sympy.printing import ccode\n\nfile = Symbol('file')\nfile_exists = Symbol('file_exists')\npath_conjunction = (~(file_exists))\nprint(ccode(simplify(path_conjunction)))",
          "soundSymbolic": false,
          "soundBackwards": true,
          "maybe": true,
          "line": 288,
          "throwingLine": 297,
          "isStatic": true,
          "targetOnlyArguments": true
        },
        {
          "qualifiedSignature": "org.apache.commons.io.FileUtils.openOutputStream(java.io.File)",
          "exception": "throw new IOException(\"File '\" + file + \"' cannot be written to\")",
          "pathCojunction": "(file.exists()) && (!(file.isDirectory())) && (file.canWrite() == false)",
          "symbolicPathConjunction": "(openOutputStream(file, false))",
          "backwardsPathConjunction": "(file.exists()) && (!(file.isDirectory())) && (file.canWrite() == false)",
          "simplifiedPathConjunction": "file.exists() && !file.canWrite() && !file.isDirectory()",
          "z3Program": "from z3 import *\nfrom z3_all_models import *\n\n\nconstraints = [\n  And(And(file0.exists(), Not(file0.isDirectory())), file0.canWrite() == False)\n]\n\nsolver = Solver()\nfor constraint in constraints:\n  solver.add(constraint)\n\nmodels = list(all_smt(solver))\nfor model in models: print(model)",
          "symPyProgram": "from sympy import Symbol\nfrom sympy import simplify\nfrom sympy.core.relational import Eq, Ne, StrictGreaterThan, StrictLessThan, LessThan, GreaterThan\nfrom sympy.printing import ccode\n\nfile = Symbol('file')\nfile_exists = Symbol('file_exists')\nfile_isDirectory = Symbol('file_isDirectory')\nfile_canWrite = Symbol('file_canWrite')\npath_conjunction = ((file_exists & (~(file_isDirectory))) & (~(file_canWrite)))\nprint(ccode(simplify(path_conjunction)))",
          "soundSymbolic": true,
          "soundBackwards": true,
          "maybe": true,
          "line": 323,
          "throwingLine": 324,
          "isStatic": true,
          "targetOnlyArguments": true
        },
        {
          "qualifiedSignature": "org.apache.commons.io.FileUtils.openOutputStream(java.io.File)",
          "exception": "throw new IOException(\"File '\" + file + \"' exists but is a directory\")",
          "pathCojunction": "(file.exists()) && (file.isDirectory())",
          "symbolicPathConjunction": "(openOutputStream(file, false))",
          "backwardsPathConjunction": "(file.exists()) && (file.isDirectory())",
          "simplifiedPathConjunction": "file.exists() && file.isDirectory()",
          "z3Program": "from z3 import *\nfrom z3_all_models import *\n\n\nconstraints = [\n  And(file0.exists(), file0.isDirectory())\n]\n\nsolver = Solver()\nfor constraint in constraints:\n  solver.add(constraint)\n\nmodels = list(all_smt(solver))\nfor model in models: print(model)",
          "symPyProgram": "from sympy import Symbol\nfrom sympy import simplify\nfrom sympy.core.relational import Eq, Ne, StrictGreaterThan, StrictLessThan, LessThan, GreaterThan\nfrom sympy.printing import ccode\n\nfile = Symbol('file')\nfile_exists = Symbol('file_exists')\nfile_isDirectory = Symbol('file_isDirectory')\npath_conjunction = (file_exists & file_isDirectory)\nprint(ccode(simplify(path_conjunction)))",
          "soundSymbolic": true,
          "soundBackwards": true,
          "maybe": true,
          "line": 323,
          "throwingLine": 324,
          "isStatic": true,
          "targetOnlyArguments": true
        },
        {
          "qualifiedSignature": "org.apache.commons.io.FileUtils.openOutputStream(java.io.File, boolean)",
          "exception": "throw new IOException(\"File '\" + file + \"' exists but is a directory\");",
          "pathCojunction": "(file.exists()) && (file.isDirectory())",
          "symbolicPathConjunction": "(file.exists()) && (file.isDirectory())",
          "backwardsPathConjunction": "(file.exists()) && (file.isDirectory())",
          "simplifiedPathConjunction": "file.exists() && file.isDirectory()",
          "z3Program": "from z3 import *\nfrom z3_all_models import *\n\nappend0 = Bool('append0')\n\nconstraints = [\n  And(file0.exists(), file0.isDirectory())\n]\n\nsolver = Solver()\nfor constraint in constraints:\n  solver.add(constraint)\n\nmodels = list(all_smt(solver))\nfor model in models: print(model)",
          "symPyProgram": "from sympy import Symbol\nfrom sympy import simplify\nfrom sympy.core.relational import Eq, Ne, StrictGreaterThan, StrictLessThan, LessThan, GreaterThan\nfrom sympy.printing import ccode\n\nfile = Symbol('file')\nfile_exists = Symbol('file_exists')\nfile_isDirectory = Symbol('file_isDirectory')\npath_conjunction = (file_exists & file_isDirectory)\nprint(ccode(simplify(path_conjunction)))",
          "soundSymbolic": false,
          "soundBackwards": true,
          "maybe": true,
          "line": 349,
          "throwingLine": 352,
          "isStatic": true,
          "targetOnlyArguments": true
        },
        {
          "qualifiedSignature": "org.apache.commons.io.FileUtils.openOutputStream(java.io.File, boolean)",
          "exception": "throw new IOException(\"Directory '\" + parent + \"' could not be created\");",
          "pathCojunction": "(!(file.exists())) && (parent != null) && (!parent.mkdirs() && !parent.isDirectory())",
          "symbolicPathConjunction": "(!(file.exists())) && (parent != null) && (!parent.mkdirs() && !parent.isDirectory())",
          "backwardsPathConjunction": "(!(file.exists())) && (file.getParentFile() != null) && (!file.getParentFile().mkdirs() && !file.getParentFile().isDirectory())",
          "simplifiedPathConjunction": "!file.exists() && !file.getParentFile()_isDirectory && !file.getParentFile()_mkdirs && file.getParentFile() != null",
          "z3Program": "from z3 import *\nfrom z3_all_models import *\n\nappend0 = Bool('append0')\nparent0_isNull = Bool('parent0_isNull')\n\nconstraints = [\n  parent0 == file0.getParentFile(),\n  And(And(Not(file0.exists()), Not(parent0_isNull)), And(Not(parent0.mkdirs()), Not(parent0.isDirectory())))\n]\n\nsolver = Solver()\nfor constraint in constraints:\n  solver.add(constraint)\n\nmodels = list(all_smt(solver))\nfor model in models: print(model)",
          "symPyProgram": "from sympy import Symbol\nfrom sympy import simplify\nfrom sympy.core.relational import Eq, Ne, StrictGreaterThan, StrictLessThan, LessThan, GreaterThan\nfrom sympy.printing import ccode\n\nfile = Symbol('file')\nfile_exists = Symbol('file_exists')\nfile_getParentFile = Symbol('file_getParentFile')\nfile_getParentFile_mkdirs = Symbol('file_getParentFile_mkdirs')\nfile_getParentFile_isDirectory = Symbol('file_getParentFile_isDirectory')\nnull = Symbol('null')\npath_conjunction = (((~(file_exists)) & (Ne(file_getParentFile, null))) & ((~(file_getParentFile_mkdirs)) & (~(file_getParentFile_isDirectory))))\nprint(ccode(simplify(path_conjunction)))",
          "soundSymbolic": false,
          "soundBackwards": true,
          "maybe": true,
          "line": 349,
          "throwingLine": 361,
          "isStatic": true,
          "targetOnlyArguments": false
        },
        {
          "qualifiedSignature": "org.apache.commons.io.FileUtils.openOutputStream(java.io.File, boolean)",
          "exception": "throw new IOException(\"File '\" + file + \"' cannot be written to\");",
          "pathCojunction": "(file.exists()) && (!(file.isDirectory())) && (file.canWrite() == false)",
          "symbolicPathConjunction": "(file.exists()) && (!(file.isDirectory())) && (file.canWrite() == false)",
          "backwardsPathConjunction": "(file.exists()) && (!(file.isDirectory())) && (file.canWrite() == false)",
          "simplifiedPathConjunction": "file.exists() && !file.canWrite() && !file.isDirectory()",
          "z3Program": "from z3 import *\nfrom z3_all_models import *\n\nappend0 = Bool('append0')\n\nconstraints = [\n  And(And(file0.exists(), Not(file0.isDirectory())), file0.canWrite() == False)\n]\n\nsolver = Solver()\nfor constraint in constraints:\n  solver.add(constraint)\n\nmodels = list(all_smt(solver))\nfor model in models: print(model)",
          "symPyProgram": "from sympy import Symbol\nfrom sympy import simplify\nfrom sympy.core.relational import Eq, Ne, StrictGreaterThan, StrictLessThan, LessThan, GreaterThan\nfrom sympy.printing import ccode\n\nfile = Symbol('file')\nfile_exists = Symbol('file_exists')\nfile_isDirectory = Symbol('file_isDirectory')\nfile_canWrite = Symbol('file_canWrite')\npath_conjunction = ((file_exists & (~(file_isDirectory))) & (~(file_canWrite)))\nprint(ccode(simplify(path_conjunction)))",
          "soundSymbolic": false,
          "soundBackwards": true,
          "maybe": true,
          "line": 349,
          "throwingLine": 355,
          "isStatic": true,
          "targetOnlyArguments": true
        },
        {
          "qualifiedSignature": "org.apache.commons.io.FileUtils.touch(java.io.File)",
          "exception": "throw new IOException(\"Unable to set the last modification time for \" + file);",
          "pathCojunction": "(!(file.exists())) && (!(success))",
          "symbolicPathConjunction": "(!file.exists()) && (!(success))",
          "backwardsPathConjunction": "(!(file.exists())) && (!(file.setLastModified(System.currentTimeMillis())))",
          "simplifiedPathConjunction": "!file.exists() && !file.setLastModified(System.currentTimeMillis())",
          "z3Program": "from z3 import *\nfrom z3_all_models import *\n\nsuccess0 = Bool('success0')\n\nconstraints = [\n  success0 == file0.setLastModified(System.currentTimeMillis()),\n  And(Not(file0.exists()), Not(success0))\n]\n\nsolver = Solver()\nfor constraint in constraints:\n  solver.add(constraint)\n\nmodels = list(all_smt(solver))\nfor model in models: print(model)",
          "symPyProgram": "from sympy import Symbol\nfrom sympy import simplify\nfrom sympy.core.relational import Eq, Ne, StrictGreaterThan, StrictLessThan, LessThan, GreaterThan\nfrom sympy.printing import ccode\n\nfile = Symbol('file')\nfile_exists = Symbol('file_exists')\nfile_setLastModified = Symbol('file_setLastModified')\nSystem_currentTimeMillis = Symbol('System_currentTimeMillis')\npath_conjunction = ((~(file_exists)) & (~(file_setLastModified)))\nprint(ccode(simplify(path_conjunction)))",
          "soundSymbolic": false,
          "soundBackwards": false,
          "maybe": true,
          "line": 438,
          "throwingLine": 444,
          "isStatic": true,
          "targetOnlyArguments": false
        },
        {
          "qualifiedSignature": "org.apache.commons.io.FileUtils.touch(java.io.File)",
          "exception": "throw new IOException(\"Unable to set the last modification time for \" + file);",
          "pathCojunction": "(!(!file.exists())) && (!(success))",
          "symbolicPathConjunction": "(!(!file.exists())) && (!(success))",
          "backwardsPathConjunction": "(!(!file.exists())) && (!(file.setLastModified(System.currentTimeMillis())))",
          "simplifiedPathConjunction": "file.exists() && !file.setLastModified(System.currentTimeMillis())",
          "z3Program": "from z3 import *\nfrom z3_all_models import *\n\nsuccess0 = Bool('success0')\n\nconstraints = [\n  success0 == file0.setLastModified(System.currentTimeMillis()),\n  And(Not(Not(file0.exists())), Not(success0))\n]\n\nsolver = Solver()\nfor constraint in constraints:\n  solver.add(constraint)\n\nmodels = list(all_smt(solver))\nfor model in models: print(model)",
          "symPyProgram": "from sympy import Symbol\nfrom sympy import simplify\nfrom sympy.core.relational import Eq, Ne, StrictGreaterThan, StrictLessThan, LessThan, GreaterThan\nfrom sympy.printing import ccode\n\nfile = Symbol('file')\nfile_exists = Symbol('file_exists')\nfile_setLastModified = Symbol('file_setLastModified')\nSystem_currentTimeMillis = Symbol('System_currentTimeMillis')\npath_conjunction = ((~((~(file_exists)))) & (~(file_setLastModified)))\nprint(ccode(simplify(path_conjunction)))",
          "soundSymbolic": false,
          "soundBackwards": false,
          "maybe": true,
          "line": 438,
          "throwingLine": 444,
          "isStatic": true,
          "targetOnlyArguments": false
        },
        {
          "qualifiedSignature": "org.apache.commons.io.FileUtils.listFiles(java.io.File, org.apache.commons.io.filefilter.IOFileFilter, org.apache.commons.io.filefilter.IOFileFilter)",
          "exception": "throw new IllegalArgumentException(\"Parameter 'directory' is not a directory: \" + directory);",
          "pathCojunction": "(!(directory.isDirectory()))",
          "symbolicPathConjunction": "(!directory.isDirectory())",
          "backwardsPathConjunction": "(!(directory.isDirectory()))",
          "simplifiedPathConjunction": "!directory.isDirectory()",
          "z3Program": "from z3 import *\nfrom z3_all_models import *\n\n\nconstraints = [\n  Not(directory0.isDirectory())\n]\n\nsolver = Solver()\nfor constraint in constraints:\n  solver.add(constraint)\n\nmodels = list(all_smt(solver))\nfor model in models: print(model)",
          "symPyProgram": "from sympy import Symbol\nfrom sympy import simplify\nfrom sympy.core.relational import Eq, Ne, StrictGreaterThan, StrictLessThan, LessThan, GreaterThan\nfrom sympy.printing import ccode\n\ndirectory = Symbol('directory')\ndirectory_isDirectory = Symbol('directory_isDirectory')\npath_conjunction = (~(directory_isDirectory))\nprint(ccode(simplify(path_conjunction)))",
          "soundSymbolic": true,
          "soundBackwards": true,
          "maybe": true,
          "line": 516,
          "throwingLine": 517,
          "isStatic": true,
          "targetOnlyArguments": true
        },
        {
          "qualifiedSignature": "org.apache.commons.io.FileUtils.listFiles(java.io.File, org.apache.commons.io.filefilter.IOFileFilter, org.apache.commons.io.filefilter.IOFileFilter)",
          "exception": "throw new NullPointerException(\"Parameter 'fileFilter' is null\");",
          "pathCojunction": "(!(!directory.isDirectory())) && (fileFilter == null)",
          "symbolicPathConjunction": "((!(!directory.isDirectory())) && (fileFilter == null))",
          "backwardsPathConjunction": "(!(!directory.isDirectory())) && (fileFilter == null)",
          "simplifiedPathConjunction": "directory.isDirectory() && fileFilter == null",
          "z3Program": "from z3 import *\nfrom z3_all_models import *\n\nfileFilter0_isNull = Bool('fileFilter0_isNull')\n\nconstraints = [\n  And(Not(Not(directory0.isDirectory())), fileFilter0_isNull)\n]\n\nsolver = Solver()\nfor constraint in constraints:\n  solver.add(constraint)\n\nmodels = list(all_smt(solver))\nfor model in models: print(model)",
          "symPyProgram": "from sympy import Symbol\nfrom sympy import simplify\nfrom sympy.core.relational import Eq, Ne, StrictGreaterThan, StrictLessThan, LessThan, GreaterThan\nfrom sympy.printing import ccode\n\ndirectory = Symbol('directory')\nfileFilter = Symbol('fileFilter')\ndirectory_isDirectory = Symbol('directory_isDirectory')\nnull = Symbol('null')\npath_conjunction = ((~((~(directory_isDirectory)))) & (Eq(fileFilter, null)))\nprint(ccode(simplify(path_conjunction)))",
          "soundSymbolic": true,
          "soundBackwards": true,
          "maybe": true,
          "line": 516,
          "throwingLine": 517,
          "isStatic": true,
          "targetOnlyArguments": true
        },
        {
          "qualifiedSignature": "org.apache.commons.io.FileUtils.listFilesAndDirs(java.io.File, org.apache.commons.io.filefilter.IOFileFilter, org.apache.commons.io.filefilter.IOFileFilter)",
          "exception": "throw new IllegalArgumentException(\"Parameter 'directory' is not a directory: \" + directory);",
          "pathCojunction": "(!(directory.isDirectory()))",
          "symbolicPathConjunction": "(!directory.isDirectory())",
          "backwardsPathConjunction": "(!(directory.isDirectory()))",
          "simplifiedPathConjunction": "!directory.isDirectory()",
          "z3Program": "from z3 import *\nfrom z3_all_models import *\n\n\nconstraints = [\n  Not(directory0.isDirectory())\n]\n\nsolver = Solver()\nfor constraint in constraints:\n  solver.add(constraint)\n\nmodels = list(all_smt(solver))\nfor model in models: print(model)",
          "symPyProgram": "from sympy import Symbol\nfrom sympy import simplify\nfrom sympy.core.relational import Eq, Ne, StrictGreaterThan, StrictLessThan, LessThan, GreaterThan\nfrom sympy.printing import ccode\n\ndirectory = Symbol('directory')\ndirectory_isDirectory = Symbol('directory_isDirectory')\npath_conjunction = (~(directory_isDirectory))\nprint(ccode(simplify(path_conjunction)))",
          "soundSymbolic": true,
          "soundBackwards": true,
          "maybe": true,
          "line": 589,
          "throwingLine": 590,
          "isStatic": true,
          "targetOnlyArguments": true
        },
        {
          "qualifiedSignature": "org.apache.commons.io.FileUtils.listFilesAndDirs(java.io.File, org.apache.commons.io.filefilter.IOFileFilter, org.apache.commons.io.filefilter.IOFileFilter)",
          "exception": "throw new NullPointerException(\"Parameter 'fileFilter' is null\");",
          "pathCojunction": "(!(!directory.isDirectory())) && (fileFilter == null)",
          "symbolicPathConjunction": "((!(!directory.isDirectory())) && (fileFilter == null))",
          "backwardsPathConjunction": "(!(!directory.isDirectory())) && (fileFilter == null)",
          "simplifiedPathConjunction": "directory.isDirectory() && fileFilter == null",
          "z3Program": "from z3 import *\nfrom z3_all_models import *\n\nfileFilter0_isNull = Bool('fileFilter0_isNull')\n\nconstraints = [\n  And(Not(Not(directory0.isDirectory())), fileFilter0_isNull)\n]\n\nsolver = Solver()\nfor constraint in constraints:\n  solver.add(constraint)\n\nmodels = list(all_smt(solver))\nfor model in models: print(model)",
          "symPyProgram": "from sympy import Symbol\nfrom sympy import simplify\nfrom sympy.core.relational import Eq, Ne, StrictGreaterThan, StrictLessThan, LessThan, GreaterThan\nfrom sympy.printing import ccode\n\ndirectory = Symbol('directory')\nfileFilter = Symbol('fileFilter')\ndirectory_isDirectory = Symbol('directory_isDirectory')\nnull = Symbol('null')\npath_conjunction = ((~((~(directory_isDirectory)))) & (Eq(fileFilter, null)))\nprint(ccode(simplify(path_conjunction)))",
          "soundSymbolic": true,
          "soundBackwards": true,
          "maybe": true,
          "line": 589,
          "throwingLine": 590,
          "isStatic": true,
          "targetOnlyArguments": true
        },
        {
          "qualifiedSignature": "org.apache.commons.io.FileUtils.listFiles(java.io.File, java.lang.String[], boolean)",
          "exception": "throw new IllegalArgumentException(\"Parameter 'directory' is not a directory: \" + directory)",
          "pathCojunction": "(!(extensions == null)) && (!(0 < extensions.length)) && (!(directory.isDirectory()))",
          "symbolicPathConjunction": "(!(extensions == null)) && (!(0 < extensions.length)) && (listFiles(directory, filter, recursive ? TrueFileFilter.INSTANCE : FalseFileFilter.INSTANCE))",
          "backwardsPathConjunction": "(!(extensions == null)) && (!(0 < extensions.length)) && (!(directory.isDirectory()))",
          "simplifiedPathConjunction": "extensions.length <= 0 && !directory.isDirectory() && extensions != null",
          "z3Program": "from z3 import *\nfrom z3_all_models import *\n\nrecursive0 = Bool('recursive0')\nextensions0_isNull = Bool('extensions0_isNull')\nextensions0_length = Int('extensions0_length')\n\nconstraints = [\n  suffixes0 == new String[extensions0_length],\n  suffixes1 == suffixes0,\n  filter1 == new SuffixFileFilter(suffixes1),\n  extensions0_length >= 0, # implicit\n  And(And(Not(extensions0_isNull), Not(0 < extensions0_length)), Not(directory0.isDirectory()))\n]\n\nsolver = Solver()\nfor constraint in constraints:\n  solver.add(constraint)\n\nmodels = list(all_smt(solver))\nfor model in models: print(model)",
          "symPyProgram": "from sympy import Symbol\nfrom sympy import simplify\nfrom sympy.core.relational import Eq, Ne, StrictGreaterThan, StrictLessThan, LessThan, GreaterThan\nfrom sympy.printing import ccode\n\ndirectory = Symbol('directory')\nextensions = Symbol('extensions')\nextensions_length = Symbol('extensions_length', integer=True)\ndirectory_isDirectory = Symbol('directory_isDirectory')\nnull = Symbol('null')\npath_conjunction = (((~((Eq(extensions, null)))) & (~((StrictLessThan(0, extensions_length))))) & (~(directory_isDirectory)))\nprint(ccode(simplify(path_conjunction)))",
          "soundSymbolic": true,
          "soundBackwards": true,
          "maybe": true,
          "line": 681,
          "throwingLine": 689,
          "isStatic": true,
          "targetOnlyArguments": true
        },
        {
          "qualifiedSignature": "org.apache.commons.io.FileUtils.listFiles(java.io.File, java.lang.String[], boolean)",
          "exception": "throw new IllegalArgumentException(\"Parameter 'directory' is not a directory: \" + directory)",
          "pathCojunction": "(!(extensions == null)) && (0 < extensions.length) && (!(directory.isDirectory()))",
          "symbolicPathConjunction": "(!(extensions == null)) && (0 < extensions.length) && (listFiles(directory, filter, recursive ? TrueFileFilter.INSTANCE : FalseFileFilter.INSTANCE))",
          "backwardsPathConjunction": "(!(extensions == null)) && (0 < extensions.length) && (!(directory.isDirectory()))",
          "simplifiedPathConjunction": "!directory.isDirectory() && extensions.length > 0 && extensions != null",
          "z3Program": "from z3 import *\nfrom z3_all_models import *\n\nrecursive0 = Bool('recursive0')\nextensions0_isNull = Bool('extensions0_isNull')\nextensions0_length = Int('extensions0_length')\n\nconstraints = [\n  suffixes0 == new String[extensions0_length],\n  suffixes1 == suffixes0,\n  filter1 == new SuffixFileFilter(suffixes1),\n  extensions0_length >= 0, # implicit\n  And(And(Not(extensions0_isNull), 0 < extensions0_length), Not(directory0.isDirectory()))\n]\n\nsolver = Solver()\nfor constraint in constraints:\n  solver.add(constraint)\n\nmodels = list(all_smt(solver))\nfor model in models: print(model)",
          "symPyProgram": "from sympy import Symbol\nfrom sympy import simplify\nfrom sympy.core.relational import Eq, Ne, StrictGreaterThan, StrictLessThan, LessThan, GreaterThan\nfrom sympy.printing import ccode\n\ndirectory = Symbol('directory')\nextensions = Symbol('extensions')\nextensions_length = Symbol('extensions_length', integer=True)\ndirectory_isDirectory = Symbol('directory_isDirectory')\nnull = Symbol('null')\npath_conjunction = (((~((Eq(extensions, null)))) & (StrictLessThan(0, extensions_length))) & (~(directory_isDirectory)))\nprint(ccode(simplify(path_conjunction)))",
          "soundSymbolic": true,
          "soundBackwards": true,
          "maybe": true,
          "line": 681,
          "throwingLine": 689,
          "isStatic": true,
          "targetOnlyArguments": true
        },
        {
          "qualifiedSignature": "org.apache.commons.io.FileUtils.listFiles(java.io.File, java.lang.String[], boolean)",
          "exception": "throw new IllegalArgumentException(\"Parameter 'directory' is not a directory: \" + directory)",
          "pathCojunction": "(extensions == null) && (!(directory.isDirectory()))",
          "symbolicPathConjunction": "(extensions == null) && (listFiles(directory, filter, recursive ? TrueFileFilter.INSTANCE : FalseFileFilter.INSTANCE))",
          "backwardsPathConjunction": "(extensions == null) && (!(directory.isDirectory()))",
          "simplifiedPathConjunction": "extensions == null && !directory.isDirectory()",
          "z3Program": "from z3 import *\nfrom z3_all_models import *\n\nrecursive0 = Bool('recursive0')\nextensions0_isNull = Bool('extensions0_isNull')\n\nconstraints = [\n  filter1 == TrueFileFilter.INSTANCE,\n  And(extensions0_isNull, Not(directory0.isDirectory()))\n]\n\nsolver = Solver()\nfor constraint in constraints:\n  solver.add(constraint)\n\nmodels = list(all_smt(solver))\nfor model in models: print(model)",
          "symPyProgram": "from sympy import Symbol\nfrom sympy import simplify\nfrom sympy.core.relational import Eq, Ne, StrictGreaterThan, StrictLessThan, LessThan, GreaterThan\nfrom sympy.printing import ccode\n\ndirectory = Symbol('directory')\nextensions = Symbol('extensions')\ndirectory_isDirectory = Symbol('directory_isDirectory')\nnull = Symbol('null')\npath_conjunction = ((Eq(extensions, null)) & (~(directory_isDirectory)))\nprint(ccode(simplify(path_conjunction)))",
          "soundSymbolic": true,
          "soundBackwards": true,
          "maybe": true,
          "line": 681,
          "throwingLine": 689,
          "isStatic": true,
          "targetOnlyArguments": true
        },
        {
          "qualifiedSignature": "org.apache.commons.io.FileUtils.listFiles(java.io.File, java.lang.String[], boolean)",
          "exception": "throw new NullPointerException(\"Parameter 'fileFilter' is null\")",
          "pathCojunction": "(extensions == null) && (!(!directory.isDirectory())) && (filter == null)",
          "symbolicPathConjunction": "(extensions == null) && (listFiles(directory, filter, recursive ? TrueFileFilter.INSTANCE : FalseFileFilter.INSTANCE))",
          "backwardsPathConjunction": "(extensions == null) && (!(!directory.isDirectory())) && (TrueFileFilter.INSTANCE == null)",
          "z3Program": "from z3 import *\nfrom z3_all_models import *\n\nrecursive0 = Bool('recursive0')\nextensions0_isNull = Bool('extensions0_isNull')\nfilter1_isNull = Bool('filter1_isNull')\n\nconstraints = [\n  filter1 == TrueFileFilter.INSTANCE,\n  And(And(extensions0_isNull, Not(Not(directory0.isDirectory()))), filter1_isNull)\n]\n\nsolver = Solver()\nfor constraint in constraints:\n  solver.add(constraint)\n\nmodels = list(all_smt(solver))\nfor model in models: print(model)",
          "soundSymbolic": true,
          "soundBackwards": false,
          "maybe": true,
          "line": 681,
          "throwingLine": 689,
          "isStatic": true,
          "targetOnlyArguments": false
        },
        {
          "qualifiedSignature": "org.apache.commons.io.FileUtils.listFiles(java.io.File, java.lang.String[], boolean)",
          "exception": "throw new NullPointerException(\"Parameter 'fileFilter' is null\")",
          "pathCojunction": "(!(extensions == null)) && (0 < extensions.length) && (!(!directory.isDirectory())) && (filter == null)",
          "symbolicPathConjunction": "(!(extensions == null)) && (0 < extensions.length) && (listFiles(directory, filter, recursive ? TrueFileFilter.INSTANCE : FalseFileFilter.INSTANCE))",
          "backwardsPathConjunction": "(!(extensions == null)) && (0 < extensions.length) && (!(!directory.isDirectory())) && (new SuffixFileFilter(suffixes) == null)",
          "z3Program": "from z3 import *\nfrom z3_all_models import *\n\nrecursive0 = Bool('recursive0')\nextensions0_isNull = Bool('extensions0_isNull')\nfilter1_isNull = Bool('filter1_isNull')\nextensions0_length = Int('extensions0_length')\n\nconstraints = [\n  suffixes0 == new String[extensions0_length],\n  suffixes1 == suffixes0,\n  filter1 == new SuffixFileFilter(suffixes1),\n  extensions0_length >= 0, # implicit\n  And(And(And(Not(extensions0_isNull), 0 < extensions0_length), Not(Not(directory0.isDirectory()))), filter1_isNull)\n]\n\nsolver = Solver()\nfor constraint in constraints:\n  solver.add(constraint)\n\nmodels = list(all_smt(solver))\nfor model in models: print(model)",
          "soundSymbolic": true,
          "soundBackwards": false,
          "maybe": true,
          "line": 681,
          "throwingLine": 689,
          "isStatic": true,
          "targetOnlyArguments": false
        },
        {
          "qualifiedSignature": "org.apache.commons.io.FileUtils.listFiles(java.io.File, java.lang.String[], boolean)",
          "exception": "throw new NullPointerException(\"Parameter 'fileFilter' is null\")",
          "pathCojunction": "(!(extensions == null)) && (!(0 < extensions.length)) && (!(!directory.isDirectory())) && (filter == null)",
          "symbolicPathConjunction": "(!(extensions == null)) && (!(0 < extensions.length)) && (listFiles(directory, filter, recursive ? TrueFileFilter.INSTANCE : FalseFileFilter.INSTANCE))",
          "backwardsPathConjunction": "(!(extensions == null)) && (!(0 < extensions.length)) && (!(!directory.isDirectory())) && (new SuffixFileFilter(suffixes) == null)",
          "z3Program": "from z3 import *\nfrom z3_all_models import *\n\nrecursive0 = Bool('recursive0')\nextensions0_isNull = Bool('extensions0_isNull')\nfilter1_isNull = Bool('filter1_isNull')\nextensions0_length = Int('extensions0_length')\n\nconstraints = [\n  suffixes0 == new String[extensions0_length],\n  suffixes1 == suffixes0,\n  filter1 == new SuffixFileFilter(suffixes1),\n  extensions0_length >= 0, # implicit\n  And(And(And(Not(extensions0_isNull), Not(0 < extensions0_length)), Not(Not(directory0.isDirectory()))), filter1_isNull)\n]\n\nsolver = Solver()\nfor constraint in constraints:\n  solver.add(constraint)\n\nmodels = list(all_smt(solver))\nfor model in models: print(model)",
          "soundSymbolic": true,
          "soundBackwards": false,
          "maybe": true,
          "line": 681,
          "throwingLine": 689,
          "isStatic": true,
          "targetOnlyArguments": false
        },
        {
          "qualifiedSignature": "org.apache.commons.io.FileUtils.toFiles(java.net.URL[])",
          "exception": "throw new IllegalArgumentException(\"URL could not be converted to a File: \" + url);",
          "pathCojunction": "(!(urls == null || urls.length == 0)) && (i < urls.length) && (url != null) && (url.getProtocol().equals(\"file\") == false)",
          "symbolicPathConjunction": "(!(urls == null || urls.length == 0)) && (i < urls.length) && (url != null) && (url.getProtocol().equals(\"file\") == false)",
          "backwardsPathConjunction": "(!(urls == null || urls.length == 0)) && (0 < urls.length) && (urls[0] != null) && (urls[0].getProtocol().equals(\"file\") == false)",
          "z3Program": "from z3 import *\nfrom z3_all_models import *\n\ni0 = Int('i0')\nurls0_isNull = Bool('urls0_isNull')\nurl0_isNull = Bool('url0_isNull')\nurls0_length = Int('urls0_length')\n\nconstraints = [\n  files0 == new File[urls0_length],\n  i0 == 0,\n  url0 == urls0[i0],\n  urls0_length >= 0, # implicit\n  And(And(And(Not(Or(urls0_isNull, urls0_length == 0)), i0 < urls0_length), Not(url0_isNull)), url0.getProtocol().equals(\"file\") == False)\n]\n\nsolver = Solver()\nfor constraint in constraints:\n  solver.add(constraint)\n\nmodels = list(all_smt(solver))\nfor model in models: print(model)",
          "soundSymbolic": false,
          "soundBackwards": true,
          "maybe": true,
          "line": 900,
          "throwingLine": 909,
          "isStatic": true,
          "targetOnlyArguments": false
        },
        {
          "qualifiedSignature": "org.apache.commons.io.FileUtils.copyFileToDirectory(java.io.File, java.io.File)",
          "exception": "throw new NullPointerException(\"Source must not be null\")",
          "pathCojunction": "(!(destDir == null)) && (!(destDir.exists() && destDir.isDirectory() == false)) && (srcFile == null)",
          "symbolicPathConjunction": "(copyFileToDirectory(srcFile, destDir, true))",
          "backwardsPathConjunction": "(!(destDir == null)) && (!(destDir.exists() && destDir.isDirectory() == false)) && (srcFile == null)",
          "simplifiedPathConjunction": "null == srcFile && (destDir.isDirectory() || !destDir.exists()) && destDir != null",
          "z3Program": "from z3 import *\nfrom z3_all_models import *\n\ndestDir0_isNull = Bool('destDir0_isNull')\nsrcFile0_isNull = Bool('srcFile0_isNull')\n\nconstraints = [\n  And(And(Not(destDir0_isNull), Not(And(destDir0.exists(), destDir0.isDirectory() == False))), srcFile0_isNull)\n]\n\nsolver = Solver()\nfor constraint in constraints:\n  solver.add(constraint)\n\nmodels = list(all_smt(solver))\nfor model in models: print(model)",
          "symPyProgram": "from sympy import Symbol\nfrom sympy import simplify\nfrom sympy.core.relational import Eq, Ne, StrictGreaterThan, StrictLessThan, LessThan, GreaterThan\nfrom sympy.printing import ccode\n\nsrcFile = Symbol('srcFile')\ndestDir = Symbol('destDir')\ndestDir_exists = Symbol('destDir_exists')\ndestDir_isDirectory = Symbol('destDir_isDirectory')\nnull = Symbol('null')\npath_conjunction = (((~((Eq(destDir, null)))) & (~((destDir_exists & (~(destDir_isDirectory)))))) & (Eq(srcFile, null)))\nprint(ccode(simplify(path_conjunction)))",
          "soundSymbolic": true,
          "soundBackwards": true,
          "maybe": true,
          "line": 960,
          "throwingLine": 961,
          "isStatic": true,
          "targetOnlyArguments": true
        },
        {
          "qualifiedSignature": "org.apache.commons.io.FileUtils.copyFileToDirectory(java.io.File, java.io.File)",
          "exception": "throw new NullPointerException(\"Destination must not be null\")",
          "pathCojunction": "(destDir == null)",
          "symbolicPathConjunction": "(copyFileToDirectory(srcFile, destDir, true))",
          "backwardsPathConjunction": "(destDir == null)",
          "simplifiedPathConjunction": "destDir == null",
          "z3Inputs": "[destDir0_isNull = True]\n",
          "z3Program": "from z3 import *\nfrom z3_all_models import *\n\ndestDir0_isNull = Bool('destDir0_isNull')\n\nconstraints = [\n  destDir0_isNull\n]\n\nsolver = Solver()\nfor constraint in constraints:\n  solver.add(constraint)\n\nmodels = list(all_smt(solver))\nfor model in models: print(model)",
          "symPyProgram": "from sympy import Symbol\nfrom sympy import simplify\nfrom sympy.core.relational import Eq, Ne, StrictGreaterThan, StrictLessThan, LessThan, GreaterThan\nfrom sympy.printing import ccode\n\ndestDir = Symbol('destDir')\nnull = Symbol('null')\npath_conjunction = (Eq(destDir, null))\nprint(ccode(simplify(path_conjunction)))",
          "soundSymbolic": true,
          "soundBackwards": true,
          "maybe": false,
          "line": 960,
          "throwingLine": 961,
          "isStatic": true,
          "targetOnlyArguments": true
        },
        {
          "qualifiedSignature": "org.apache.commons.io.FileUtils.copyFileToDirectory(java.io.File, java.io.File)",
          "exception": "throw new IllegalArgumentException(\"Destination '\" + destDir + \"' is not a directory\")",
          "pathCojunction": "(!(destDir == null)) && (destDir.exists() && destDir.isDirectory() == false)",
          "symbolicPathConjunction": "(copyFileToDirectory(srcFile, destDir, true))",
          "backwardsPathConjunction": "(!(destDir == null)) && (destDir.exists() && destDir.isDirectory() == false)",
          "simplifiedPathConjunction": "destDir.exists() && !destDir.isDirectory() && destDir != null",
          "z3Program": "from z3 import *\nfrom z3_all_models import *\n\ndestDir0_isNull = Bool('destDir0_isNull')\n\nconstraints = [\n  And(Not(destDir0_isNull), And(destDir0.exists(), destDir0.isDirectory() == False))\n]\n\nsolver = Solver()\nfor constraint in constraints:\n  solver.add(constraint)\n\nmodels = list(all_smt(solver))\nfor model in models: print(model)",
          "symPyProgram": "from sympy import Symbol\nfrom sympy import simplify\nfrom sympy.core.relational import Eq, Ne, StrictGreaterThan, StrictLessThan, LessThan, GreaterThan\nfrom sympy.printing import ccode\n\ndestDir = Symbol('destDir')\ndestDir_exists = Symbol('destDir_exists')\ndestDir_isDirectory = Symbol('destDir_isDirectory')\nnull = Symbol('null')\npath_conjunction = ((~((Eq(destDir, null)))) & (destDir_exists & (~(destDir_isDirectory))))\nprint(ccode(simplify(path_conjunction)))",
          "soundSymbolic": true,
          "soundBackwards": true,
          "maybe": true,
          "line": 960,
          "throwingLine": 961,
          "isStatic": true,
          "targetOnlyArguments": true
        },
        {
          "qualifiedSignature": "org.apache.commons.io.FileUtils.copyFileToDirectory(java.io.File, java.io.File, boolean)",
          "exception": "throw new NullPointerException(\"Destination must not be null\");",
          "pathCojunction": "(destDir == null)",
          "symbolicPathConjunction": "(destDir == null)",
          "backwardsPathConjunction": "(destDir == null)",
          "simplifiedPathConjunction": "destDir == null",
          "z3Inputs": "[destDir0_isNull = True]\n",
          "z3Program": "from z3 import *\nfrom z3_all_models import *\n\npreserveFileDate0 = Bool('preserveFileDate0')\ndestDir0_isNull = Bool('destDir0_isNull')\n\nconstraints = [\n  destDir0_isNull\n]\n\nsolver = Solver()\nfor constraint in constraints:\n  solver.add(constraint)\n\nmodels = list(all_smt(solver))\nfor model in models: print(model)",
          "symPyProgram": "from sympy import Symbol\nfrom sympy import simplify\nfrom sympy.core.relational import Eq, Ne, StrictGreaterThan, StrictLessThan, LessThan, GreaterThan\nfrom sympy.printing import ccode\n\ndestDir = Symbol('destDir')\nnull = Symbol('null')\npath_conjunction = (Eq(destDir, null))\nprint(ccode(simplify(path_conjunction)))",
          "soundSymbolic": true,
          "soundBackwards": true,
          "maybe": false,
          "line": 992,
          "throwingLine": 994,
          "isStatic": true,
          "targetOnlyArguments": true
        },
        {
          "qualifiedSignature": "org.apache.commons.io.FileUtils.copyFileToDirectory(java.io.File, java.io.File, boolean)",
          "exception": "throw new NullPointerException(\"Destination must not be null\")",
          "pathCojunction": "(!(destDir == null)) && (!(destDir.exists() && destDir.isDirectory() == false)) && (!(srcFile == null)) && (destFile == null)",
          "symbolicPathConjunction": "(!(destDir == null)) && (!(destDir.exists() && destDir.isDirectory() == false)) && (copyFile(srcFile, destFile, preserveFileDate))",
          "backwardsPathConjunction": "(!(destDir == null)) && (!(destDir.exists() && destDir.isDirectory() == false)) && (!(srcFile == null)) && (new File(destDir, srcFile.getName()) == null)",
          "z3Program": "from z3 import *\nfrom z3_all_models import *\n\npreserveFileDate0 = Bool('preserveFileDate0')\ndestDir0_isNull = Bool('destDir0_isNull')\nsrcFile0_isNull = Bool('srcFile0_isNull')\ndestFile0_isNull = Bool('destFile0_isNull')\n\nconstraints = [\n  destFile0 == new File(destDir0, srcFile0.getName()),\n  And(And(And(Not(destDir0_isNull), Not(And(destDir0.exists(), destDir0.isDirectory() == False))), Not(srcFile0_isNull)), destFile0_isNull)\n]\n\nsolver = Solver()\nfor constraint in constraints:\n  solver.add(constraint)\n\nmodels = list(all_smt(solver))\nfor model in models: print(model)",
          "soundSymbolic": false,
          "soundBackwards": true,
          "maybe": true,
          "line": 992,
          "throwingLine": 1000,
          "isStatic": true,
          "targetOnlyArguments": false
        },
        {
          "qualifiedSignature": "org.apache.commons.io.FileUtils.copyFileToDirectory(java.io.File, java.io.File, boolean)",
          "exception": "throw new NullPointerException(\"Source must not be null\")",
          "pathCojunction": "(!(destDir == null)) && (!(destDir.exists() && destDir.isDirectory() == false)) && (srcFile == null)",
          "symbolicPathConjunction": "(!(destDir == null)) && (!(destDir.exists() && destDir.isDirectory() == false)) && (copyFile(srcFile, destFile, preserveFileDate))",
          "backwardsPathConjunction": "(!(destDir == null)) && (!(destDir.exists() && destDir.isDirectory() == false)) && (srcFile == null)",
          "simplifiedPathConjunction": "null == srcFile && (destDir.isDirectory() || !destDir.exists()) && destDir != null",
          "z3Program": "from z3 import *\nfrom z3_all_models import *\n\npreserveFileDate0 = Bool('preserveFileDate0')\ndestDir0_isNull = Bool('destDir0_isNull')\nsrcFile0_isNull = Bool('srcFile0_isNull')\n\nconstraints = [\n  destFile0 == new File(destDir0, srcFile0.getName()),\n  And(And(Not(destDir0_isNull), Not(And(destDir0.exists(), destDir0.isDirectory() == False))), srcFile0_isNull)\n]\n\nsolver = Solver()\nfor constraint in constraints:\n  solver.add(constraint)\n\nmodels = list(all_smt(solver))\nfor model in models: print(model)",
          "symPyProgram": "from sympy import Symbol\nfrom sympy import simplify\nfrom sympy.core.relational import Eq, Ne, StrictGreaterThan, StrictLessThan, LessThan, GreaterThan\nfrom sympy.printing import ccode\n\nsrcFile = Symbol('srcFile')\ndestDir = Symbol('destDir')\ndestDir_exists = Symbol('destDir_exists')\ndestDir_isDirectory = Symbol('destDir_isDirectory')\nnull = Symbol('null')\npath_conjunction = (((~((Eq(destDir, null)))) & (~((destDir_exists & (~(destDir_isDirectory)))))) & (Eq(srcFile, null)))\nprint(ccode(simplify(path_conjunction)))",
          "soundSymbolic": false,
          "soundBackwards": true,
          "maybe": true,
          "line": 992,
          "throwingLine": 1000,
          "isStatic": true,
          "targetOnlyArguments": true
        },
        {
          "qualifiedSignature": "org.apache.commons.io.FileUtils.copyFileToDirectory(java.io.File, java.io.File, boolean)",
          "exception": "throw new IOException(\"Source '\" + srcFile + \"' exists but is a directory\");",
          "pathCojunction": "(!(destDir == null)) && (!(destDir.exists() && destDir.isDirectory() == false)) && (!(srcFile == null)) && (!(destFile == null)) && (!(!srcFile.exists())) && (srcFile.isDirectory())",
          "symbolicPathConjunction": "(!(destDir == null)) && (!(destDir.exists() && destDir.isDirectory() == false)) && (copyFile(srcFile, destFile, preserveFileDate))",
          "backwardsPathConjunction": "(!(destDir == null)) && (!(destDir.exists() && destDir.isDirectory() == false)) && (!(srcFile == null)) && (!(new File(destDir, srcFile.getName()) == null)) && (!(!srcFile.exists())) && (srcFile.isDirectory())",
          "z3Program": "from z3 import *\nfrom z3_all_models import *\n\npreserveFileDate0 = Bool('preserveFileDate0')\ndestDir0_isNull = Bool('destDir0_isNull')\nsrcFile0_isNull = Bool('srcFile0_isNull')\ndestFile0_isNull = Bool('destFile0_isNull')\n\nconstraints = [\n  destFile0 == new File(destDir0, srcFile0.getName()),\n  And(And(And(And(And(Not(destDir0_isNull), Not(And(destDir0.exists(), destDir0.isDirectory() == False))), Not(srcFile0_isNull)), Not(destFile0_isNull)), Not(Not(srcFile0.exists()))), srcFile0.isDirectory())\n]\n\nsolver = Solver()\nfor constraint in constraints:\n  solver.add(constraint)\n\nmodels = list(all_smt(solver))\nfor model in models: print(model)",
          "soundSymbolic": false,
          "soundBackwards": true,
          "maybe": true,
          "line": 992,
          "throwingLine": 1000,
          "isStatic": true,
          "targetOnlyArguments": false
        },
        {
          "qualifiedSignature": "org.apache.commons.io.FileUtils.copyFileToDirectory(java.io.File, java.io.File, boolean)",
          "exception": "throw new IllegalArgumentException(\"Destination '\" + destDir + \"' is not a directory\");",
          "pathCojunction": "(!(destDir == null)) && (destDir.exists() && destDir.isDirectory() == false)",
          "symbolicPathConjunction": "(!(destDir == null)) && (destDir.exists() && destDir.isDirectory() == false)",
          "backwardsPathConjunction": "(!(destDir == null)) && (destDir.exists() && destDir.isDirectory() == false)",
          "simplifiedPathConjunction": "destDir.exists() && !destDir.isDirectory() && destDir != null",
          "z3Program": "from z3 import *\nfrom z3_all_models import *\n\npreserveFileDate0 = Bool('preserveFileDate0')\ndestDir0_isNull = Bool('destDir0_isNull')\n\nconstraints = [\n  And(Not(destDir0_isNull), And(destDir0.exists(), destDir0.isDirectory() == False))\n]\n\nsolver = Solver()\nfor constraint in constraints:\n  solver.add(constraint)\n\nmodels = list(all_smt(solver))\nfor model in models: print(model)",
          "symPyProgram": "from sympy import Symbol\nfrom sympy import simplify\nfrom sympy.core.relational import Eq, Ne, StrictGreaterThan, StrictLessThan, LessThan, GreaterThan\nfrom sympy.printing import ccode\n\ndestDir = Symbol('destDir')\ndestDir_exists = Symbol('destDir_exists')\ndestDir_isDirectory = Symbol('destDir_isDirectory')\nnull = Symbol('null')\npath_conjunction = ((~((Eq(destDir, null)))) & (destDir_exists & (~(destDir_isDirectory))))\nprint(ccode(simplify(path_conjunction)))",
          "soundSymbolic": false,
          "soundBackwards": true,
          "maybe": true,
          "line": 992,
          "throwingLine": 997,
          "isStatic": true,
          "targetOnlyArguments": true
        },
        {
          "qualifiedSignature": "org.apache.commons.io.FileUtils.copyFileToDirectory(java.io.File, java.io.File, boolean)",
          "exception": "throw new IOException(\"Source '\" + srcFile + \"' and destination '\" + destFile + \"' are the same\");",
          "pathCojunction": "(!(destDir == null)) && (!(destDir.exists() && destDir.isDirectory() == false)) && (!(srcFile == null)) && (!(destFile == null)) && (!(!srcFile.exists())) && (!(srcFile.isDirectory())) && (srcFile.getCanonicalPath().equals(destFile.getCanonicalPath()))",
          "symbolicPathConjunction": "(!(destDir == null)) && (!(destDir.exists() && destDir.isDirectory() == false)) && (copyFile(srcFile, destFile, preserveFileDate))",
          "backwardsPathConjunction": "(!(destDir == null)) && (!(destDir.exists() && destDir.isDirectory() == false)) && (!(srcFile == null)) && (!(new File(destDir, srcFile.getName()) == null)) && (!(!srcFile.exists())) && (!(srcFile.isDirectory())) && (srcFile.getCanonicalPath().equals(new File(destDir, srcFile.getName()).getCanonicalPath()))",
          "z3Program": "from z3 import *\nfrom z3_all_models import *\n\npreserveFileDate0 = Bool('preserveFileDate0')\ndestDir0_isNull = Bool('destDir0_isNull')\nsrcFile0_isNull = Bool('srcFile0_isNull')\ndestFile0_isNull = Bool('destFile0_isNull')\n\nconstraints = [\n  destFile0 == new File(destDir0, srcFile0.getName()),\n  And(And(And(And(And(And(Not(destDir0_isNull), Not(And(destDir0.exists(), destDir0.isDirectory() == False))), Not(srcFile0_isNull)), Not(destFile0_isNull)), Not(Not(srcFile0.exists()))), Not(srcFile0.isDirectory())), srcFile0.getCanonicalPath().equals(destFile0.getCanonicalPath()))\n]\n\nsolver = Solver()\nfor constraint in constraints:\n  solver.add(constraint)\n\nmodels = list(all_smt(solver))\nfor model in models: print(model)",
          "soundSymbolic": false,
          "soundBackwards": true,
          "maybe": true,
          "line": 992,
          "throwingLine": 1000,
          "isStatic": true,
          "targetOnlyArguments": false
        },
        {
          "qualifiedSignature": "org.apache.commons.io.FileUtils.copyFileToDirectory(java.io.File, java.io.File, boolean)",
          "exception": "throw new FileNotFoundException(\"Source '\" + srcFile + \"' does not exist\")",
          "pathCojunction": "(!(destDir == null)) && (!(destDir.exists() && destDir.isDirectory() == false)) && (!(srcFile == null)) && (!(destFile == null)) && (!(srcFile.exists()))",
          "symbolicPathConjunction": "(!(destDir == null)) && (!(destDir.exists() && destDir.isDirectory() == false)) && (copyFile(srcFile, destFile, preserveFileDate))",
          "backwardsPathConjunction": "(!(destDir == null)) && (!(destDir.exists() && destDir.isDirectory() == false)) && (!(srcFile == null)) && (!(new File(destDir, srcFile.getName()) == null)) && (!(srcFile.exists()))",
          "z3Program": "from z3 import *\nfrom z3_all_models import *\n\npreserveFileDate0 = Bool('preserveFileDate0')\ndestDir0_isNull = Bool('destDir0_isNull')\nsrcFile0_isNull = Bool('srcFile0_isNull')\ndestFile0_isNull = Bool('destFile0_isNull')\n\nconstraints = [\n  destFile0 == new File(destDir0, srcFile0.getName()),\n  And(And(And(And(Not(destDir0_isNull), Not(And(destDir0.exists(), destDir0.isDirectory() == False))), Not(srcFile0_isNull)), Not(destFile0_isNull)), Not(srcFile0.exists()))\n]\n\nsolver = Solver()\nfor constraint in constraints:\n  solver.add(constraint)\n\nmodels = list(all_smt(solver))\nfor model in models: print(model)",
          "soundSymbolic": false,
          "soundBackwards": true,
          "maybe": true,
          "line": 992,
          "throwingLine": 1000,
          "isStatic": true,
          "targetOnlyArguments": false
        },
        {
          "qualifiedSignature": "org.apache.commons.io.FileUtils.copyFile(java.io.File, java.io.File)",
          "exception": "throw new IOException(\"Source '\" + srcFile + \"' and destination '\" + destFile + \"' are the same\")",
          "pathCojunction": "(!(srcFile == null)) && (!(destFile == null)) && (!(!srcFile.exists())) && (!(srcFile.isDirectory())) && (srcFile.getCanonicalPath().equals(destFile.getCanonicalPath()))",
          "symbolicPathConjunction": "(copyFile(srcFile, destFile, true))",
          "backwardsPathConjunction": "(!(srcFile == null)) && (!(destFile == null)) && (!(!srcFile.exists())) && (!(srcFile.isDirectory())) && (srcFile.getCanonicalPath().equals(destFile.getCanonicalPath()))",
          "simplifiedPathConjunction": "srcFile.exists() && srcFile.getCanonicalPath().equals(destFile.getCanonicalPath()) && !srcFile.isDirectory() && destFile != null && null != srcFile",
          "z3Program": "from z3 import *\nfrom z3_all_models import *\n\nsrcFile0_isNull = Bool('srcFile0_isNull')\ndestFile0_isNull = Bool('destFile0_isNull')\n\nconstraints = [\n  And(And(And(And(Not(srcFile0_isNull), Not(destFile0_isNull)), Not(Not(srcFile0.exists()))), Not(srcFile0.isDirectory())), srcFile0.getCanonicalPath().equals(destFile0.getCanonicalPath()))\n]\n\nsolver = Solver()\nfor constraint in constraints:\n  solver.add(constraint)\n\nmodels = list(all_smt(solver))\nfor model in models: print(model)",
          "symPyProgram": "from sympy import Symbol\nfrom sympy import simplify\nfrom sympy.core.relational import Eq, Ne, StrictGreaterThan, StrictLessThan, LessThan, GreaterThan\nfrom sympy.printing import ccode\n\nsrcFile = Symbol('srcFile')\ndestFile = Symbol('destFile')\nsrcFile_exists = Symbol('srcFile_exists')\nsrcFile_isDirectory = Symbol('srcFile_isDirectory')\nsrcFile_getCanonicalPath_equals = Symbol('srcFile_getCanonicalPath_equals')\nsrcFile_getCanonicalPath = Symbol('srcFile_getCanonicalPath')\ndestFile_getCanonicalPath = Symbol('destFile_getCanonicalPath')\nnull = Symbol('null')\npath_conjunction = (((((~((Eq(srcFile, null)))) & (~((Eq(destFile, null))))) & (~((~(srcFile_exists))))) & (~(srcFile_isDirectory))) & srcFile_getCanonicalPath_equals)\nprint(ccode(simplify(path_conjunction)))",
          "soundSymbolic": true,
          "soundBackwards": true,
          "maybe": true,
          "line": 1027,
          "throwingLine": 1028,
          "isStatic": true,
          "targetOnlyArguments": true
        },
        {
          "qualifiedSignature": "org.apache.commons.io.FileUtils.copyFile(java.io.File, java.io.File)",
          "exception": "throw new IOException(\"Source '\" + srcFile + \"' exists but is a directory\")",
          "pathCojunction": "(!(srcFile == null)) && (!(destFile == null)) && (!(!srcFile.exists())) && (srcFile.isDirectory())",
          "symbolicPathConjunction": "(copyFile(srcFile, destFile, true))",
          "backwardsPathConjunction": "(!(srcFile == null)) && (!(destFile == null)) && (!(!srcFile.exists())) && (srcFile.isDirectory())",
          "simplifiedPathConjunction": "srcFile.exists() && srcFile.isDirectory() && destFile != null && null != srcFile",
          "z3Program": "from z3 import *\nfrom z3_all_models import *\n\nsrcFile0_isNull = Bool('srcFile0_isNull')\ndestFile0_isNull = Bool('destFile0_isNull')\n\nconstraints = [\n  And(And(And(Not(srcFile0_isNull), Not(destFile0_isNull)), Not(Not(srcFile0.exists()))), srcFile0.isDirectory())\n]\n\nsolver = Solver()\nfor constraint in constraints:\n  solver.add(constraint)\n\nmodels = list(all_smt(solver))\nfor model in models: print(model)",
          "symPyProgram": "from sympy import Symbol\nfrom sympy import simplify\nfrom sympy.core.relational import Eq, Ne, StrictGreaterThan, StrictLessThan, LessThan, GreaterThan\nfrom sympy.printing import ccode\n\nsrcFile = Symbol('srcFile')\ndestFile = Symbol('destFile')\nsrcFile_exists = Symbol('srcFile_exists')\nsrcFile_isDirectory = Symbol('srcFile_isDirectory')\nnull = Symbol('null')\npath_conjunction = ((((~((Eq(srcFile, null)))) & (~((Eq(destFile, null))))) & (~((~(srcFile_exists))))) & srcFile_isDirectory)\nprint(ccode(simplify(path_conjunction)))",
          "soundSymbolic": true,
          "soundBackwards": true,
          "maybe": true,
          "line": 1027,
          "throwingLine": 1028,
          "isStatic": true,
          "targetOnlyArguments": true
        },
        {
          "qualifiedSignature": "org.apache.commons.io.FileUtils.copyFile(java.io.File, java.io.File)",
          "exception": "throw new FileNotFoundException(\"Source '\" + srcFile + \"' does not exist\")",
          "pathCojunction": "(!(srcFile == null)) && (!(destFile == null)) && (!(srcFile.exists()))",
          "symbolicPathConjunction": "(copyFile(srcFile, destFile, true))",
          "backwardsPathConjunction": "(!(srcFile == null)) && (!(destFile == null)) && (!(srcFile.exists()))",
          "simplifiedPathConjunction": "!srcFile.exists() && destFile != null && null != srcFile",
          "z3Program": "from z3 import *\nfrom z3_all_models import *\n\nsrcFile0_isNull = Bool('srcFile0_isNull')\ndestFile0_isNull = Bool('destFile0_isNull')\n\nconstraints = [\n  And(And(Not(srcFile0_isNull), Not(destFile0_isNull)), Not(srcFile0.exists()))\n]\n\nsolver = Solver()\nfor constraint in constraints:\n  solver.add(constraint)\n\nmodels = list(all_smt(solver))\nfor model in models: print(model)",
          "symPyProgram": "from sympy import Symbol\nfrom sympy import simplify\nfrom sympy.core.relational import Eq, Ne, StrictGreaterThan, StrictLessThan, LessThan, GreaterThan\nfrom sympy.printing import ccode\n\nsrcFile = Symbol('srcFile')\ndestFile = Symbol('destFile')\nsrcFile_exists = Symbol('srcFile_exists')\nnull = Symbol('null')\npath_conjunction = (((~((Eq(srcFile, null)))) & (~((Eq(destFile, null))))) & (~(srcFile_exists)))\nprint(ccode(simplify(path_conjunction)))",
          "soundSymbolic": true,
          "soundBackwards": true,
          "maybe": true,
          "line": 1027,
          "throwingLine": 1028,
          "isStatic": true,
          "targetOnlyArguments": true
        },
        {
          "qualifiedSignature": "org.apache.commons.io.FileUtils.copyFile(java.io.File, java.io.File)",
          "exception": "throw new NullPointerException(\"Source must not be null\")",
          "pathCojunction": "(srcFile == null)",
          "symbolicPathConjunction": "(copyFile(srcFile, destFile, true))",
          "backwardsPathConjunction": "(srcFile == null)",
          "simplifiedPathConjunction": "null == srcFile",
          "z3Inputs": "[srcFile0_isNull = True]\n",
          "z3Program": "from z3 import *\nfrom z3_all_models import *\n\nsrcFile0_isNull = Bool('srcFile0_isNull')\n\nconstraints = [\n  srcFile0_isNull\n]\n\nsolver = Solver()\nfor constraint in constraints:\n  solver.add(constraint)\n\nmodels = list(all_smt(solver))\nfor model in models: print(model)",
          "symPyProgram": "from sympy import Symbol\nfrom sympy import simplify\nfrom sympy.core.relational import Eq, Ne, StrictGreaterThan, StrictLessThan, LessThan, GreaterThan\nfrom sympy.printing import ccode\n\nsrcFile = Symbol('srcFile')\nnull = Symbol('null')\npath_conjunction = (Eq(srcFile, null))\nprint(ccode(simplify(path_conjunction)))",
          "soundSymbolic": true,
          "soundBackwards": true,
          "maybe": false,
          "line": 1027,
          "throwingLine": 1028,
          "isStatic": true,
          "targetOnlyArguments": true
        },
        {
          "qualifiedSignature": "org.apache.commons.io.FileUtils.copyFile(java.io.File, java.io.File)",
          "exception": "throw new NullPointerException(\"Destination must not be null\")",
          "pathCojunction": "(!(srcFile == null)) && (destFile == null)",
          "symbolicPathConjunction": "(copyFile(srcFile, destFile, true))",
          "backwardsPathConjunction": "(!(srcFile == null)) && (destFile == null)",
          "simplifiedPathConjunction": "destFile == null && null != srcFile",
          "z3Inputs": "[destFile0_isNull = True, srcFile0_isNull = False]\n",
          "z3Program": "from z3 import *\nfrom z3_all_models import *\n\nsrcFile0_isNull = Bool('srcFile0_isNull')\ndestFile0_isNull = Bool('destFile0_isNull')\n\nconstraints = [\n  And(Not(srcFile0_isNull), destFile0_isNull)\n]\n\nsolver = Solver()\nfor constraint in constraints:\n  solver.add(constraint)\n\nmodels = list(all_smt(solver))\nfor model in models: print(model)",
          "symPyProgram": "from sympy import Symbol\nfrom sympy import simplify\nfrom sympy.core.relational import Eq, Ne, StrictGreaterThan, StrictLessThan, LessThan, GreaterThan\nfrom sympy.printing import ccode\n\nsrcFile = Symbol('srcFile')\ndestFile = Symbol('destFile')\nnull = Symbol('null')\npath_conjunction = ((~((Eq(srcFile, null)))) & (Eq(destFile, null)))\nprint(ccode(simplify(path_conjunction)))",
          "soundSymbolic": true,
          "soundBackwards": true,
          "maybe": false,
          "line": 1027,
          "throwingLine": 1028,
          "isStatic": true,
          "targetOnlyArguments": true
        },
        {
          "qualifiedSignature": "org.apache.commons.io.FileUtils.copyFile(java.io.File, java.io.File, boolean)",
          "exception": "throw new IOException(\"Destination '\" + parentFile + \"' directory cannot be created\");",
          "pathCojunction": "(!(srcFile == null)) && (!(destFile == null)) && (!(!srcFile.exists())) && (!(srcFile.isDirectory())) && (!(srcFile.getCanonicalPath().equals(destFile.getCanonicalPath()))) && (parentFile != null) && (!parentFile.mkdirs() && !parentFile.isDirectory())",
          "symbolicPathConjunction": "(!(!(src == null)) && (!(dest == null)) && (!(!src.exists()))) && (!(srcFile.isDirectory())) && (!(srcFile.getCanonicalPath().equals(destFile.getCanonicalPath()))) && (parentFile != null) && (!parentFile.mkdirs() && !parentFile.isDirectory())",
          "backwardsPathConjunction": "(!(srcFile == null)) && (!(destFile == null)) && (!(!srcFile.exists())) && (!(srcFile.isDirectory())) && (!(srcFile.getCanonicalPath().equals(destFile.getCanonicalPath()))) && (destFile.getParentFile() != null) && (!destFile.getParentFile().mkdirs() && !destFile.getParentFile().isDirectory())",
          "simplifiedPathConjunction": "srcFile.exists() && !destFile.getParentFile().isDirectory() && !destFile.getParentFile().mkdirs() && !srcFile.getCanonicalPath().equals(destFile.getCanonicalPath()) && !srcFile.isDirectory() && destFile != null && destFile.getParentFile() != null && null != srcFile",
          "z3Program": "from z3 import *\nfrom z3_all_models import *\n\npreserveFileDate0 = Bool('preserveFileDate0')\nsrcFile0_isNull = Bool('srcFile0_isNull')\ndestFile0_isNull = Bool('destFile0_isNull')\nparentFile0_isNull = Bool('parentFile0_isNull')\n\nconstraints = [\n  parentFile0 == destFile0.getParentFile(),\n  And(And(And(And(And(And(Not(srcFile0_isNull), Not(destFile0_isNull)), Not(Not(srcFile0.exists()))), Not(srcFile0.isDirectory())), Not(srcFile0.getCanonicalPath().equals(destFile0.getCanonicalPath()))), Not(parentFile0_isNull)), And(Not(parentFile0.mkdirs()), Not(parentFile0.isDirectory())))\n]\n\nsolver = Solver()\nfor constraint in constraints:\n  solver.add(constraint)\n\nmodels = list(all_smt(solver))\nfor model in models: print(model)",
          "symPyProgram": "from sympy import Symbol\nfrom sympy import simplify\nfrom sympy.core.relational import Eq, Ne, StrictGreaterThan, StrictLessThan, LessThan, GreaterThan\nfrom sympy.printing import ccode\n\nsrcFile = Symbol('srcFile')\ndestFile = Symbol('destFile')\nsrcFile_exists = Symbol('srcFile_exists')\nsrcFile_isDirectory = Symbol('srcFile_isDirectory')\nsrcFile_getCanonicalPath_equals = Symbol('srcFile_getCanonicalPath_equals')\nsrcFile_getCanonicalPath = Symbol('srcFile_getCanonicalPath')\ndestFile_getCanonicalPath = Symbol('destFile_getCanonicalPath')\ndestFile_getParentFile = Symbol('destFile_getParentFile')\ndestFile_getParentFile_mkdirs = Symbol('destFile_getParentFile_mkdirs')\ndestFile_getParentFile_isDirectory = Symbol('destFile_getParentFile_isDirectory')\nnull = Symbol('null')\npath_conjunction = (((((((~((Eq(srcFile, null)))) & (~((Eq(destFile, null))))) & (~((~(srcFile_exists))))) & (~(srcFile_isDirectory))) & (~(srcFile_getCanonicalPath_equals))) & (Ne(destFile_getParentFile, null))) & ((~(destFile_getParentFile_mkdirs)) & (~(destFile_getParentFile_isDirectory))))\nprint(ccode(simplify(path_conjunction)))",
          "soundSymbolic": false,
          "soundBackwards": true,
          "maybe": true,
          "line": 1059,
          "throwingLine": 1070,
          "isStatic": true,
          "targetOnlyArguments": false
        },
        {
          "qualifiedSignature": "org.apache.commons.io.FileUtils.copyFile(java.io.File, java.io.File, boolean)",
          "exception": "throw new IOException(\"Destination '\" + destFile + \"' exists but is read-only\");",
          "pathCojunction": "(!(srcFile == null)) && (!(destFile == null)) && (!(!srcFile.exists())) && (!(srcFile.isDirectory())) && (!(srcFile.getCanonicalPath().equals(destFile.getCanonicalPath()))) && (parentFile != null) && (!(!parentFile.mkdirs() && !parentFile.isDirectory())) && (destFile.exists() && destFile.canWrite() == false)",
          "symbolicPathConjunction": "((!(src == null)) && (!(dest == null)) && (!(!src.exists()))) && (!(srcFile.isDirectory())) && (!(srcFile.getCanonicalPath().equals(destFile.getCanonicalPath()))) && (parentFile != null) && (!(!parentFile.mkdirs() && !parentFile.isDirectory())) && (destFile.exists() && destFile.canWrite() == false)",
          "backwardsPathConjunction": "(!(srcFile == null)) && (!(destFile == null)) && (!(!srcFile.exists())) && (!(srcFile.isDirectory())) && (!(srcFile.getCanonicalPath().equals(destFile.getCanonicalPath()))) && (destFile.getParentFile() != null) && (!(!destFile.getParentFile().mkdirs() && !destFile.getParentFile().isDirectory())) && (destFile.exists() && destFile.canWrite() == false)",
          "simplifiedPathConjunction": "destFile.exists() && srcFile.exists() && !destFile.canWrite() && !srcFile.getCanonicalPath().equals(destFile.getCanonicalPath()) && !srcFile.isDirectory() && (destFile.getParentFile().isDirectory() || destFile.getParentFile().mkdirs()) && destFile != null && destFile.getParentFile() != null && null != srcFile",
          "z3Program": "from z3 import *\nfrom z3_all_models import *\n\npreserveFileDate0 = Bool('preserveFileDate0')\nsrcFile0_isNull = Bool('srcFile0_isNull')\ndestFile0_isNull = Bool('destFile0_isNull')\nparentFile0_isNull = Bool('parentFile0_isNull')\n\nconstraints = [\n  parentFile0 == destFile0.getParentFile(),\n  And(And(And(And(And(And(And(Not(srcFile0_isNull), Not(destFile0_isNull)), Not(Not(srcFile0.exists()))), Not(srcFile0.isDirectory())), Not(srcFile0.getCanonicalPath().equals(destFile0.getCanonicalPath()))), Not(parentFile0_isNull)), Not(And(Not(parentFile0.mkdirs()), Not(parentFile0.isDirectory())))), And(destFile0.exists(), destFile0.canWrite() == False))\n]\n\nsolver = Solver()\nfor constraint in constraints:\n  solver.add(constraint)\n\nmodels = list(all_smt(solver))\nfor model in models: print(model)",
          "symPyProgram": "from sympy import Symbol\nfrom sympy import simplify\nfrom sympy.core.relational import Eq, Ne, StrictGreaterThan, StrictLessThan, LessThan, GreaterThan\nfrom sympy.printing import ccode\n\nsrcFile = Symbol('srcFile')\ndestFile = Symbol('destFile')\nsrcFile_exists = Symbol('srcFile_exists')\nsrcFile_isDirectory = Symbol('srcFile_isDirectory')\nsrcFile_getCanonicalPath_equals = Symbol('srcFile_getCanonicalPath_equals')\nsrcFile_getCanonicalPath = Symbol('srcFile_getCanonicalPath')\ndestFile_getCanonicalPath = Symbol('destFile_getCanonicalPath')\ndestFile_getParentFile = Symbol('destFile_getParentFile')\ndestFile_getParentFile_mkdirs = Symbol('destFile_getParentFile_mkdirs')\ndestFile_getParentFile_isDirectory = Symbol('destFile_getParentFile_isDirectory')\ndestFile_exists = Symbol('destFile_exists')\ndestFile_canWrite = Symbol('destFile_canWrite')\nnull = Symbol('null')\npath_conjunction = ((((((((~((Eq(srcFile, null)))) & (~((Eq(destFile, null))))) & (~((~(srcFile_exists))))) & (~(srcFile_isDirectory))) & (~(srcFile_getCanonicalPath_equals))) & (Ne(destFile_getParentFile, null))) & (~(((~(destFile_getParentFile_mkdirs)) & (~(destFile_getParentFile_isDirectory)))))) & (destFile_exists & (~(destFile_canWrite))))\nprint(ccode(simplify(path_conjunction)))",
          "soundSymbolic": false,
          "soundBackwards": true,
          "maybe": true,
          "line": 1059,
          "throwingLine": 1074,
          "isStatic": true,
          "targetOnlyArguments": false
        },
        {
          "qualifiedSignature": "org.apache.commons.io.FileUtils.copyFile(java.io.File, java.io.File, boolean)",
          "exception": "throw new NullPointerException(\"Destination must not be null\")",
          "pathCojunction": "(!(srcFile == null)) && (destFile == null)",
          "symbolicPathConjunction": "((!(src == null)) && (dest == null))",
          "backwardsPathConjunction": "(!(srcFile == null)) && (destFile == null)",
          "simplifiedPathConjunction": "destFile == null && null != srcFile",
          "z3Inputs": "[destFile0_isNull = True, srcFile0_isNull = False]\n",
          "z3Program": "from z3 import *\nfrom z3_all_models import *\n\npreserveFileDate0 = Bool('preserveFileDate0')\nsrcFile0_isNull = Bool('srcFile0_isNull')\ndestFile0_isNull = Bool('destFile0_isNull')\n\nconstraints = [\n  And(Not(srcFile0_isNull), destFile0_isNull)\n]\n\nsolver = Solver()\nfor constraint in constraints:\n  solver.add(constraint)\n\nmodels = list(all_smt(solver))\nfor model in models: print(model)",
          "symPyProgram": "from sympy import Symbol\nfrom sympy import simplify\nfrom sympy.core.relational import Eq, Ne, StrictGreaterThan, StrictLessThan, LessThan, GreaterThan\nfrom sympy.printing import ccode\n\nsrcFile = Symbol('srcFile')\ndestFile = Symbol('destFile')\nnull = Symbol('null')\npath_conjunction = ((~((Eq(srcFile, null)))) & (Eq(destFile, null)))\nprint(ccode(simplify(path_conjunction)))",
          "soundSymbolic": true,
          "soundBackwards": true,
          "maybe": false,
          "line": 1059,
          "throwingLine": 1060,
          "isStatic": true,
          "targetOnlyArguments": true
        },
        {
          "qualifiedSignature": "org.apache.commons.io.FileUtils.copyFile(java.io.File, java.io.File, boolean)",
          "exception": "throw new IOException(\"Destination '\" + destFile + \"' exists but is read-only\");",
          "pathCojunction": "(!(srcFile == null)) && (!(destFile == null)) && (!(!srcFile.exists())) && (!(srcFile.isDirectory())) && (!(srcFile.getCanonicalPath().equals(destFile.getCanonicalPath()))) && (!(parentFile != null)) && (destFile.exists() && destFile.canWrite() == false)",
          "symbolicPathConjunction": "((!(src == null)) && (!(dest == null)) && (!(!src.exists()))) && (!(srcFile.isDirectory())) && (!(srcFile.getCanonicalPath().equals(destFile.getCanonicalPath()))) && (!(parentFile != null)) && (destFile.exists() && destFile.canWrite() == false)",
          "backwardsPathConjunction": "(!(srcFile == null)) && (!(destFile == null)) && (!(!srcFile.exists())) && (!(srcFile.isDirectory())) && (!(srcFile.getCanonicalPath().equals(destFile.getCanonicalPath()))) && (!(destFile.getParentFile() != null)) && (destFile.exists() && destFile.canWrite() == false)",
          "simplifiedPathConjunction": "destFile.exists() && srcFile.exists() && destFile.getParentFile() == null && !destFile.canWrite() && !srcFile.getCanonicalPath().equals(destFile.getCanonicalPath()) && !srcFile.isDirectory() && destFile != null && null != srcFile",
          "z3Program": "from z3 import *\nfrom z3_all_models import *\n\npreserveFileDate0 = Bool('preserveFileDate0')\nsrcFile0_isNull = Bool('srcFile0_isNull')\ndestFile0_isNull = Bool('destFile0_isNull')\nparentFile0_isNull = Bool('parentFile0_isNull')\n\nconstraints = [\n  parentFile0 == destFile0.getParentFile(),\n  And(And(And(And(And(And(Not(srcFile0_isNull), Not(destFile0_isNull)), Not(Not(srcFile0.exists()))), Not(srcFile0.isDirectory())), Not(srcFile0.getCanonicalPath().equals(destFile0.getCanonicalPath()))), Not(Not(parentFile0_isNull))), And(destFile0.exists(), destFile0.canWrite() == False))\n]\n\nsolver = Solver()\nfor constraint in constraints:\n  solver.add(constraint)\n\nmodels = list(all_smt(solver))\nfor model in models: print(model)",
          "symPyProgram": "from sympy import Symbol\nfrom sympy import simplify\nfrom sympy.core.relational import Eq, Ne, StrictGreaterThan, StrictLessThan, LessThan, GreaterThan\nfrom sympy.printing import ccode\n\nsrcFile = Symbol('srcFile')\ndestFile = Symbol('destFile')\nsrcFile_exists = Symbol('srcFile_exists')\nsrcFile_isDirectory = Symbol('srcFile_isDirectory')\nsrcFile_getCanonicalPath_equals = Symbol('srcFile_getCanonicalPath_equals')\nsrcFile_getCanonicalPath = Symbol('srcFile_getCanonicalPath')\ndestFile_getCanonicalPath = Symbol('destFile_getCanonicalPath')\ndestFile_getParentFile = Symbol('destFile_getParentFile')\ndestFile_exists = Symbol('destFile_exists')\ndestFile_canWrite = Symbol('destFile_canWrite')\nnull = Symbol('null')\npath_conjunction = (((((((~((Eq(srcFile, null)))) & (~((Eq(destFile, null))))) & (~((~(srcFile_exists))))) & (~(srcFile_isDirectory))) & (~(srcFile_getCanonicalPath_equals))) & (~((Ne(destFile_getParentFile, null))))) & (destFile_exists & (~(destFile_canWrite))))\nprint(ccode(simplify(path_conjunction)))",
          "soundSymbolic": false,
          "soundBackwards": true,
          "maybe": true,
          "line": 1059,
          "throwingLine": 1074,
          "isStatic": true,
          "targetOnlyArguments": false
        },
        {
          "qualifiedSignature": "org.apache.commons.io.FileUtils.copyFile(java.io.File, java.io.File, boolean)",
          "exception": "throw new IOException(\"Source '\" + srcFile + \"' and destination '\" + destFile + \"' are the same\");",
          "pathCojunction": "(!(srcFile == null)) && (!(destFile == null)) && (!(!srcFile.exists())) && (!(srcFile.isDirectory())) && (srcFile.getCanonicalPath().equals(destFile.getCanonicalPath()))",
          "symbolicPathConjunction": "(!(!(src == null)) && (!(dest == null)) && (!(!src.exists()))) && (!(srcFile.isDirectory())) && (srcFile.getCanonicalPath().equals(destFile.getCanonicalPath()))",
          "backwardsPathConjunction": "(!(srcFile == null)) && (!(destFile == null)) && (!(!srcFile.exists())) && (!(srcFile.isDirectory())) && (srcFile.getCanonicalPath().equals(destFile.getCanonicalPath()))",
          "simplifiedPathConjunction": "srcFile.exists() && srcFile.getCanonicalPath().equals(destFile.getCanonicalPath()) && !srcFile.isDirectory() && destFile != null && null != srcFile",
          "z3Program": "from z3 import *\nfrom z3_all_models import *\n\npreserveFileDate0 = Bool('preserveFileDate0')\nsrcFile0_isNull = Bool('srcFile0_isNull')\ndestFile0_isNull = Bool('destFile0_isNull')\n\nconstraints = [\n  And(And(And(And(Not(srcFile0_isNull), Not(destFile0_isNull)), Not(Not(srcFile0.exists()))), Not(srcFile0.isDirectory())), srcFile0.getCanonicalPath().equals(destFile0.getCanonicalPath()))\n]\n\nsolver = Solver()\nfor constraint in constraints:\n  solver.add(constraint)\n\nmodels = list(all_smt(solver))\nfor model in models: print(model)",
          "symPyProgram": "from sympy import Symbol\nfrom sympy import simplify\nfrom sympy.core.relational import Eq, Ne, StrictGreaterThan, StrictLessThan, LessThan, GreaterThan\nfrom sympy.printing import ccode\n\nsrcFile = Symbol('srcFile')\ndestFile = Symbol('destFile')\nsrcFile_exists = Symbol('srcFile_exists')\nsrcFile_isDirectory = Symbol('srcFile_isDirectory')\nsrcFile_getCanonicalPath_equals = Symbol('srcFile_getCanonicalPath_equals')\nsrcFile_getCanonicalPath = Symbol('srcFile_getCanonicalPath')\ndestFile_getCanonicalPath = Symbol('destFile_getCanonicalPath')\nnull = Symbol('null')\npath_conjunction = (((((~((Eq(srcFile, null)))) & (~((Eq(destFile, null))))) & (~((~(srcFile_exists))))) & (~(srcFile_isDirectory))) & srcFile_getCanonicalPath_equals)\nprint(ccode(simplify(path_conjunction)))",
          "soundSymbolic": false,
          "soundBackwards": true,
          "maybe": true,
          "line": 1059,
          "throwingLine": 1065,
          "isStatic": true,
          "targetOnlyArguments": true
        },
        {
          "qualifiedSignature": "org.apache.commons.io.FileUtils.copyFile(java.io.File, java.io.File, boolean)",
          "exception": "throw new IOException(\"Source '\" + srcFile + \"' exists but is a directory\");",
          "pathCojunction": "(!(srcFile == null)) && (!(destFile == null)) && (!(!srcFile.exists())) && (srcFile.isDirectory())",
          "symbolicPathConjunction": "((!(src == null)) && (!(dest == null)) && (!(!src.exists()))) && (srcFile.isDirectory())",
          "backwardsPathConjunction": "(!(srcFile == null)) && (!(destFile == null)) && (!(!srcFile.exists())) && (srcFile.isDirectory())",
          "simplifiedPathConjunction": "srcFile.exists() && srcFile.isDirectory() && destFile != null && null != srcFile",
          "z3Program": "from z3 import *\nfrom z3_all_models import *\n\npreserveFileDate0 = Bool('preserveFileDate0')\nsrcFile0_isNull = Bool('srcFile0_isNull')\ndestFile0_isNull = Bool('destFile0_isNull')\n\nconstraints = [\n  And(And(And(Not(srcFile0_isNull), Not(destFile0_isNull)), Not(Not(srcFile0.exists()))), srcFile0.isDirectory())\n]\n\nsolver = Solver()\nfor constraint in constraints:\n  solver.add(constraint)\n\nmodels = list(all_smt(solver))\nfor model in models: print(model)",
          "symPyProgram": "from sympy import Symbol\nfrom sympy import simplify\nfrom sympy.core.relational import Eq, Ne, StrictGreaterThan, StrictLessThan, LessThan, GreaterThan\nfrom sympy.printing import ccode\n\nsrcFile = Symbol('srcFile')\ndestFile = Symbol('destFile')\nsrcFile_exists = Symbol('srcFile_exists')\nsrcFile_isDirectory = Symbol('srcFile_isDirectory')\nnull = Symbol('null')\npath_conjunction = ((((~((Eq(srcFile, null)))) & (~((Eq(destFile, null))))) & (~((~(srcFile_exists))))) & srcFile_isDirectory)\nprint(ccode(simplify(path_conjunction)))",
          "soundSymbolic": false,
          "soundBackwards": true,
          "maybe": true,
          "line": 1059,
          "throwingLine": 1062,
          "isStatic": true,
          "targetOnlyArguments": true
        },
        {
          "qualifiedSignature": "org.apache.commons.io.FileUtils.copyFile(java.io.File, java.io.File, boolean)",
          "exception": "throw new NullPointerException(\"Source must not be null\")",
          "pathCojunction": "(srcFile == null)",
          "symbolicPathConjunction": "(src == null)",
          "backwardsPathConjunction": "(srcFile == null)",
          "simplifiedPathConjunction": "null == srcFile",
          "z3Inputs": "[srcFile0_isNull = True]\n",
          "z3Program": "from z3 import *\nfrom z3_all_models import *\n\npreserveFileDate0 = Bool('preserveFileDate0')\nsrcFile0_isNull = Bool('srcFile0_isNull')\n\nconstraints = [\n  srcFile0_isNull\n]\n\nsolver = Solver()\nfor constraint in constraints:\n  solver.add(constraint)\n\nmodels = list(all_smt(solver))\nfor model in models: print(model)",
          "symPyProgram": "from sympy import Symbol\nfrom sympy import simplify\nfrom sympy.core.relational import Eq, Ne, StrictGreaterThan, StrictLessThan, LessThan, GreaterThan\nfrom sympy.printing import ccode\n\nsrcFile = Symbol('srcFile')\nnull = Symbol('null')\npath_conjunction = (Eq(srcFile, null))\nprint(ccode(simplify(path_conjunction)))",
          "soundSymbolic": true,
          "soundBackwards": true,
          "maybe": false,
          "line": 1059,
          "throwingLine": 1060,
          "isStatic": true,
          "targetOnlyArguments": true
        },
        {
          "qualifiedSignature": "org.apache.commons.io.FileUtils.copyFile(java.io.File, java.io.File, boolean)",
          "exception": "throw new FileNotFoundException(\"Source '\" + srcFile + \"' does not exist\")",
          "pathCojunction": "(!(srcFile == null)) && (!(destFile == null)) && (!(srcFile.exists()))",
          "symbolicPathConjunction": "((!(src == null)) && (!(dest == null)) && (!src.exists()))",
          "backwardsPathConjunction": "(!(srcFile == null)) && (!(destFile == null)) && (!(srcFile.exists()))",
          "simplifiedPathConjunction": "!srcFile.exists() && destFile != null && null != srcFile",
          "z3Program": "from z3 import *\nfrom z3_all_models import *\n\npreserveFileDate0 = Bool('preserveFileDate0')\nsrcFile0_isNull = Bool('srcFile0_isNull')\ndestFile0_isNull = Bool('destFile0_isNull')\n\nconstraints = [\n  And(And(Not(srcFile0_isNull), Not(destFile0_isNull)), Not(srcFile0.exists()))\n]\n\nsolver = Solver()\nfor constraint in constraints:\n  solver.add(constraint)\n\nmodels = list(all_smt(solver))\nfor model in models: print(model)",
          "symPyProgram": "from sympy import Symbol\nfrom sympy import simplify\nfrom sympy.core.relational import Eq, Ne, StrictGreaterThan, StrictLessThan, LessThan, GreaterThan\nfrom sympy.printing import ccode\n\nsrcFile = Symbol('srcFile')\ndestFile = Symbol('destFile')\nsrcFile_exists = Symbol('srcFile_exists')\nnull = Symbol('null')\npath_conjunction = (((~((Eq(srcFile, null)))) & (~((Eq(destFile, null))))) & (~(srcFile_exists)))\nprint(ccode(simplify(path_conjunction)))",
          "soundSymbolic": true,
          "soundBackwards": true,
          "maybe": true,
          "line": 1059,
          "throwingLine": 1060,
          "isStatic": true,
          "targetOnlyArguments": true
        },
        {
          "qualifiedSignature": "org.apache.commons.io.FileUtils.copyDirectoryToDirectory(java.io.File, java.io.File)",
          "exception": "throw new IllegalArgumentException(\"Destination '\" + destDir + \"' is not a directory\");",
          "pathCojunction": "(!(srcDir == null)) && (!(srcDir.exists() && srcDir.isDirectory() == false)) && (!(destDir == null)) && (destDir.exists() && destDir.isDirectory() == false)",
          "symbolicPathConjunction": "(!(srcDir == null)) && (!(srcDir.exists() && srcDir.isDirectory() == false)) && (!(destDir == null)) && (destDir.exists() && destDir.isDirectory() == false)",
          "backwardsPathConjunction": "(!(srcDir == null)) && (!(srcDir.exists() && srcDir.isDirectory() == false)) && (!(destDir == null)) && (destDir.exists() && destDir.isDirectory() == false)",
          "simplifiedPathConjunction": "destDir.exists() && !destDir.isDirectory() && (srcDir.isDirectory() || !srcDir.exists()) && destDir != null && null != srcDir",
          "z3Program": "from z3 import *\nfrom z3_all_models import *\n\nsrcDir0_isNull = Bool('srcDir0_isNull')\ndestDir0_isNull = Bool('destDir0_isNull')\n\nconstraints = [\n  And(And(And(Not(srcDir0_isNull), Not(And(srcDir0.exists(), srcDir0.isDirectory() == False))), Not(destDir0_isNull)), And(destDir0.exists(), destDir0.isDirectory() == False))\n]\n\nsolver = Solver()\nfor constraint in constraints:\n  solver.add(constraint)\n\nmodels = list(all_smt(solver))\nfor model in models: print(model)",
          "symPyProgram": "from sympy import Symbol\nfrom sympy import simplify\nfrom sympy.core.relational import Eq, Ne, StrictGreaterThan, StrictLessThan, LessThan, GreaterThan\nfrom sympy.printing import ccode\n\nsrcDir = Symbol('srcDir')\ndestDir = Symbol('destDir')\nsrcDir_exists = Symbol('srcDir_exists')\nsrcDir_isDirectory = Symbol('srcDir_isDirectory')\ndestDir_exists = Symbol('destDir_exists')\ndestDir_isDirectory = Symbol('destDir_isDirectory')\nnull = Symbol('null')\npath_conjunction = ((((~((Eq(srcDir, null)))) & (~((srcDir_exists & (~(srcDir_isDirectory)))))) & (~((Eq(destDir, null))))) & (destDir_exists & (~(destDir_isDirectory))))\nprint(ccode(simplify(path_conjunction)))",
          "soundSymbolic": false,
          "soundBackwards": true,
          "maybe": true,
          "line": 1174,
          "throwingLine": 1185,
          "isStatic": true,
          "targetOnlyArguments": true
        },
        {
          "qualifiedSignature": "org.apache.commons.io.FileUtils.copyDirectoryToDirectory(java.io.File, java.io.File)",
          "exception": "throw new IllegalArgumentException(\"Source '\" + destDir + \"' is not a directory\");",
          "pathCojunction": "(!(srcDir == null)) && (srcDir.exists() && srcDir.isDirectory() == false)",
          "symbolicPathConjunction": "(!(srcDir == null)) && (srcDir.exists() && srcDir.isDirectory() == false)",
          "backwardsPathConjunction": "(!(srcDir == null)) && (srcDir.exists() && srcDir.isDirectory() == false)",
          "simplifiedPathConjunction": "srcDir.exists() && !srcDir.isDirectory() && null != srcDir",
          "z3Program": "from z3 import *\nfrom z3_all_models import *\n\nsrcDir0_isNull = Bool('srcDir0_isNull')\n\nconstraints = [\n  And(Not(srcDir0_isNull), And(srcDir0.exists(), srcDir0.isDirectory() == False))\n]\n\nsolver = Solver()\nfor constraint in constraints:\n  solver.add(constraint)\n\nmodels = list(all_smt(solver))\nfor model in models: print(model)",
          "symPyProgram": "from sympy import Symbol\nfrom sympy import simplify\nfrom sympy.core.relational import Eq, Ne, StrictGreaterThan, StrictLessThan, LessThan, GreaterThan\nfrom sympy.printing import ccode\n\nsrcDir = Symbol('srcDir')\nsrcDir_exists = Symbol('srcDir_exists')\nsrcDir_isDirectory = Symbol('srcDir_isDirectory')\nnull = Symbol('null')\npath_conjunction = ((~((Eq(srcDir, null)))) & (srcDir_exists & (~(srcDir_isDirectory))))\nprint(ccode(simplify(path_conjunction)))",
          "soundSymbolic": false,
          "soundBackwards": true,
          "maybe": true,
          "line": 1174,
          "throwingLine": 1179,
          "isStatic": true,
          "targetOnlyArguments": true
        },
        {
          "qualifiedSignature": "org.apache.commons.io.FileUtils.copyDirectoryToDirectory(java.io.File, java.io.File)",
          "exception": "throw new NullPointerException(\"Destination must not be null\");",
          "pathCojunction": "(!(srcDir == null)) && (!(srcDir.exists() && srcDir.isDirectory() == false)) && (destDir == null)",
          "symbolicPathConjunction": "(!(srcDir == null)) && (!(srcDir.exists() && srcDir.isDirectory() == false)) && (destDir == null)",
          "backwardsPathConjunction": "(!(srcDir == null)) && (!(srcDir.exists() && srcDir.isDirectory() == false)) && (destDir == null)",
          "simplifiedPathConjunction": "destDir == null && (srcDir.isDirectory() || !srcDir.exists()) && null != srcDir",
          "z3Program": "from z3 import *\nfrom z3_all_models import *\n\nsrcDir0_isNull = Bool('srcDir0_isNull')\ndestDir0_isNull = Bool('destDir0_isNull')\n\nconstraints = [\n  And(And(Not(srcDir0_isNull), Not(And(srcDir0.exists(), srcDir0.isDirectory() == False))), destDir0_isNull)\n]\n\nsolver = Solver()\nfor constraint in constraints:\n  solver.add(constraint)\n\nmodels = list(all_smt(solver))\nfor model in models: print(model)",
          "symPyProgram": "from sympy import Symbol\nfrom sympy import simplify\nfrom sympy.core.relational import Eq, Ne, StrictGreaterThan, StrictLessThan, LessThan, GreaterThan\nfrom sympy.printing import ccode\n\nsrcDir = Symbol('srcDir')\ndestDir = Symbol('destDir')\nsrcDir_exists = Symbol('srcDir_exists')\nsrcDir_isDirectory = Symbol('srcDir_isDirectory')\nnull = Symbol('null')\npath_conjunction = (((~((Eq(srcDir, null)))) & (~((srcDir_exists & (~(srcDir_isDirectory)))))) & (Eq(destDir, null)))\nprint(ccode(simplify(path_conjunction)))",
          "soundSymbolic": false,
          "soundBackwards": true,
          "maybe": true,
          "line": 1174,
          "throwingLine": 1182,
          "isStatic": true,
          "targetOnlyArguments": true
        },
        {
          "qualifiedSignature": "org.apache.commons.io.FileUtils.copyDirectoryToDirectory(java.io.File, java.io.File)",
          "exception": "throw new NullPointerException(\"Source must not be null\");",
          "pathCojunction": "(srcDir == null)",
          "symbolicPathConjunction": "(srcDir == null)",
          "backwardsPathConjunction": "(srcDir == null)",
          "simplifiedPathConjunction": "null == srcDir",
          "z3Inputs": "[srcDir0_isNull = True]\n",
          "z3Program": "from z3 import *\nfrom z3_all_models import *\n\nsrcDir0_isNull = Bool('srcDir0_isNull')\n\nconstraints = [\n  srcDir0_isNull\n]\n\nsolver = Solver()\nfor constraint in constraints:\n  solver.add(constraint)\n\nmodels = list(all_smt(solver))\nfor model in models: print(model)",
          "symPyProgram": "from sympy import Symbol\nfrom sympy import simplify\nfrom sympy.core.relational import Eq, Ne, StrictGreaterThan, StrictLessThan, LessThan, GreaterThan\nfrom sympy.printing import ccode\n\nsrcDir = Symbol('srcDir')\nnull = Symbol('null')\npath_conjunction = (Eq(srcDir, null))\nprint(ccode(simplify(path_conjunction)))",
          "soundSymbolic": true,
          "soundBackwards": true,
          "maybe": false,
          "line": 1174,
          "throwingLine": 1176,
          "isStatic": true,
          "targetOnlyArguments": true
        },
        {
          "qualifiedSignature": "org.apache.commons.io.FileUtils.copyToDirectory(java.io.File, java.io.File)",
          "exception": "throw new IllegalArgumentException(\"Destination '\" + destDir + \"' is not a directory\")",
          "pathCojunction": "(!(src == null)) && (!(src.isFile())) && (src.isDirectory()) && (!(src == null)) && (!(src.exists() && src.isDirectory() == false)) && (!(destDir == null)) && (destDir.exists() && destDir.isDirectory() == false)",
          "symbolicPathConjunction": "(!(src == null)) && (!(src.isFile())) && (src.isDirectory()) && (copyDirectoryToDirectory(src, destDir))",
          "backwardsPathConjunction": "(!(src == null)) && (!(src.isFile())) && (src.isDirectory()) && (!(src == null)) && (!(src.exists() && src.isDirectory() == false)) && (!(destDir == null)) && (destDir.exists() && destDir.isDirectory() == false)",
          "simplifiedPathConjunction": "destDir.exists() && src.isDirectory() && !destDir.isDirectory() && !src.isFile() && destDir != null && null != src",
          "z3Program": "from z3 import *\nfrom z3_all_models import *\n\nsrc0_isNull = Bool('src0_isNull')\ndestDir0_isNull = Bool('destDir0_isNull')\n\nconstraints = [\n  And(And(And(And(And(And(Not(src0_isNull), Not(src0.isFile())), src0.isDirectory()), Not(src0_isNull)), Not(And(src0.exists(), src0.isDirectory() == False))), Not(destDir0_isNull)), And(destDir0.exists(), destDir0.isDirectory() == False))\n]\n\nsolver = Solver()\nfor constraint in constraints:\n  solver.add(constraint)\n\nmodels = list(all_smt(solver))\nfor model in models: print(model)",
          "symPyProgram": "from sympy import Symbol\nfrom sympy import simplify\nfrom sympy.core.relational import Eq, Ne, StrictGreaterThan, StrictLessThan, LessThan, GreaterThan\nfrom sympy.printing import ccode\n\nsrc = Symbol('src')\ndestDir = Symbol('destDir')\nsrc_isFile = Symbol('src_isFile')\nsrc_isDirectory = Symbol('src_isDirectory')\nsrc_exists = Symbol('src_exists')\ndestDir_exists = Symbol('destDir_exists')\ndestDir_isDirectory = Symbol('destDir_isDirectory')\nnull = Symbol('null')\npath_conjunction = (((((((~((Eq(src, null)))) & (~(src_isFile))) & src_isDirectory) & (~((Eq(src, null))))) & (~((src_exists & (~(src_isDirectory)))))) & (~((Eq(destDir, null))))) & (destDir_exists & (~(destDir_isDirectory))))\nprint(ccode(simplify(path_conjunction)))",
          "soundSymbolic": false,
          "soundBackwards": true,
          "maybe": true,
          "line": 1559,
          "throwingLine": 1566,
          "isStatic": true,
          "targetOnlyArguments": true
        },
        {
          "qualifiedSignature": "org.apache.commons.io.FileUtils.copyToDirectory(java.io.File, java.io.File)",
          "exception": "throw new NullPointerException(\"Destination must not be null\")",
          "pathCojunction": "(!(src == null)) && (!(src.isFile())) && (src.isDirectory()) && (!(src == null)) && (!(src.exists() && src.isDirectory() == false)) && (destDir == null)",
          "symbolicPathConjunction": "(!(src == null)) && (!(src.isFile())) && (src.isDirectory()) && (copyDirectoryToDirectory(src, destDir))",
          "backwardsPathConjunction": "(!(src == null)) && (!(src.isFile())) && (src.isDirectory()) && (!(src == null)) && (!(src.exists() && src.isDirectory() == false)) && (destDir == null)",
          "simplifiedPathConjunction": "src.isDirectory() && destDir == null && !src.isFile() && null != src",
          "z3Program": "from z3 import *\nfrom z3_all_models import *\n\nsrc0_isNull = Bool('src0_isNull')\ndestDir0_isNull = Bool('destDir0_isNull')\n\nconstraints = [\n  And(And(And(And(And(Not(src0_isNull), Not(src0.isFile())), src0.isDirectory()), Not(src0_isNull)), Not(And(src0.exists(), src0.isDirectory() == False))), destDir0_isNull)\n]\n\nsolver = Solver()\nfor constraint in constraints:\n  solver.add(constraint)\n\nmodels = list(all_smt(solver))\nfor model in models: print(model)",
          "symPyProgram": "from sympy import Symbol\nfrom sympy import simplify\nfrom sympy.core.relational import Eq, Ne, StrictGreaterThan, StrictLessThan, LessThan, GreaterThan\nfrom sympy.printing import ccode\n\nsrc = Symbol('src')\ndestDir = Symbol('destDir')\nsrc_isFile = Symbol('src_isFile')\nsrc_isDirectory = Symbol('src_isDirectory')\nsrc_exists = Symbol('src_exists')\nnull = Symbol('null')\npath_conjunction = ((((((~((Eq(src, null)))) & (~(src_isFile))) & src_isDirectory) & (~((Eq(src, null))))) & (~((src_exists & (~(src_isDirectory)))))) & (Eq(destDir, null)))\nprint(ccode(simplify(path_conjunction)))",
          "soundSymbolic": false,
          "soundBackwards": true,
          "maybe": true,
          "line": 1559,
          "throwingLine": 1566,
          "isStatic": true,
          "targetOnlyArguments": true
        },
        {
          "qualifiedSignature": "org.apache.commons.io.FileUtils.copyToDirectory(java.io.File, java.io.File)",
          "exception": "throw new IllegalArgumentException(\"Destination '\" + destDir + \"' is not a directory\")",
          "pathCojunction": "(!(src == null)) && (src.isFile()) && (!(destDir == null)) && (destDir.exists() && destDir.isDirectory() == false)",
          "symbolicPathConjunction": "(!(src == null)) && (src.isFile()) && (copyFileToDirectory(src, destDir))",
          "backwardsPathConjunction": "(!(src == null)) && (src.isFile()) && (!(destDir == null)) && (destDir.exists() && destDir.isDirectory() == false)",
          "simplifiedPathConjunction": "destDir.exists() && src.isFile() && !destDir.isDirectory() && destDir != null && null != src",
          "z3Program": "from z3 import *\nfrom z3_all_models import *\n\nsrc0_isNull = Bool('src0_isNull')\ndestDir0_isNull = Bool('destDir0_isNull')\n\nconstraints = [\n  And(And(And(Not(src0_isNull), src0.isFile()), Not(destDir0_isNull)), And(destDir0.exists(), destDir0.isDirectory() == False))\n]\n\nsolver = Solver()\nfor constraint in constraints:\n  solver.add(constraint)\n\nmodels = list(all_smt(solver))\nfor model in models: print(model)",
          "symPyProgram": "from sympy import Symbol\nfrom sympy import simplify\nfrom sympy.core.relational import Eq, Ne, StrictGreaterThan, StrictLessThan, LessThan, GreaterThan\nfrom sympy.printing import ccode\n\nsrc = Symbol('src')\ndestDir = Symbol('destDir')\nsrc_isFile = Symbol('src_isFile')\ndestDir_exists = Symbol('destDir_exists')\ndestDir_isDirectory = Symbol('destDir_isDirectory')\nnull = Symbol('null')\npath_conjunction = ((((~((Eq(src, null)))) & src_isFile) & (~((Eq(destDir, null))))) & (destDir_exists & (~(destDir_isDirectory))))\nprint(ccode(simplify(path_conjunction)))",
          "soundSymbolic": false,
          "soundBackwards": true,
          "maybe": true,
          "line": 1559,
          "throwingLine": 1564,
          "isStatic": true,
          "targetOnlyArguments": true
        },
        {
          "qualifiedSignature": "org.apache.commons.io.FileUtils.copyToDirectory(java.io.File, java.io.File)",
          "exception": "throw new IOException(\"The source \" + src + \" does not exist\");",
          "pathCojunction": "(!(src == null)) && (!(src.isFile())) && (!(src.isDirectory()))",
          "symbolicPathConjunction": "(!(src == null)) && (!(src.isFile())) && (!(src.isDirectory()))",
          "backwardsPathConjunction": "(!(src == null)) && (!(src.isFile())) && (!(src.isDirectory()))",
          "simplifiedPathConjunction": "!src.isDirectory() && !src.isFile() && null != src",
          "z3Program": "from z3 import *\nfrom z3_all_models import *\n\nsrc0_isNull = Bool('src0_isNull')\n\nconstraints = [\n  And(And(Not(src0_isNull), Not(src0.isFile())), Not(src0.isDirectory()))\n]\n\nsolver = Solver()\nfor constraint in constraints:\n  solver.add(constraint)\n\nmodels = list(all_smt(solver))\nfor model in models: print(model)",
          "symPyProgram": "from sympy import Symbol\nfrom sympy import simplify\nfrom sympy.core.relational import Eq, Ne, StrictGreaterThan, StrictLessThan, LessThan, GreaterThan\nfrom sympy.printing import ccode\n\nsrc = Symbol('src')\nsrc_isFile = Symbol('src_isFile')\nsrc_isDirectory = Symbol('src_isDirectory')\nnull = Symbol('null')\npath_conjunction = (((~((Eq(src, null)))) & (~(src_isFile))) & (~(src_isDirectory)))\nprint(ccode(simplify(path_conjunction)))",
          "soundSymbolic": false,
          "soundBackwards": true,
          "maybe": true,
          "line": 1559,
          "throwingLine": 1568,
          "isStatic": true,
          "targetOnlyArguments": true
        },
        {
          "qualifiedSignature": "org.apache.commons.io.FileUtils.copyToDirectory(java.io.File, java.io.File)",
          "exception": "throw new NullPointerException(\"Source must not be null\");",
          "pathCojunction": "(src == null)",
          "symbolicPathConjunction": "(src == null)",
          "backwardsPathConjunction": "(src == null)",
          "simplifiedPathConjunction": "null == src",
          "z3Inputs": "[src0_isNull = True]\n",
          "z3Program": "from z3 import *\nfrom z3_all_models import *\n\nsrc0_isNull = Bool('src0_isNull')\n\nconstraints = [\n  src0_isNull\n]\n\nsolver = Solver()\nfor constraint in constraints:\n  solver.add(constraint)\n\nmodels = list(all_smt(solver))\nfor model in models: print(model)",
          "symPyProgram": "from sympy import Symbol\nfrom sympy import simplify\nfrom sympy.core.relational import Eq, Ne, StrictGreaterThan, StrictLessThan, LessThan, GreaterThan\nfrom sympy.printing import ccode\n\nsrc = Symbol('src')\nnull = Symbol('null')\npath_conjunction = (Eq(src, null))\nprint(ccode(simplify(path_conjunction)))",
          "soundSymbolic": true,
          "soundBackwards": true,
          "maybe": false,
          "line": 1559,
          "throwingLine": 1561,
          "isStatic": true,
          "targetOnlyArguments": true
        },
        {
          "qualifiedSignature": "org.apache.commons.io.FileUtils.copyToDirectory(java.io.File, java.io.File)",
          "exception": "throw new NullPointerException(\"Destination must not be null\")",
          "pathCojunction": "(!(src == null)) && (src.isFile()) && (destDir == null)",
          "symbolicPathConjunction": "(!(src == null)) && (src.isFile()) && (copyFileToDirectory(src, destDir))",
          "backwardsPathConjunction": "(!(src == null)) && (src.isFile()) && (destDir == null)",
          "simplifiedPathConjunction": "src.isFile() && destDir == null && null != src",
          "z3Program": "from z3 import *\nfrom z3_all_models import *\n\nsrc0_isNull = Bool('src0_isNull')\ndestDir0_isNull = Bool('destDir0_isNull')\n\nconstraints = [\n  And(And(Not(src0_isNull), src0.isFile()), destDir0_isNull)\n]\n\nsolver = Solver()\nfor constraint in constraints:\n  solver.add(constraint)\n\nmodels = list(all_smt(solver))\nfor model in models: print(model)",
          "symPyProgram": "from sympy import Symbol\nfrom sympy import simplify\nfrom sympy.core.relational import Eq, Ne, StrictGreaterThan, StrictLessThan, LessThan, GreaterThan\nfrom sympy.printing import ccode\n\nsrc = Symbol('src')\ndestDir = Symbol('destDir')\nsrc_isFile = Symbol('src_isFile')\nnull = Symbol('null')\npath_conjunction = (((~((Eq(src, null)))) & src_isFile) & (Eq(destDir, null)))\nprint(ccode(simplify(path_conjunction)))",
          "soundSymbolic": false,
          "soundBackwards": true,
          "maybe": true,
          "line": 1559,
          "throwingLine": 1564,
          "isStatic": true,
          "targetOnlyArguments": true
        },
        {
          "qualifiedSignature": "org.apache.commons.io.FileUtils.deleteDirectory(java.io.File)",
          "exception": "throw new NullPointerException(\"File must not be null\")",
          "pathCojunction": "(!(!directory.exists())) && (directory == null)",
          "symbolicPathConjunction": "(!(!directory.exists())) && (!(isSymlink(directory)))",
          "backwardsPathConjunction": "(!(!directory.exists())) && (directory == null)",
          "simplifiedPathConjunction": "directory.exists() && directory == null",
          "z3Program": "from z3 import *\nfrom z3_all_models import *\n\ndirectory0_isNull = Bool('directory0_isNull')\n\nconstraints = [\n  And(Not(Not(directory0.exists())), directory0_isNull)\n]\n\nsolver = Solver()\nfor constraint in constraints:\n  solver.add(constraint)\n\nmodels = list(all_smt(solver))\nfor model in models: print(model)",
          "symPyProgram": "from sympy import Symbol\nfrom sympy import simplify\nfrom sympy.core.relational import Eq, Ne, StrictGreaterThan, StrictLessThan, LessThan, GreaterThan\nfrom sympy.printing import ccode\n\ndirectory = Symbol('directory')\ndirectory_exists = Symbol('directory_exists')\nnull = Symbol('null')\npath_conjunction = ((~((~(directory_exists)))) & (Eq(directory, null)))\nprint(ccode(simplify(path_conjunction)))",
          "soundSymbolic": false,
          "soundBackwards": true,
          "maybe": true,
          "line": 1611,
          "throwingLine": 1616,
          "isStatic": true,
          "targetOnlyArguments": true
        },
        {
          "qualifiedSignature": "org.apache.commons.io.FileUtils.deleteDirectory(java.io.File)",
          "exception": "throw new IOException(message);",
          "pathCojunction": "(!(!directory.exists())) && (!(directory == null)) && (!(Files.isSymbolicLink(directory.toPath()))) && (!(directory.delete()))",
          "symbolicPathConjunction": "(!(!directory.exists())) && (!(isSymlink(directory))) && (!isSymlink(directory)) && (!directory.delete())",
          "backwardsPathConjunction": "(!(!directory.exists())) && (!(directory == null)) && (!(Files.isSymbolicLink(directory.toPath()))) && (!(directory.delete()))",
          "simplifiedPathConjunction": "directory.exists() && !Files.isSymbolicLink(directory.toPath()) && !directory.delete() && directory != null",
          "z3Program": "from z3 import *\nfrom z3_all_models import *\n\nmessage0 = String('message0')\ndirectory0_isNull = Bool('directory0_isNull')\n\nconstraints = [\n  message0 == \"Unable to delete directory \" + directory0 + \".\",\n  And(And(And(Not(Not(directory0.exists())), Not(directory0_isNull)), Not(Files.isSymbolicLink(directory0.toPath()))), Not(directory0.delete()))\n]\n\nsolver = Solver()\nfor constraint in constraints:\n  solver.add(constraint)\n\nmodels = list(all_smt(solver))\nfor model in models: print(model)",
          "symPyProgram": "from sympy import Symbol\nfrom sympy import simplify\nfrom sympy.core.relational import Eq, Ne, StrictGreaterThan, StrictLessThan, LessThan, GreaterThan\nfrom sympy.printing import ccode\n\ndirectory = Symbol('directory')\ndirectory_exists = Symbol('directory_exists')\nFiles_isSymbolicLink = Symbol('Files_isSymbolicLink')\ndirectory_toPath = Symbol('directory_toPath')\ndirectory_delete = Symbol('directory_delete')\nnull = Symbol('null')\npath_conjunction = ((((~((~(directory_exists)))) & (~((Eq(directory, null))))) & (~(Files_isSymbolicLink))) & (~(directory_delete)))\nprint(ccode(simplify(path_conjunction)))",
          "soundSymbolic": false,
          "soundBackwards": false,
          "maybe": true,
          "line": 1611,
          "throwingLine": 1623,
          "isStatic": true,
          "targetOnlyArguments": false
        },
        {
          "qualifiedSignature": "org.apache.commons.io.FileUtils.deleteDirectory(java.io.File)",
          "exception": "throw new IOException(message);",
          "pathCojunction": "(!(!directory.exists())) && (!(directory == null)) && (!(!Files.isSymbolicLink(directory.toPath()))) && (!(directory.delete()))",
          "symbolicPathConjunction": "(!(!directory.exists())) && (!(isSymlink(directory))) && (!(!isSymlink(directory))) && (!directory.delete())",
          "backwardsPathConjunction": "(!(!directory.exists())) && (!(directory == null)) && (!(!Files.isSymbolicLink(directory.toPath()))) && (!(directory.delete()))",
          "simplifiedPathConjunction": "Files.isSymbolicLink(directory.toPath()) && directory.exists() && !directory.delete() && directory != null",
          "z3Program": "from z3 import *\nfrom z3_all_models import *\n\nmessage0 = String('message0')\ndirectory0_isNull = Bool('directory0_isNull')\n\nconstraints = [\n  message0 == \"Unable to delete directory \" + directory0 + \".\",\n  And(And(And(Not(Not(directory0.exists())), Not(directory0_isNull)), Not(Not(Files.isSymbolicLink(directory0.toPath())))), Not(directory0.delete()))\n]\n\nsolver = Solver()\nfor constraint in constraints:\n  solver.add(constraint)\n\nmodels = list(all_smt(solver))\nfor model in models: print(model)",
          "symPyProgram": "from sympy import Symbol\nfrom sympy import simplify\nfrom sympy.core.relational import Eq, Ne, StrictGreaterThan, StrictLessThan, LessThan, GreaterThan\nfrom sympy.printing import ccode\n\ndirectory = Symbol('directory')\ndirectory_exists = Symbol('directory_exists')\nFiles_isSymbolicLink = Symbol('Files_isSymbolicLink')\ndirectory_toPath = Symbol('directory_toPath')\ndirectory_delete = Symbol('directory_delete')\nnull = Symbol('null')\npath_conjunction = ((((~((~(directory_exists)))) & (~((Eq(directory, null))))) & (~((~(Files_isSymbolicLink))))) & (~(directory_delete)))\nprint(ccode(simplify(path_conjunction)))",
          "soundSymbolic": false,
          "soundBackwards": false,
          "maybe": true,
          "line": 1611,
          "throwingLine": 1623,
          "isStatic": true,
          "targetOnlyArguments": false
        },
        {
          "qualifiedSignature": "org.apache.commons.io.FileUtils.directoryContains(java.io.File, java.io.File)",
          "exception": "throw new IllegalArgumentException(\"Directory must not be null\");",
          "pathCojunction": "(directory == null)",
          "symbolicPathConjunction": "(directory == null)",
          "backwardsPathConjunction": "(directory == null)",
          "simplifiedPathConjunction": "directory == null",
          "z3Inputs": "[directory0_isNull = True]\n",
          "z3Program": "from z3 import *\nfrom z3_all_models import *\n\ndirectory0_isNull = Bool('directory0_isNull')\n\nconstraints = [\n  directory0_isNull\n]\n\nsolver = Solver()\nfor constraint in constraints:\n  solver.add(constraint)\n\nmodels = list(all_smt(solver))\nfor model in models: print(model)",
          "symPyProgram": "from sympy import Symbol\nfrom sympy import simplify\nfrom sympy.core.relational import Eq, Ne, StrictGreaterThan, StrictLessThan, LessThan, GreaterThan\nfrom sympy.printing import ccode\n\ndirectory = Symbol('directory')\nnull = Symbol('null')\npath_conjunction = (Eq(directory, null))\nprint(ccode(simplify(path_conjunction)))",
          "soundSymbolic": true,
          "soundBackwards": true,
          "maybe": false,
          "line": 1682,
          "throwingLine": 1686,
          "isStatic": true,
          "targetOnlyArguments": true
        },
        {
          "qualifiedSignature": "org.apache.commons.io.FileUtils.directoryContains(java.io.File, java.io.File)",
          "exception": "throw new IllegalArgumentException(\"Directory must not be null\");",
          "pathCojunction": "(!(directory == null)) && (!(!directory.isDirectory())) && (!(child == null)) && (!(!directory.exists() || !child.exists())) && (canonicalParent == null)",
          "symbolicPathConjunction": "(!(directory == null)) && (!(!directory.isDirectory())) && (!(child == null)) && (!(!directory.exists() || !child.exists())) && (FilenameUtils.directoryContains(canonicalParent, canonicalChild))",
          "backwardsPathConjunction": "(!(directory == null)) && (!(!directory.isDirectory())) && (!(child == null)) && (!(!directory.exists() || !child.exists())) && (directory.getCanonicalPath() == null)",
          "simplifiedPathConjunction": "child.exists() && directory.exists() && directory.isDirectory() && directory.getCanonicalPath() == null && child != null && directory != null",
          "z3Program": "from z3 import *\nfrom z3_all_models import *\n\ncanonicalParent0 = String('canonicalParent0')\ncanonicalChild0 = String('canonicalChild0')\ndirectory0_isNull = Bool('directory0_isNull')\nchild0_isNull = Bool('child0_isNull')\ncanonicalParent0_isNull = Bool('canonicalParent0_isNull')\n\nconstraints = [\n  canonicalParent0 == directory0.getCanonicalPath(),\n  canonicalChild0 == child0.getCanonicalPath(),\n  And(And(And(And(Not(directory0_isNull), Not(Not(directory0.isDirectory()))), Not(child0_isNull)), Not(Or(Not(directory0.exists()), Not(child0.exists())))), canonicalParent0_isNull)\n]\n\nsolver = Solver()\nfor constraint in constraints:\n  solver.add(constraint)\n\nmodels = list(all_smt(solver))\nfor model in models: print(model)",
          "symPyProgram": "from sympy import Symbol\nfrom sympy import simplify\nfrom sympy.core.relational import Eq, Ne, StrictGreaterThan, StrictLessThan, LessThan, GreaterThan\nfrom sympy.printing import ccode\n\ndirectory = Symbol('directory')\nchild = Symbol('child')\ndirectory_isDirectory = Symbol('directory_isDirectory')\ndirectory_exists = Symbol('directory_exists')\nchild_exists = Symbol('child_exists')\ndirectory_getCanonicalPath = Symbol('directory_getCanonicalPath')\nnull = Symbol('null')\npath_conjunction = (((((~((Eq(directory, null)))) & (~((~(directory_isDirectory))))) & (~((Eq(child, null))))) & (~(((~(directory_exists)) | (~(child_exists)))))) & (Eq(directory_getCanonicalPath, null)))\nprint(ccode(simplify(path_conjunction)))",
          "soundSymbolic": false,
          "soundBackwards": true,
          "maybe": true,
          "line": 1682,
          "throwingLine": 1705,
          "isStatic": true,
          "targetOnlyArguments": false
        },
        {
          "qualifiedSignature": "org.apache.commons.io.FileUtils.directoryContains(java.io.File, java.io.File)",
          "exception": "throw new IllegalArgumentException(\"Not a directory: \" + directory);",
          "pathCojunction": "(!(directory == null)) && (!(directory.isDirectory()))",
          "symbolicPathConjunction": "(!(directory == null)) && (!directory.isDirectory())",
          "backwardsPathConjunction": "(!(directory == null)) && (!(directory.isDirectory()))",
          "simplifiedPathConjunction": "!directory.isDirectory() && directory != null",
          "z3Program": "from z3 import *\nfrom z3_all_models import *\n\ndirectory0_isNull = Bool('directory0_isNull')\n\nconstraints = [\n  And(Not(directory0_isNull), Not(directory0.isDirectory()))\n]\n\nsolver = Solver()\nfor constraint in constraints:\n  solver.add(constraint)\n\nmodels = list(all_smt(solver))\nfor model in models: print(model)",
          "symPyProgram": "from sympy import Symbol\nfrom sympy import simplify\nfrom sympy.core.relational import Eq, Ne, StrictGreaterThan, StrictLessThan, LessThan, GreaterThan\nfrom sympy.printing import ccode\n\ndirectory = Symbol('directory')\ndirectory_isDirectory = Symbol('directory_isDirectory')\nnull = Symbol('null')\npath_conjunction = ((~((Eq(directory, null)))) & (~(directory_isDirectory)))\nprint(ccode(simplify(path_conjunction)))",
          "soundSymbolic": false,
          "soundBackwards": true,
          "maybe": true,
          "line": 1682,
          "throwingLine": 1690,
          "isStatic": true,
          "targetOnlyArguments": true
        },
        {
          "qualifiedSignature": "org.apache.commons.io.FileUtils.forceDelete(java.io.File)",
          "exception": "throw new IOException(message);",
          "pathCojunction": "(!(file.isDirectory())) && (!(file.delete())) && (!(!filePresent))",
          "symbolicPathConjunction": "(!(file.isDirectory())) && (!file.delete()) && (!(!filePresent))",
          "backwardsPathConjunction": "(!(file.isDirectory())) && (!(file.delete())) && (!(!file.exists()))",
          "simplifiedPathConjunction": "file.exists() && !file.delete() && !file.isDirectory()",
          "z3Program": "from z3 import *\nfrom z3_all_models import *\n\nfilePresent0 = Bool('filePresent0')\nmessage0 = String('message0')\n\nconstraints = [\n  filePresent0 == file0.exists(),\n  message0 == \"Unable to delete file: \" + file0,\n  And(And(Not(file0.isDirectory()), Not(file0.delete())), Not(Not(filePresent0)))\n]\n\nsolver = Solver()\nfor constraint in constraints:\n  solver.add(constraint)\n\nmodels = list(all_smt(solver))\nfor model in models: print(model)",
          "symPyProgram": "from sympy import Symbol\nfrom sympy import simplify\nfrom sympy.core.relational import Eq, Ne, StrictGreaterThan, StrictLessThan, LessThan, GreaterThan\nfrom sympy.printing import ccode\n\nfile = Symbol('file')\nfile_isDirectory = Symbol('file_isDirectory')\nfile_delete = Symbol('file_delete')\nfile_exists = Symbol('file_exists')\npath_conjunction = (((~(file_isDirectory)) & (~(file_delete))) & (~((~(file_exists)))))\nprint(ccode(simplify(path_conjunction)))",
          "soundSymbolic": false,
          "soundBackwards": true,
          "maybe": true,
          "line": 2389,
          "throwingLine": 2400,
          "isStatic": true,
          "targetOnlyArguments": false
        },
        {
          "qualifiedSignature": "org.apache.commons.io.FileUtils.forceDelete(java.io.File)",
          "exception": "throw new FileNotFoundException(\"File does not exist: \" + file);",
          "pathCojunction": "(!(file.isDirectory())) && (!(file.delete())) && (!(filePresent))",
          "symbolicPathConjunction": "(!(file.isDirectory())) && (!file.delete()) && (!(filePresent))",
          "backwardsPathConjunction": "(!(file.isDirectory())) && (!(file.delete())) && (!(file.exists()))",
          "simplifiedPathConjunction": "!file.delete() && !file.exists() && !file.isDirectory()",
          "z3Program": "from z3 import *\nfrom z3_all_models import *\n\nfilePresent0 = Bool('filePresent0')\n\nconstraints = [\n  filePresent0 == file0.exists(),\n  And(And(Not(file0.isDirectory()), Not(file0.delete())), Not(filePresent0))\n]\n\nsolver = Solver()\nfor constraint in constraints:\n  solver.add(constraint)\n\nmodels = list(all_smt(solver))\nfor model in models: print(model)",
          "symPyProgram": "from sympy import Symbol\nfrom sympy import simplify\nfrom sympy.core.relational import Eq, Ne, StrictGreaterThan, StrictLessThan, LessThan, GreaterThan\nfrom sympy.printing import ccode\n\nfile = Symbol('file')\nfile_isDirectory = Symbol('file_isDirectory')\nfile_delete = Symbol('file_delete')\nfile_exists = Symbol('file_exists')\npath_conjunction = (((~(file_isDirectory)) & (~(file_delete))) & (~(file_exists)))\nprint(ccode(simplify(path_conjunction)))",
          "soundSymbolic": false,
          "soundBackwards": true,
          "maybe": true,
          "line": 2389,
          "throwingLine": 2396,
          "isStatic": true,
          "targetOnlyArguments": false
        },
        {
          "qualifiedSignature": "org.apache.commons.io.FileUtils.forceDeleteOnExit(java.io.File)",
          "exception": "throw new NullPointerException(\"File must not be null\")",
          "pathCojunction": "(file.isDirectory()) && (!(!file.exists())) && (file == null)",
          "symbolicPathConjunction": "(file.isDirectory()) && ((!(!directory.exists())) && (!(isSymlink(directory))))",
          "backwardsPathConjunction": "(file.isDirectory()) && (!(!file.exists())) && (file == null)",
          "simplifiedPathConjunction": "file.exists() && file.isDirectory() && file == null",
          "z3Program": "from z3 import *\nfrom z3_all_models import *\n\nfile0_isNull = Bool('file0_isNull')\n\nconstraints = [\n  And(And(file0.isDirectory(), Not(Not(file0.exists()))), file0_isNull)\n]\n\nsolver = Solver()\nfor constraint in constraints:\n  solver.add(constraint)\n\nmodels = list(all_smt(solver))\nfor model in models: print(model)",
          "symPyProgram": "from sympy import Symbol\nfrom sympy import simplify\nfrom sympy.core.relational import Eq, Ne, StrictGreaterThan, StrictLessThan, LessThan, GreaterThan\nfrom sympy.printing import ccode\n\nfile = Symbol('file')\nfile_isDirectory = Symbol('file_isDirectory')\nfile_exists = Symbol('file_exists')\nnull = Symbol('null')\npath_conjunction = ((file_isDirectory & (~((~(file_exists))))) & (Eq(file, null)))\nprint(ccode(simplify(path_conjunction)))",
          "soundSymbolic": false,
          "soundBackwards": true,
          "maybe": true,
          "line": 2413,
          "throwingLine": 2415,
          "isStatic": true,
          "targetOnlyArguments": true
        },
        {
          "qualifiedSignature": "org.apache.commons.io.FileUtils.forceMkdir(java.io.File)",
          "exception": "throw new IOException(message);",
          "pathCojunction": "(!(directory.exists())) && (!(directory.mkdirs())) && (!(directory.isDirectory()))",
          "symbolicPathConjunction": "(!(directory.exists())) && (!directory.mkdirs()) && (!directory.isDirectory())",
          "backwardsPathConjunction": "(!(directory.exists())) && (!(directory.mkdirs())) && (!(directory.isDirectory()))",
          "simplifiedPathConjunction": "!directory.exists() && !directory.isDirectory() && !directory.mkdirs()",
          "z3Program": "from z3 import *\nfrom z3_all_models import *\n\nmessage0 = String('message0')\n\nconstraints = [\n  message0 == \"Unable to create directory \" + directory0,\n  And(And(Not(directory0.exists()), Not(directory0.mkdirs())), Not(directory0.isDirectory()))\n]\n\nsolver = Solver()\nfor constraint in constraints:\n  solver.add(constraint)\n\nmodels = list(all_smt(solver))\nfor model in models: print(model)",
          "symPyProgram": "from sympy import Symbol\nfrom sympy import simplify\nfrom sympy.core.relational import Eq, Ne, StrictGreaterThan, StrictLessThan, LessThan, GreaterThan\nfrom sympy.printing import ccode\n\ndirectory = Symbol('directory')\ndirectory_exists = Symbol('directory_exists')\ndirectory_mkdirs = Symbol('directory_mkdirs')\ndirectory_isDirectory = Symbol('directory_isDirectory')\npath_conjunction = (((~(directory_exists)) & (~(directory_mkdirs))) & (~(directory_isDirectory)))\nprint(ccode(simplify(path_conjunction)))",
          "soundSymbolic": false,
          "soundBackwards": true,
          "maybe": true,
          "line": 2474,
          "throwingLine": 2491,
          "isStatic": true,
          "targetOnlyArguments": true
        },
        {
          "qualifiedSignature": "org.apache.commons.io.FileUtils.forceMkdir(java.io.File)",
          "exception": "throw new IOException(message);",
          "pathCojunction": "(directory.exists()) && (!(directory.isDirectory()))",
          "symbolicPathConjunction": "(directory.exists()) && (!directory.isDirectory())",
          "backwardsPathConjunction": "(directory.exists()) && (!(directory.isDirectory()))",
          "simplifiedPathConjunction": "directory.exists() && !directory.isDirectory()",
          "z3Program": "from z3 import *\nfrom z3_all_models import *\n\nmessage0 = String('message0')\n\nconstraints = [\n  message0 == \"File \" + directory0 + \" exists and is \" + \"not a directory. Unable to create directory.\",\n  And(directory0.exists(), Not(directory0.isDirectory()))\n]\n\nsolver = Solver()\nfor constraint in constraints:\n  solver.add(constraint)\n\nmodels = list(all_smt(solver))\nfor model in models: print(model)",
          "symPyProgram": "from sympy import Symbol\nfrom sympy import simplify\nfrom sympy.core.relational import Eq, Ne, StrictGreaterThan, StrictLessThan, LessThan, GreaterThan\nfrom sympy.printing import ccode\n\ndirectory = Symbol('directory')\ndirectory_exists = Symbol('directory_exists')\ndirectory_isDirectory = Symbol('directory_isDirectory')\npath_conjunction = (directory_exists & (~(directory_isDirectory)))\nprint(ccode(simplify(path_conjunction)))",
          "soundSymbolic": false,
          "soundBackwards": true,
          "maybe": true,
          "line": 2474,
          "throwingLine": 2482,
          "isStatic": true,
          "targetOnlyArguments": true
        },
        {
          "qualifiedSignature": "org.apache.commons.io.FileUtils.forceMkdirParent(java.io.File)",
          "exception": "throw new IOException(message)",
          "pathCojunction": "(!(parent == null)) && (parent.exists()) && (!(parent.isDirectory()))",
          "symbolicPathConjunction": "(!(parent == null)) && (!(forceMkdir(parent)))",
          "backwardsPathConjunction": "(!(file.getParentFile() == null)) && (file.getParentFile().exists()) && (!(file.getParentFile().isDirectory()))",
          "simplifiedPathConjunction": "file.getParentFile()_exists && !file.getParentFile()_isDirectory && file.getParentFile() != null",
          "z3Program": "from z3 import *\nfrom z3_all_models import *\n\nparent0_isNull = Bool('parent0_isNull')\n\nconstraints = [\n  parent0 == file0.getParentFile(),\n  And(And(Not(parent0_isNull), parent0.exists()), Not(parent0.isDirectory()))\n]\n\nsolver = Solver()\nfor constraint in constraints:\n  solver.add(constraint)\n\nmodels = list(all_smt(solver))\nfor model in models: print(model)",
          "symPyProgram": "from sympy import Symbol\nfrom sympy import simplify\nfrom sympy.core.relational import Eq, Ne, StrictGreaterThan, StrictLessThan, LessThan, GreaterThan\nfrom sympy.printing import ccode\n\nfile = Symbol('file')\nfile_getParentFile = Symbol('file_getParentFile')\nfile_getParentFile_exists = Symbol('file_getParentFile_exists')\nfile_getParentFile_isDirectory = Symbol('file_getParentFile_isDirectory')\nnull = Symbol('null')\npath_conjunction = (((~((Eq(file_getParentFile, null)))) & file_getParentFile_exists) & (~(file_getParentFile_isDirectory)))\nprint(ccode(simplify(path_conjunction)))",
          "soundSymbolic": false,
          "soundBackwards": true,
          "maybe": true,
          "line": 2506,
          "throwingLine": 2511,
          "isStatic": true,
          "targetOnlyArguments": false
        },
        {
          "qualifiedSignature": "org.apache.commons.io.FileUtils.forceMkdirParent(java.io.File)",
          "exception": "throw new IOException(message)",
          "pathCojunction": "(!(parent == null)) && (!(parent.exists())) && (!(parent.mkdirs())) && (!(parent.isDirectory()))",
          "symbolicPathConjunction": "(!(parent == null)) && (!(forceMkdir(parent)))",
          "backwardsPathConjunction": "(!(file.getParentFile() == null)) && (!(file.getParentFile().exists())) && (!(file.getParentFile().mkdirs())) && (!(file.getParentFile().isDirectory()))",
          "simplifiedPathConjunction": "!file.getParentFile()_exists && !file.getParentFile()_isDirectory && !file.getParentFile()_mkdirs && file.getParentFile() != null",
          "z3Program": "from z3 import *\nfrom z3_all_models import *\n\nparent0_isNull = Bool('parent0_isNull')\n\nconstraints = [\n  parent0 == file0.getParentFile(),\n  And(And(And(Not(parent0_isNull), Not(parent0.exists())), Not(parent0.mkdirs())), Not(parent0.isDirectory()))\n]\n\nsolver = Solver()\nfor constraint in constraints:\n  solver.add(constraint)\n\nmodels = list(all_smt(solver))\nfor model in models: print(model)",
          "symPyProgram": "from sympy import Symbol\nfrom sympy import simplify\nfrom sympy.core.relational import Eq, Ne, StrictGreaterThan, StrictLessThan, LessThan, GreaterThan\nfrom sympy.printing import ccode\n\nfile = Symbol('file')\nfile_getParentFile = Symbol('file_getParentFile')\nfile_getParentFile_exists = Symbol('file_getParentFile_exists')\nfile_getParentFile_mkdirs = Symbol('file_getParentFile_mkdirs')\nfile_getParentFile_isDirectory = Symbol('file_getParentFile_isDirectory')\nnull = Symbol('null')\npath_conjunction = ((((~((Eq(file_getParentFile, null)))) & (~(file_getParentFile_exists))) & (~(file_getParentFile_mkdirs))) & (~(file_getParentFile_isDirectory)))\nprint(ccode(simplify(path_conjunction)))",
          "soundSymbolic": false,
          "soundBackwards": true,
          "maybe": true,
          "line": 2506,
          "throwingLine": 2511,
          "isStatic": true,
          "targetOnlyArguments": false
        },
        {
          "qualifiedSignature": "org.apache.commons.io.FileUtils.sizeOf(java.io.File)",
          "exception": "throw new IllegalArgumentException(message);",
          "pathCojunction": "(!(file.exists()))",
          "symbolicPathConjunction": "(!file.exists())",
          "backwardsPathConjunction": "(!(file.exists()))",
          "simplifiedPathConjunction": "!file.exists()",
          "z3Program": "from z3 import *\nfrom z3_all_models import *\n\nmessage0 = String('message0')\n\nconstraints = [\n  message0 == file0 + \" does not exist\",\n  Not(file0.exists())\n]\n\nsolver = Solver()\nfor constraint in constraints:\n  solver.add(constraint)\n\nmodels = list(all_smt(solver))\nfor model in models: print(model)",
          "symPyProgram": "from sympy import Symbol\nfrom sympy import simplify\nfrom sympy.core.relational import Eq, Ne, StrictGreaterThan, StrictLessThan, LessThan, GreaterThan\nfrom sympy.printing import ccode\n\nfile = Symbol('file')\nfile_exists = Symbol('file_exists')\npath_conjunction = (~(file_exists))\nprint(ccode(simplify(path_conjunction)))",
          "soundSymbolic": false,
          "soundBackwards": true,
          "maybe": true,
          "line": 2537,
          "throwingLine": 2541,
          "isStatic": true,
          "targetOnlyArguments": true
        },
        {
          "qualifiedSignature": "org.apache.commons.io.FileUtils.sizeOfAsBigInteger(java.io.File)",
          "exception": "throw new IllegalArgumentException(message);",
          "pathCojunction": "(!(file.exists()))",
          "symbolicPathConjunction": "(!file.exists())",
          "backwardsPathConjunction": "(!(file.exists()))",
          "simplifiedPathConjunction": "!file.exists()",
          "z3Program": "from z3 import *\nfrom z3_all_models import *\n\nmessage0 = String('message0')\n\nconstraints = [\n  message0 == file0 + \" does not exist\",\n  Not(file0.exists())\n]\n\nsolver = Solver()\nfor constraint in constraints:\n  solver.add(constraint)\n\nmodels = list(all_smt(solver))\nfor model in models: print(model)",
          "symPyProgram": "from sympy import Symbol\nfrom sympy import simplify\nfrom sympy.core.relational import Eq, Ne, StrictGreaterThan, StrictLessThan, LessThan, GreaterThan\nfrom sympy.printing import ccode\n\nfile = Symbol('file')\nfile_exists = Symbol('file_exists')\npath_conjunction = (~(file_exists))\nprint(ccode(simplify(path_conjunction)))",
          "soundSymbolic": false,
          "soundBackwards": true,
          "maybe": true,
          "line": 2570,
          "throwingLine": 2574,
          "isStatic": true,
          "targetOnlyArguments": true
        },
        {
          "qualifiedSignature": "org.apache.commons.io.FileUtils.sizeOfDirectory(java.io.File)",
          "exception": "throw new IllegalArgumentException(directory + \" does not exist\");",
          "pathCojunction": "(!(directory.exists()))",
          "symbolicPathConjunction": "(!directory.exists())",
          "backwardsPathConjunction": "(!(directory.exists()))",
          "simplifiedPathConjunction": "!directory.exists()",
          "z3Program": "from z3 import *\nfrom z3_all_models import *\n\n\nconstraints = [\n  Not(directory0.exists())\n]\n\nsolver = Solver()\nfor constraint in constraints:\n  solver.add(constraint)\n\nmodels = list(all_smt(solver))\nfor model in models: print(model)",
          "symPyProgram": "from sympy import Symbol\nfrom sympy import simplify\nfrom sympy.core.relational import Eq, Ne, StrictGreaterThan, StrictLessThan, LessThan, GreaterThan\nfrom sympy.printing import ccode\n\ndirectory = Symbol('directory')\ndirectory_exists = Symbol('directory_exists')\npath_conjunction = (~(directory_exists))\nprint(ccode(simplify(path_conjunction)))",
          "soundSymbolic": true,
          "soundBackwards": true,
          "maybe": true,
          "line": 2597,
          "throwingLine": 2598,
          "isStatic": true,
          "targetOnlyArguments": true
        },
        {
          "qualifiedSignature": "org.apache.commons.io.FileUtils.sizeOfDirectory(java.io.File)",
          "exception": "throw new IllegalArgumentException(directory + \" is not a directory\");",
          "pathCojunction": "(!(!directory.exists())) && (!(directory.isDirectory()))",
          "symbolicPathConjunction": "((!(!directory.exists())) && (!directory.isDirectory()))",
          "backwardsPathConjunction": "(!(!directory.exists())) && (!(directory.isDirectory()))",
          "simplifiedPathConjunction": "directory.exists() && !directory.isDirectory()",
          "z3Program": "from z3 import *\nfrom z3_all_models import *\n\n\nconstraints = [\n  And(Not(Not(directory0.exists())), Not(directory0.isDirectory()))\n]\n\nsolver = Solver()\nfor constraint in constraints:\n  solver.add(constraint)\n\nmodels = list(all_smt(solver))\nfor model in models: print(model)",
          "symPyProgram": "from sympy import Symbol\nfrom sympy import simplify\nfrom sympy.core.relational import Eq, Ne, StrictGreaterThan, StrictLessThan, LessThan, GreaterThan\nfrom sympy.printing import ccode\n\ndirectory = Symbol('directory')\ndirectory_exists = Symbol('directory_exists')\ndirectory_isDirectory = Symbol('directory_isDirectory')\npath_conjunction = ((~((~(directory_exists)))) & (~(directory_isDirectory)))\nprint(ccode(simplify(path_conjunction)))",
          "soundSymbolic": true,
          "soundBackwards": true,
          "maybe": true,
          "line": 2597,
          "throwingLine": 2598,
          "isStatic": true,
          "targetOnlyArguments": true
        },
        {
          "qualifiedSignature": "org.apache.commons.io.FileUtils.sizeOfDirectoryAsBigInteger(java.io.File)",
          "exception": "throw new IllegalArgumentException(directory + \" is not a directory\");",
          "pathCojunction": "(!(!directory.exists())) && (!(directory.isDirectory()))",
          "symbolicPathConjunction": "((!(!directory.exists())) && (!directory.isDirectory()))",
          "backwardsPathConjunction": "(!(!directory.exists())) && (!(directory.isDirectory()))",
          "simplifiedPathConjunction": "directory.exists() && !directory.isDirectory()",
          "z3Program": "from z3 import *\nfrom z3_all_models import *\n\n\nconstraints = [\n  And(Not(Not(directory0.exists())), Not(directory0.isDirectory()))\n]\n\nsolver = Solver()\nfor constraint in constraints:\n  solver.add(constraint)\n\nmodels = list(all_smt(solver))\nfor model in models: print(model)",
          "symPyProgram": "from sympy import Symbol\nfrom sympy import simplify\nfrom sympy.core.relational import Eq, Ne, StrictGreaterThan, StrictLessThan, LessThan, GreaterThan\nfrom sympy.printing import ccode\n\ndirectory = Symbol('directory')\ndirectory_exists = Symbol('directory_exists')\ndirectory_isDirectory = Symbol('directory_isDirectory')\npath_conjunction = ((~((~(directory_exists)))) & (~(directory_isDirectory)))\nprint(ccode(simplify(path_conjunction)))",
          "soundSymbolic": true,
          "soundBackwards": true,
          "maybe": true,
          "line": 2655,
          "throwingLine": 2656,
          "isStatic": true,
          "targetOnlyArguments": true
        },
        {
          "qualifiedSignature": "org.apache.commons.io.FileUtils.sizeOfDirectoryAsBigInteger(java.io.File)",
          "exception": "throw new IllegalArgumentException(directory + \" does not exist\");",
          "pathCojunction": "(!(directory.exists()))",
          "symbolicPathConjunction": "(!directory.exists())",
          "backwardsPathConjunction": "(!(directory.exists()))",
          "simplifiedPathConjunction": "!directory.exists()",
          "z3Program": "from z3 import *\nfrom z3_all_models import *\n\n\nconstraints = [\n  Not(directory0.exists())\n]\n\nsolver = Solver()\nfor constraint in constraints:\n  solver.add(constraint)\n\nmodels = list(all_smt(solver))\nfor model in models: print(model)",
          "symPyProgram": "from sympy import Symbol\nfrom sympy import simplify\nfrom sympy.core.relational import Eq, Ne, StrictGreaterThan, StrictLessThan, LessThan, GreaterThan\nfrom sympy.printing import ccode\n\ndirectory = Symbol('directory')\ndirectory_exists = Symbol('directory_exists')\npath_conjunction = (~(directory_exists))\nprint(ccode(simplify(path_conjunction)))",
          "soundSymbolic": true,
          "soundBackwards": true,
          "maybe": true,
          "line": 2655,
          "throwingLine": 2656,
          "isStatic": true,
          "targetOnlyArguments": true
        },
        {
          "qualifiedSignature": "org.apache.commons.io.FileUtils.isFileNewer(java.io.File, java.io.File)",
          "exception": "throw new IllegalArgumentException(\"No specified file\")",
          "pathCojunction": "(!(reference == null)) && (!(!reference.exists())) && (file == null)",
          "symbolicPathConjunction": "(!(reference == null)) && (!(!reference.exists())) && (isFileNewer(file, reference.lastModified()))",
          "backwardsPathConjunction": "(!(reference == null)) && (!(!reference.exists())) && (file == null)",
          "simplifiedPathConjunction": "reference.exists() && file == null && null != reference",
          "z3Program": "from z3 import *\nfrom z3_all_models import *\n\nreference0_isNull = Bool('reference0_isNull')\nfile0_isNull = Bool('file0_isNull')\n\nconstraints = [\n  And(And(Not(reference0_isNull), Not(Not(reference0.exists()))), file0_isNull)\n]\n\nsolver = Solver()\nfor constraint in constraints:\n  solver.add(constraint)\n\nmodels = list(all_smt(solver))\nfor model in models: print(model)",
          "symPyProgram": "from sympy import Symbol\nfrom sympy import simplify\nfrom sympy.core.relational import Eq, Ne, StrictGreaterThan, StrictLessThan, LessThan, GreaterThan\nfrom sympy.printing import ccode\n\nfile = Symbol('file')\nreference = Symbol('reference')\nreference_exists = Symbol('reference_exists')\nnull = Symbol('null')\npath_conjunction = (((~((Eq(reference, null)))) & (~((~(reference_exists))))) & (Eq(file, null)))\nprint(ccode(simplify(path_conjunction)))",
          "soundSymbolic": false,
          "soundBackwards": true,
          "maybe": true,
          "line": 2732,
          "throwingLine": 2740,
          "isStatic": true,
          "targetOnlyArguments": true
        },
        {
          "qualifiedSignature": "org.apache.commons.io.FileUtils.isFileNewer(java.io.File, java.io.File)",
          "exception": "throw new IllegalArgumentException(\"The reference file '\" + reference + \"' doesn't exist\");",
          "pathCojunction": "(!(reference == null)) && (!(reference.exists()))",
          "symbolicPathConjunction": "(!(reference == null)) && (!reference.exists())",
          "backwardsPathConjunction": "(!(reference == null)) && (!(reference.exists()))",
          "simplifiedPathConjunction": "!reference.exists() && null != reference",
          "z3Program": "from z3 import *\nfrom z3_all_models import *\n\nreference0_isNull = Bool('reference0_isNull')\n\nconstraints = [\n  And(Not(reference0_isNull), Not(reference0.exists()))\n]\n\nsolver = Solver()\nfor constraint in constraints:\n  solver.add(constraint)\n\nmodels = list(all_smt(solver))\nfor model in models: print(model)",
          "symPyProgram": "from sympy import Symbol\nfrom sympy import simplify\nfrom sympy.core.relational import Eq, Ne, StrictGreaterThan, StrictLessThan, LessThan, GreaterThan\nfrom sympy.printing import ccode\n\nreference = Symbol('reference')\nreference_exists = Symbol('reference_exists')\nnull = Symbol('null')\npath_conjunction = ((~((Eq(reference, null)))) & (~(reference_exists)))\nprint(ccode(simplify(path_conjunction)))",
          "soundSymbolic": false,
          "soundBackwards": true,
          "maybe": true,
          "line": 2732,
          "throwingLine": 2737,
          "isStatic": true,
          "targetOnlyArguments": true
        },
        {
          "qualifiedSignature": "org.apache.commons.io.FileUtils.isFileNewer(java.io.File, java.io.File)",
          "exception": "throw new IllegalArgumentException(\"No specified reference file\");",
          "pathCojunction": "(reference == null)",
          "symbolicPathConjunction": "(reference == null)",
          "backwardsPathConjunction": "(reference == null)",
          "simplifiedPathConjunction": "null == reference",
          "z3Inputs": "[reference0_isNull = True]\n",
          "z3Program": "from z3 import *\nfrom z3_all_models import *\n\nreference0_isNull = Bool('reference0_isNull')\n\nconstraints = [\n  reference0_isNull\n]\n\nsolver = Solver()\nfor constraint in constraints:\n  solver.add(constraint)\n\nmodels = list(all_smt(solver))\nfor model in models: print(model)",
          "symPyProgram": "from sympy import Symbol\nfrom sympy import simplify\nfrom sympy.core.relational import Eq, Ne, StrictGreaterThan, StrictLessThan, LessThan, GreaterThan\nfrom sympy.printing import ccode\n\nreference = Symbol('reference')\nnull = Symbol('null')\npath_conjunction = (Eq(reference, null))\nprint(ccode(simplify(path_conjunction)))",
          "soundSymbolic": true,
          "soundBackwards": true,
          "maybe": false,
          "line": 2732,
          "throwingLine": 2734,
          "isStatic": true,
          "targetOnlyArguments": true
        },
        {
          "qualifiedSignature": "org.apache.commons.io.FileUtils.isFileNewer(java.io.File, java.util.Date)",
          "exception": "throw new IllegalArgumentException(\"No specified file\")",
          "pathCojunction": "(!(date == null)) && (file == null)",
          "symbolicPathConjunction": "(!(date == null)) && (isFileNewer(file, date.getTime()))",
          "backwardsPathConjunction": "(!(date == null)) && (file == null)",
          "simplifiedPathConjunction": "file == null && date != null",
          "z3Inputs": "[file0_isNull = True, date0_isNull = False]\n",
          "z3Program": "from z3 import *\nfrom z3_all_models import *\n\ndate0_isNull = Bool('date0_isNull')\nfile0_isNull = Bool('file0_isNull')\n\nconstraints = [\n  And(Not(date0_isNull), file0_isNull)\n]\n\nsolver = Solver()\nfor constraint in constraints:\n  solver.add(constraint)\n\nmodels = list(all_smt(solver))\nfor model in models: print(model)",
          "symPyProgram": "from sympy import Symbol\nfrom sympy import simplify\nfrom sympy.core.relational import Eq, Ne, StrictGreaterThan, StrictLessThan, LessThan, GreaterThan\nfrom sympy.printing import ccode\n\nfile = Symbol('file')\ndate = Symbol('date')\nnull = Symbol('null')\npath_conjunction = ((~((Eq(date, null)))) & (Eq(file, null)))\nprint(ccode(simplify(path_conjunction)))",
          "soundSymbolic": true,
          "soundBackwards": true,
          "maybe": false,
          "line": 2755,
          "throwingLine": 2759,
          "isStatic": true,
          "targetOnlyArguments": true
        },
        {
          "qualifiedSignature": "org.apache.commons.io.FileUtils.isFileNewer(java.io.File, java.util.Date)",
          "exception": "throw new IllegalArgumentException(\"No specified date\");",
          "pathCojunction": "(date == null)",
          "symbolicPathConjunction": "(date == null)",
          "backwardsPathConjunction": "(date == null)",
          "simplifiedPathConjunction": "date == null",
          "z3Inputs": "[date0_isNull = True]\n",
          "z3Program": "from z3 import *\nfrom z3_all_models import *\n\ndate0_isNull = Bool('date0_isNull')\n\nconstraints = [\n  date0_isNull\n]\n\nsolver = Solver()\nfor constraint in constraints:\n  solver.add(constraint)\n\nmodels = list(all_smt(solver))\nfor model in models: print(model)",
          "symPyProgram": "from sympy import Symbol\nfrom sympy import simplify\nfrom sympy.core.relational import Eq, Ne, StrictGreaterThan, StrictLessThan, LessThan, GreaterThan\nfrom sympy.printing import ccode\n\ndate = Symbol('date')\nnull = Symbol('null')\npath_conjunction = (Eq(date, null))\nprint(ccode(simplify(path_conjunction)))",
          "soundSymbolic": true,
          "soundBackwards": true,
          "maybe": false,
          "line": 2755,
          "throwingLine": 2757,
          "isStatic": true,
          "targetOnlyArguments": true
        },
        {
          "qualifiedSignature": "org.apache.commons.io.FileUtils.isFileNewer(java.io.File, long)",
          "exception": "throw new IllegalArgumentException(\"No specified file\");",
          "pathCojunction": "(file == null)",
          "symbolicPathConjunction": "(file == null)",
          "backwardsPathConjunction": "(file == null)",
          "simplifiedPathConjunction": "file == null",
          "z3Inputs": "[timeMillis0 = -9223372036854775808, file0_isNull = True]\n[file0_isNull = True, timeMillis0 = 0]\n[file0_isNull = True, timeMillis0 = -1]\n[file0_isNull = True, timeMillis0 = -2]\n[file0_isNull = True, timeMillis0 = -3]\n[file0_isNull = True, timeMillis0 = -4]\n[file0_isNull = True, timeMillis0 = -5]\n[file0_isNull = True, timeMillis0 = -6]\n[file0_isNull = True, timeMillis0 = -7]\n[file0_isNull = True, timeMillis0 = -8]\n",
          "z3Program": "from z3 import *\nfrom z3_all_models import *\n\ntimeMillis0 = Int('timeMillis0')\nfile0_isNull = Bool('file0_isNull')\n\nconstraints = [\n  timeMillis0 >= -9223372036854775808, timeMillis0 <= 9223372036854775807, # implicit\n  file0_isNull\n]\n\nsolver = Solver()\nfor constraint in constraints:\n  solver.add(constraint)\n\nmodels = list(all_smt(solver))\nfor model in models: print(model)",
          "symPyProgram": "from sympy import Symbol\nfrom sympy import simplify\nfrom sympy.core.relational import Eq, Ne, StrictGreaterThan, StrictLessThan, LessThan, GreaterThan\nfrom sympy.printing import ccode\n\nfile = Symbol('file')\nnull = Symbol('null')\npath_conjunction = (Eq(file, null))\nprint(ccode(simplify(path_conjunction)))",
          "soundSymbolic": true,
          "soundBackwards": true,
          "maybe": false,
          "line": 2774,
          "throwingLine": 2776,
          "isStatic": true,
          "targetOnlyArguments": true
        },
        {
          "qualifiedSignature": "org.apache.commons.io.FileUtils.isFileOlder(java.io.File, java.io.File)",
          "exception": "throw new IllegalArgumentException(\"The reference file '\" + reference + \"' doesn't exist\");",
          "pathCojunction": "(!(reference == null)) && (!(reference.exists()))",
          "symbolicPathConjunction": "(!(reference == null)) && (!reference.exists())",
          "backwardsPathConjunction": "(!(reference == null)) && (!(reference.exists()))",
          "simplifiedPathConjunction": "!reference.exists() && null != reference",
          "z3Program": "from z3 import *\nfrom z3_all_models import *\n\nreference0_isNull = Bool('reference0_isNull')\n\nconstraints = [\n  And(Not(reference0_isNull), Not(reference0.exists()))\n]\n\nsolver = Solver()\nfor constraint in constraints:\n  solver.add(constraint)\n\nmodels = list(all_smt(solver))\nfor model in models: print(model)",
          "symPyProgram": "from sympy import Symbol\nfrom sympy import simplify\nfrom sympy.core.relational import Eq, Ne, StrictGreaterThan, StrictLessThan, LessThan, GreaterThan\nfrom sympy.printing import ccode\n\nreference = Symbol('reference')\nreference_exists = Symbol('reference_exists')\nnull = Symbol('null')\npath_conjunction = ((~((Eq(reference, null)))) & (~(reference_exists)))\nprint(ccode(simplify(path_conjunction)))",
          "soundSymbolic": false,
          "soundBackwards": true,
          "maybe": true,
          "line": 2799,
          "throwingLine": 2804,
          "isStatic": true,
          "targetOnlyArguments": true
        },
        {
          "qualifiedSignature": "org.apache.commons.io.FileUtils.isFileOlder(java.io.File, java.io.File)",
          "exception": "throw new IllegalArgumentException(\"No specified reference file\");",
          "pathCojunction": "(reference == null)",
          "symbolicPathConjunction": "(reference == null)",
          "backwardsPathConjunction": "(reference == null)",
          "simplifiedPathConjunction": "null == reference",
          "z3Inputs": "[reference0_isNull = True]\n",
          "z3Program": "from z3 import *\nfrom z3_all_models import *\n\nreference0_isNull = Bool('reference0_isNull')\n\nconstraints = [\n  reference0_isNull\n]\n\nsolver = Solver()\nfor constraint in constraints:\n  solver.add(constraint)\n\nmodels = list(all_smt(solver))\nfor model in models: print(model)",
          "symPyProgram": "from sympy import Symbol\nfrom sympy import simplify\nfrom sympy.core.relational import Eq, Ne, StrictGreaterThan, StrictLessThan, LessThan, GreaterThan\nfrom sympy.printing import ccode\n\nreference = Symbol('reference')\nnull = Symbol('null')\npath_conjunction = (Eq(reference, null))\nprint(ccode(simplify(path_conjunction)))",
          "soundSymbolic": true,
          "soundBackwards": true,
          "maybe": false,
          "line": 2799,
          "throwingLine": 2801,
          "isStatic": true,
          "targetOnlyArguments": true
        },
        {
          "qualifiedSignature": "org.apache.commons.io.FileUtils.isFileOlder(java.io.File, java.io.File)",
          "exception": "throw new IllegalArgumentException(\"No specified file\")",
          "pathCojunction": "(!(reference == null)) && (!(!reference.exists())) && (file == null)",
          "symbolicPathConjunction": "(!(reference == null)) && (!(!reference.exists())) && (isFileOlder(file, reference.lastModified()))",
          "backwardsPathConjunction": "(!(reference == null)) && (!(!reference.exists())) && (file == null)",
          "simplifiedPathConjunction": "reference.exists() && file == null && null != reference",
          "z3Program": "from z3 import *\nfrom z3_all_models import *\n\nreference0_isNull = Bool('reference0_isNull')\nfile0_isNull = Bool('file0_isNull')\n\nconstraints = [\n  And(And(Not(reference0_isNull), Not(Not(reference0.exists()))), file0_isNull)\n]\n\nsolver = Solver()\nfor constraint in constraints:\n  solver.add(constraint)\n\nmodels = list(all_smt(solver))\nfor model in models: print(model)",
          "symPyProgram": "from sympy import Symbol\nfrom sympy import simplify\nfrom sympy.core.relational import Eq, Ne, StrictGreaterThan, StrictLessThan, LessThan, GreaterThan\nfrom sympy.printing import ccode\n\nfile = Symbol('file')\nreference = Symbol('reference')\nreference_exists = Symbol('reference_exists')\nnull = Symbol('null')\npath_conjunction = (((~((Eq(reference, null)))) & (~((~(reference_exists))))) & (Eq(file, null)))\nprint(ccode(simplify(path_conjunction)))",
          "soundSymbolic": false,
          "soundBackwards": true,
          "maybe": true,
          "line": 2799,
          "throwingLine": 2807,
          "isStatic": true,
          "targetOnlyArguments": true
        },
        {
          "qualifiedSignature": "org.apache.commons.io.FileUtils.isFileOlder(java.io.File, java.util.Date)",
          "exception": "throw new IllegalArgumentException(\"No specified file\")",
          "pathCojunction": "(!(date == null)) && (file == null)",
          "symbolicPathConjunction": "(!(date == null)) && (isFileOlder(file, date.getTime()))",
          "backwardsPathConjunction": "(!(date == null)) && (file == null)",
          "simplifiedPathConjunction": "file == null && date != null",
          "z3Inputs": "[file0_isNull = True, date0_isNull = False]\n",
          "z3Program": "from z3 import *\nfrom z3_all_models import *\n\ndate0_isNull = Bool('date0_isNull')\nfile0_isNull = Bool('file0_isNull')\n\nconstraints = [\n  And(Not(date0_isNull), file0_isNull)\n]\n\nsolver = Solver()\nfor constraint in constraints:\n  solver.add(constraint)\n\nmodels = list(all_smt(solver))\nfor model in models: print(model)",
          "symPyProgram": "from sympy import Symbol\nfrom sympy import simplify\nfrom sympy.core.relational import Eq, Ne, StrictGreaterThan, StrictLessThan, LessThan, GreaterThan\nfrom sympy.printing import ccode\n\nfile = Symbol('file')\ndate = Symbol('date')\nnull = Symbol('null')\npath_conjunction = ((~((Eq(date, null)))) & (Eq(file, null)))\nprint(ccode(simplify(path_conjunction)))",
          "soundSymbolic": true,
          "soundBackwards": true,
          "maybe": false,
          "line": 2822,
          "throwingLine": 2826,
          "isStatic": true,
          "targetOnlyArguments": true
        },
        {
          "qualifiedSignature": "org.apache.commons.io.FileUtils.isFileOlder(java.io.File, java.util.Date)",
          "exception": "throw new IllegalArgumentException(\"No specified date\");",
          "pathCojunction": "(date == null)",
          "symbolicPathConjunction": "(date == null)",
          "backwardsPathConjunction": "(date == null)",
          "simplifiedPathConjunction": "date == null",
          "z3Inputs": "[date0_isNull = True]\n",
          "z3Program": "from z3 import *\nfrom z3_all_models import *\n\ndate0_isNull = Bool('date0_isNull')\n\nconstraints = [\n  date0_isNull\n]\n\nsolver = Solver()\nfor constraint in constraints:\n  solver.add(constraint)\n\nmodels = list(all_smt(solver))\nfor model in models: print(model)",
          "symPyProgram": "from sympy import Symbol\nfrom sympy import simplify\nfrom sympy.core.relational import Eq, Ne, StrictGreaterThan, StrictLessThan, LessThan, GreaterThan\nfrom sympy.printing import ccode\n\ndate = Symbol('date')\nnull = Symbol('null')\npath_conjunction = (Eq(date, null))\nprint(ccode(simplify(path_conjunction)))",
          "soundSymbolic": true,
          "soundBackwards": true,
          "maybe": false,
          "line": 2822,
          "throwingLine": 2824,
          "isStatic": true,
          "targetOnlyArguments": true
        },
        {
          "qualifiedSignature": "org.apache.commons.io.FileUtils.isFileOlder(java.io.File, long)",
          "exception": "throw new IllegalArgumentException(\"No specified file\");",
          "pathCojunction": "(file == null)",
          "symbolicPathConjunction": "(file == null)",
          "backwardsPathConjunction": "(file == null)",
          "simplifiedPathConjunction": "file == null",
          "z3Inputs": "[timeMillis0 = -9223372036854775808, file0_isNull = True]\n[file0_isNull = True, timeMillis0 = 0]\n[file0_isNull = True, timeMillis0 = -1]\n[file0_isNull = True, timeMillis0 = -2]\n[file0_isNull = True, timeMillis0 = -3]\n[file0_isNull = True, timeMillis0 = -4]\n[file0_isNull = True, timeMillis0 = -5]\n[file0_isNull = True, timeMillis0 = -6]\n[file0_isNull = True, timeMillis0 = -7]\n[file0_isNull = True, timeMillis0 = -8]\n",
          "z3Program": "from z3 import *\nfrom z3_all_models import *\n\ntimeMillis0 = Int('timeMillis0')\nfile0_isNull = Bool('file0_isNull')\n\nconstraints = [\n  timeMillis0 >= -9223372036854775808, timeMillis0 <= 9223372036854775807, # implicit\n  file0_isNull\n]\n\nsolver = Solver()\nfor constraint in constraints:\n  solver.add(constraint)\n\nmodels = list(all_smt(solver))\nfor model in models: print(model)",
          "symPyProgram": "from sympy import Symbol\nfrom sympy import simplify\nfrom sympy.core.relational import Eq, Ne, StrictGreaterThan, StrictLessThan, LessThan, GreaterThan\nfrom sympy.printing import ccode\n\nfile = Symbol('file')\nnull = Symbol('null')\npath_conjunction = (Eq(file, null))\nprint(ccode(simplify(path_conjunction)))",
          "soundSymbolic": true,
          "soundBackwards": true,
          "maybe": false,
          "line": 2841,
          "throwingLine": 2843,
          "isStatic": true,
          "targetOnlyArguments": true
        },
        {
          "qualifiedSignature": "org.apache.commons.io.FileUtils.moveDirectory(java.io.File, java.io.File)",
          "exception": "throw new NullPointerException(\"Destination must not be null\");",
          "pathCojunction": "(!(srcDir == null)) && (destDir == null)",
          "symbolicPathConjunction": "(!(srcDir == null)) && (destDir == null)",
          "backwardsPathConjunction": "(!(srcDir == null)) && (destDir == null)",
          "simplifiedPathConjunction": "destDir == null && null != srcDir",
          "z3Inputs": "[destDir0_isNull = True, srcDir0_isNull = False]\n",
          "z3Program": "from z3 import *\nfrom z3_all_models import *\n\nsrcDir0_isNull = Bool('srcDir0_isNull')\ndestDir0_isNull = Bool('destDir0_isNull')\n\nconstraints = [\n  And(Not(srcDir0_isNull), destDir0_isNull)\n]\n\nsolver = Solver()\nfor constraint in constraints:\n  solver.add(constraint)\n\nmodels = list(all_smt(solver))\nfor model in models: print(model)",
          "symPyProgram": "from sympy import Symbol\nfrom sympy import simplify\nfrom sympy.core.relational import Eq, Ne, StrictGreaterThan, StrictLessThan, LessThan, GreaterThan\nfrom sympy.printing import ccode\n\nsrcDir = Symbol('srcDir')\ndestDir = Symbol('destDir')\nnull = Symbol('null')\npath_conjunction = ((~((Eq(srcDir, null)))) & (Eq(destDir, null)))\nprint(ccode(simplify(path_conjunction)))",
          "soundSymbolic": true,
          "soundBackwards": true,
          "maybe": false,
          "line": 2909,
          "throwingLine": 2914,
          "isStatic": true,
          "targetOnlyArguments": true
        },
        {
          "qualifiedSignature": "org.apache.commons.io.FileUtils.moveDirectory(java.io.File, java.io.File)",
          "exception": "throw new IOException(\"Cannot move directory: \" + srcDir + \" to a subdirectory of itself: \" + destDir);",
          "pathCojunction": "(!(srcDir == null)) && (!(destDir == null)) && (!(!srcDir.exists())) && (!(!srcDir.isDirectory())) && (!(destDir.exists())) && (!(rename)) && (destDir.getCanonicalPath().startsWith(srcDir.getCanonicalPath() + File.separator))",
          "symbolicPathConjunction": "(!(srcDir == null)) && (!(destDir == null)) && (!(!srcDir.exists())) && (!(!srcDir.isDirectory())) && (!(destDir.exists())) && (!(rename)) && (destDir.getCanonicalPath().startsWith(srcDir.getCanonicalPath() + File.separator))",
          "backwardsPathConjunction": "(!(srcDir == null)) && (!(destDir == null)) && (!(!srcDir.exists())) && (!(!srcDir.isDirectory())) && (!(destDir.exists())) && (!(srcDir.renameTo(destDir))) && (destDir.getCanonicalPath().startsWith(srcDir.getCanonicalPath() + File.separator))",
          "simplifiedPathConjunction": "destDir.getCanonicalPath().startsWith(srcDir.getCanonicalPath() + File.separator) && srcDir.exists() && srcDir.isDirectory() && !destDir.exists() && !srcDir.renameTo(destDir) && destDir != null && null != srcDir",
          "z3Program": "from z3 import *\nfrom z3_all_models import *\n\nrename0 = Bool('rename0')\nsrcDir0_isNull = Bool('srcDir0_isNull')\ndestDir0_isNull = Bool('destDir0_isNull')\n\nconstraints = [\n  rename0 == srcDir0.renameTo(destDir0),\n  And(And(And(And(And(And(Not(srcDir0_isNull), Not(destDir0_isNull)), Not(Not(srcDir0.exists()))), Not(Not(srcDir0.isDirectory()))), Not(destDir0.exists())), Not(rename0)), destDir0.getCanonicalPath().startsWith(srcDir0.getCanonicalPath() + File.separator))\n]\n\nsolver = Solver()\nfor constraint in constraints:\n  solver.add(constraint)\n\nmodels = list(all_smt(solver))\nfor model in models: print(model)",
          "symPyProgram": "from sympy import Symbol\nfrom sympy import simplify\nfrom sympy.core.relational import Eq, Ne, StrictGreaterThan, StrictLessThan, LessThan, GreaterThan\nfrom sympy.printing import ccode\n\nsrcDir = Symbol('srcDir')\ndestDir = Symbol('destDir')\nsrcDir_exists = Symbol('srcDir_exists')\nsrcDir_isDirectory = Symbol('srcDir_isDirectory')\ndestDir_exists = Symbol('destDir_exists')\nsrcDir_renameTo = Symbol('srcDir_renameTo')\ndestDir_getCanonicalPath_startsWith = Symbol('destDir_getCanonicalPath_startsWith')\ndestDir_getCanonicalPath = Symbol('destDir_getCanonicalPath')\nsrcDir_getCanonicalPath = Symbol('srcDir_getCanonicalPath')\nnull = Symbol('null')\npath_conjunction = (((((((~((Eq(srcDir, null)))) & (~((Eq(destDir, null))))) & (~((~(srcDir_exists))))) & (~((~(srcDir_isDirectory))))) & (~(destDir_exists))) & (~(srcDir_renameTo))) & destDir_getCanonicalPath_startsWith)\nprint(ccode(simplify(path_conjunction)))",
          "soundSymbolic": false,
          "soundBackwards": false,
          "maybe": true,
          "line": 2909,
          "throwingLine": 2928,
          "isStatic": true,
          "targetOnlyArguments": false
        },
        {
          "qualifiedSignature": "org.apache.commons.io.FileUtils.moveDirectory(java.io.File, java.io.File)",
          "exception": "throw new NullPointerException(\"Source must not be null\");",
          "pathCojunction": "(srcDir == null)",
          "symbolicPathConjunction": "(srcDir == null)",
          "backwardsPathConjunction": "(srcDir == null)",
          "simplifiedPathConjunction": "null == srcDir",
          "z3Inputs": "[srcDir0_isNull = True]\n",
          "z3Program": "from z3 import *\nfrom z3_all_models import *\n\nsrcDir0_isNull = Bool('srcDir0_isNull')\n\nconstraints = [\n  srcDir0_isNull\n]\n\nsolver = Solver()\nfor constraint in constraints:\n  solver.add(constraint)\n\nmodels = list(all_smt(solver))\nfor model in models: print(model)",
          "symPyProgram": "from sympy import Symbol\nfrom sympy import simplify\nfrom sympy.core.relational import Eq, Ne, StrictGreaterThan, StrictLessThan, LessThan, GreaterThan\nfrom sympy.printing import ccode\n\nsrcDir = Symbol('srcDir')\nnull = Symbol('null')\npath_conjunction = (Eq(srcDir, null))\nprint(ccode(simplify(path_conjunction)))",
          "soundSymbolic": true,
          "soundBackwards": true,
          "maybe": false,
          "line": 2909,
          "throwingLine": 2911,
          "isStatic": true,
          "targetOnlyArguments": true
        },
        {
          "qualifiedSignature": "org.apache.commons.io.FileUtils.moveDirectory(java.io.File, java.io.File)",
          "exception": "throw new IOException(\"Failed to delete original directory '\" + srcDir + \"' after copy to '\" + destDir + \"'\");",
          "pathCojunction": "(!(srcDir == null)) && (!(destDir == null)) && (!(!srcDir.exists())) && (!(!srcDir.isDirectory())) && (!(destDir.exists())) && (!(rename)) && (!(destDir.getCanonicalPath().startsWith(srcDir.getCanonicalPath() + File.separator))) && (!(!srcDir.exists())) && (!(srcDir == null)) && (!(!Files.isSymbolicLink(srcDir.toPath()))) && (!(!srcDir.delete())) && (srcDir.exists())",
          "symbolicPathConjunction": "(!(srcDir == null)) && (!(destDir == null)) && (!(!srcDir.exists())) && (!(!srcDir.isDirectory())) && (!(destDir.exists())) && (!(rename)) && (!(destDir.getCanonicalPath().startsWith(srcDir.getCanonicalPath() + File.separator))) && (!(copyDirectory(srcDir, destDir))) && (!(deleteDirectory(srcDir))) && (srcDir.exists())",
          "backwardsPathConjunction": "(!(srcDir == null)) && (!(destDir == null)) && (!(!srcDir.exists())) && (!(!srcDir.isDirectory())) && (!(destDir.exists())) && (!(srcDir.renameTo(destDir))) && (!(destDir.getCanonicalPath().startsWith(srcDir.getCanonicalPath() + File.separator))) && (!(!srcDir.exists())) && (!(srcDir == null)) && (!(!Files.isSymbolicLink(srcDir.toPath()))) && (!(!srcDir.delete())) && (srcDir.exists())",
          "simplifiedPathConjunction": "Files.isSymbolicLink(srcDir.toPath()) && srcDir.delete() && srcDir.exists() && srcDir.isDirectory() && !destDir.exists() && !destDir.getCanonicalPath().startsWith(srcDir.getCanonicalPath() + File.separator) && !srcDir.renameTo(destDir) && destDir != null && null != srcDir",
          "z3Program": "from z3 import *\nfrom z3_all_models import *\n\nrename0 = Bool('rename0')\nsrcDir0_isNull = Bool('srcDir0_isNull')\ndestDir0_isNull = Bool('destDir0_isNull')\n\nconstraints = [\n  rename0 == srcDir0.renameTo(destDir0),\n  And(And(And(And(And(And(And(And(And(And(And(Not(srcDir0_isNull), Not(destDir0_isNull)), Not(Not(srcDir0.exists()))), Not(Not(srcDir0.isDirectory()))), Not(destDir0.exists())), Not(rename0)), Not(destDir0.getCanonicalPath().startsWith(srcDir0.getCanonicalPath() + File.separator))), Not(Not(srcDir0.exists()))), Not(srcDir0_isNull)), Not(Not(Files.isSymbolicLink(srcDir0.toPath())))), Not(Not(srcDir0.delete()))), srcDir0.exists())\n]\n\nsolver = Solver()\nfor constraint in constraints:\n  solver.add(constraint)\n\nmodels = list(all_smt(solver))\nfor model in models: print(model)",
          "symPyProgram": "from sympy import Symbol\nfrom sympy import simplify\nfrom sympy.core.relational import Eq, Ne, StrictGreaterThan, StrictLessThan, LessThan, GreaterThan\nfrom sympy.printing import ccode\n\nsrcDir = Symbol('srcDir')\ndestDir = Symbol('destDir')\nsrcDir_exists = Symbol('srcDir_exists')\nsrcDir_isDirectory = Symbol('srcDir_isDirectory')\ndestDir_exists = Symbol('destDir_exists')\nsrcDir_renameTo = Symbol('srcDir_renameTo')\ndestDir_getCanonicalPath_startsWith = Symbol('destDir_getCanonicalPath_startsWith')\ndestDir_getCanonicalPath = Symbol('destDir_getCanonicalPath')\nsrcDir_getCanonicalPath = Symbol('srcDir_getCanonicalPath')\nFiles_isSymbolicLink = Symbol('Files_isSymbolicLink')\nsrcDir_toPath = Symbol('srcDir_toPath')\nsrcDir_delete = Symbol('srcDir_delete')\nnull = Symbol('null')\npath_conjunction = ((((((((((((~((Eq(srcDir, null)))) & (~((Eq(destDir, null))))) & (~((~(srcDir_exists))))) & (~((~(srcDir_isDirectory))))) & (~(destDir_exists))) & (~(srcDir_renameTo))) & (~(destDir_getCanonicalPath_startsWith))) & (~((~(srcDir_exists))))) & (~((Eq(srcDir, null))))) & (~((~(Files_isSymbolicLink))))) & (~((~(srcDir_delete))))) & srcDir_exists)\nprint(ccode(simplify(path_conjunction)))",
          "soundSymbolic": false,
          "soundBackwards": false,
          "maybe": true,
          "line": 2909,
          "throwingLine": 2933,
          "isStatic": true,
          "targetOnlyArguments": false
        },
        {
          "qualifiedSignature": "org.apache.commons.io.FileUtils.moveDirectory(java.io.File, java.io.File)",
          "exception": "throw new FileExistsException(\"Destination '\" + destDir + \"' already exists\");",
          "pathCojunction": "(!(srcDir == null)) && (!(destDir == null)) && (!(!srcDir.exists())) && (!(!srcDir.isDirectory())) && (destDir.exists())",
          "symbolicPathConjunction": "(!(srcDir == null)) && (!(destDir == null)) && (!(!srcDir.exists())) && (!(!srcDir.isDirectory())) && (destDir.exists())",
          "backwardsPathConjunction": "(!(srcDir == null)) && (!(destDir == null)) && (!(!srcDir.exists())) && (!(!srcDir.isDirectory())) && (destDir.exists())",
          "simplifiedPathConjunction": "destDir.exists() && srcDir.exists() && srcDir.isDirectory() && destDir != null && null != srcDir",
          "z3Program": "from z3 import *\nfrom z3_all_models import *\n\nsrcDir0_isNull = Bool('srcDir0_isNull')\ndestDir0_isNull = Bool('destDir0_isNull')\n\nconstraints = [\n  And(And(And(And(Not(srcDir0_isNull), Not(destDir0_isNull)), Not(Not(srcDir0.exists()))), Not(Not(srcDir0.isDirectory()))), destDir0.exists())\n]\n\nsolver = Solver()\nfor constraint in constraints:\n  solver.add(constraint)\n\nmodels = list(all_smt(solver))\nfor model in models: print(model)",
          "symPyProgram": "from sympy import Symbol\nfrom sympy import simplify\nfrom sympy.core.relational import Eq, Ne, StrictGreaterThan, StrictLessThan, LessThan, GreaterThan\nfrom sympy.printing import ccode\n\nsrcDir = Symbol('srcDir')\ndestDir = Symbol('destDir')\nsrcDir_exists = Symbol('srcDir_exists')\nsrcDir_isDirectory = Symbol('srcDir_isDirectory')\ndestDir_exists = Symbol('destDir_exists')\nnull = Symbol('null')\npath_conjunction = (((((~((Eq(srcDir, null)))) & (~((Eq(destDir, null))))) & (~((~(srcDir_exists))))) & (~((~(srcDir_isDirectory))))) & destDir_exists)\nprint(ccode(simplify(path_conjunction)))",
          "soundSymbolic": false,
          "soundBackwards": true,
          "maybe": true,
          "line": 2909,
          "throwingLine": 2923,
          "isStatic": true,
          "targetOnlyArguments": true
        },
        {
          "qualifiedSignature": "org.apache.commons.io.FileUtils.moveDirectory(java.io.File, java.io.File)",
          "exception": "throw new IOException(message)",
          "pathCojunction": "(!(srcDir == null)) && (!(destDir == null)) && (!(!srcDir.exists())) && (!(!srcDir.isDirectory())) && (!(destDir.exists())) && (!(rename)) && (!(destDir.getCanonicalPath().startsWith(srcDir.getCanonicalPath() + File.separator))) && (!(!srcDir.exists())) && (!(srcDir == null)) && (!(Files.isSymbolicLink(srcDir.toPath()))) && (!(srcDir.delete()))",
          "symbolicPathConjunction": "(!(srcDir == null)) && (!(destDir == null)) && (!(!srcDir.exists())) && (!(!srcDir.isDirectory())) && (!(destDir.exists())) && (!(rename)) && (!(destDir.getCanonicalPath().startsWith(srcDir.getCanonicalPath() + File.separator))) && (!(copyDirectory(srcDir, destDir))) && (!(deleteDirectory(srcDir)))",
          "backwardsPathConjunction": "(!(srcDir == null)) && (!(destDir == null)) && (!(!srcDir.exists())) && (!(!srcDir.isDirectory())) && (!(destDir.exists())) && (!(srcDir.renameTo(destDir))) && (!(destDir.getCanonicalPath().startsWith(srcDir.getCanonicalPath() + File.separator))) && (!(!srcDir.exists())) && (!(srcDir == null)) && (!(Files.isSymbolicLink(srcDir.toPath()))) && (!(srcDir.delete()))",
          "simplifiedPathConjunction": "srcDir.exists() && srcDir.isDirectory() && !Files.isSymbolicLink(srcDir.toPath()) && !destDir.exists() && !destDir.getCanonicalPath().startsWith(srcDir.getCanonicalPath() + File.separator) && !srcDir.delete() && !srcDir.renameTo(destDir) && destDir != null && null != srcDir",
          "z3Program": "from z3 import *\nfrom z3_all_models import *\n\nrename0 = Bool('rename0')\nsrcDir0_isNull = Bool('srcDir0_isNull')\ndestDir0_isNull = Bool('destDir0_isNull')\n\nconstraints = [\n  rename0 == srcDir0.renameTo(destDir0),\n  And(And(And(And(And(And(And(And(And(And(Not(srcDir0_isNull), Not(destDir0_isNull)), Not(Not(srcDir0.exists()))), Not(Not(srcDir0.isDirectory()))), Not(destDir0.exists())), Not(rename0)), Not(destDir0.getCanonicalPath().startsWith(srcDir0.getCanonicalPath() + File.separator))), Not(Not(srcDir0.exists()))), Not(srcDir0_isNull)), Not(Files.isSymbolicLink(srcDir0.toPath()))), Not(srcDir0.delete()))\n]\n\nsolver = Solver()\nfor constraint in constraints:\n  solver.add(constraint)\n\nmodels = list(all_smt(solver))\nfor model in models: print(model)",
          "symPyProgram": "from sympy import Symbol\nfrom sympy import simplify\nfrom sympy.core.relational import Eq, Ne, StrictGreaterThan, StrictLessThan, LessThan, GreaterThan\nfrom sympy.printing import ccode\n\nsrcDir = Symbol('srcDir')\ndestDir = Symbol('destDir')\nsrcDir_exists = Symbol('srcDir_exists')\nsrcDir_isDirectory = Symbol('srcDir_isDirectory')\ndestDir_exists = Symbol('destDir_exists')\nsrcDir_renameTo = Symbol('srcDir_renameTo')\ndestDir_getCanonicalPath_startsWith = Symbol('destDir_getCanonicalPath_startsWith')\ndestDir_getCanonicalPath = Symbol('destDir_getCanonicalPath')\nsrcDir_getCanonicalPath = Symbol('srcDir_getCanonicalPath')\nFiles_isSymbolicLink = Symbol('Files_isSymbolicLink')\nsrcDir_toPath = Symbol('srcDir_toPath')\nsrcDir_delete = Symbol('srcDir_delete')\nnull = Symbol('null')\npath_conjunction = (((((((((((~((Eq(srcDir, null)))) & (~((Eq(destDir, null))))) & (~((~(srcDir_exists))))) & (~((~(srcDir_isDirectory))))) & (~(destDir_exists))) & (~(srcDir_renameTo))) & (~(destDir_getCanonicalPath_startsWith))) & (~((~(srcDir_exists))))) & (~((Eq(srcDir, null))))) & (~(Files_isSymbolicLink))) & (~(srcDir_delete)))\nprint(ccode(simplify(path_conjunction)))",
          "soundSymbolic": false,
          "soundBackwards": false,
          "maybe": true,
          "line": 2909,
          "throwingLine": 2931,
          "isStatic": true,
          "targetOnlyArguments": false
        },
        {
          "qualifiedSignature": "org.apache.commons.io.FileUtils.moveDirectory(java.io.File, java.io.File)",
          "exception": "throw new IOException(\"Source '\" + srcDir + \"' is not a directory\");",
          "pathCojunction": "(!(srcDir == null)) && (!(destDir == null)) && (!(!srcDir.exists())) && (!(srcDir.isDirectory()))",
          "symbolicPathConjunction": "(!(srcDir == null)) && (!(destDir == null)) && (!(!srcDir.exists())) && (!srcDir.isDirectory())",
          "backwardsPathConjunction": "(!(srcDir == null)) && (!(destDir == null)) && (!(!srcDir.exists())) && (!(srcDir.isDirectory()))",
          "simplifiedPathConjunction": "srcDir.exists() && !srcDir.isDirectory() && destDir != null && null != srcDir",
          "z3Program": "from z3 import *\nfrom z3_all_models import *\n\nsrcDir0_isNull = Bool('srcDir0_isNull')\ndestDir0_isNull = Bool('destDir0_isNull')\n\nconstraints = [\n  And(And(And(Not(srcDir0_isNull), Not(destDir0_isNull)), Not(Not(srcDir0.exists()))), Not(srcDir0.isDirectory()))\n]\n\nsolver = Solver()\nfor constraint in constraints:\n  solver.add(constraint)\n\nmodels = list(all_smt(solver))\nfor model in models: print(model)",
          "symPyProgram": "from sympy import Symbol\nfrom sympy import simplify\nfrom sympy.core.relational import Eq, Ne, StrictGreaterThan, StrictLessThan, LessThan, GreaterThan\nfrom sympy.printing import ccode\n\nsrcDir = Symbol('srcDir')\ndestDir = Symbol('destDir')\nsrcDir_exists = Symbol('srcDir_exists')\nsrcDir_isDirectory = Symbol('srcDir_isDirectory')\nnull = Symbol('null')\npath_conjunction = ((((~((Eq(srcDir, null)))) & (~((Eq(destDir, null))))) & (~((~(srcDir_exists))))) & (~(srcDir_isDirectory)))\nprint(ccode(simplify(path_conjunction)))",
          "soundSymbolic": false,
          "soundBackwards": true,
          "maybe": true,
          "line": 2909,
          "throwingLine": 2920,
          "isStatic": true,
          "targetOnlyArguments": true
        },
        {
          "qualifiedSignature": "org.apache.commons.io.FileUtils.moveDirectory(java.io.File, java.io.File)",
          "exception": "throw new IOException(message)",
          "pathCojunction": "(!(srcDir == null)) && (!(destDir == null)) && (!(!srcDir.exists())) && (!(!srcDir.isDirectory())) && (!(destDir.exists())) && (!(rename)) && (!(destDir.getCanonicalPath().startsWith(srcDir.getCanonicalPath() + File.separator))) && (!(!srcDir.exists())) && (!(srcDir == null)) && (!(!Files.isSymbolicLink(srcDir.toPath()))) && (!(srcDir.delete()))",
          "symbolicPathConjunction": "(!(srcDir == null)) && (!(destDir == null)) && (!(!srcDir.exists())) && (!(!srcDir.isDirectory())) && (!(destDir.exists())) && (!(rename)) && (!(destDir.getCanonicalPath().startsWith(srcDir.getCanonicalPath() + File.separator))) && (!(copyDirectory(srcDir, destDir))) && (!(deleteDirectory(srcDir)))",
          "backwardsPathConjunction": "(!(srcDir == null)) && (!(destDir == null)) && (!(!srcDir.exists())) && (!(!srcDir.isDirectory())) && (!(destDir.exists())) && (!(srcDir.renameTo(destDir))) && (!(destDir.getCanonicalPath().startsWith(srcDir.getCanonicalPath() + File.separator))) && (!(!srcDir.exists())) && (!(srcDir == null)) && (!(!Files.isSymbolicLink(srcDir.toPath()))) && (!(srcDir.delete()))",
          "simplifiedPathConjunction": "Files.isSymbolicLink(srcDir.toPath()) && srcDir.exists() && srcDir.isDirectory() && !destDir.exists() && !destDir.getCanonicalPath().startsWith(srcDir.getCanonicalPath() + File.separator) && !srcDir.delete() && !srcDir.renameTo(destDir) && destDir != null && null != srcDir",
          "z3Program": "from z3 import *\nfrom z3_all_models import *\n\nrename0 = Bool('rename0')\nsrcDir0_isNull = Bool('srcDir0_isNull')\ndestDir0_isNull = Bool('destDir0_isNull')\n\nconstraints = [\n  rename0 == srcDir0.renameTo(destDir0),\n  And(And(And(And(And(And(And(And(And(And(Not(srcDir0_isNull), Not(destDir0_isNull)), Not(Not(srcDir0.exists()))), Not(Not(srcDir0.isDirectory()))), Not(destDir0.exists())), Not(rename0)), Not(destDir0.getCanonicalPath().startsWith(srcDir0.getCanonicalPath() + File.separator))), Not(Not(srcDir0.exists()))), Not(srcDir0_isNull)), Not(Not(Files.isSymbolicLink(srcDir0.toPath())))), Not(srcDir0.delete()))\n]\n\nsolver = Solver()\nfor constraint in constraints:\n  solver.add(constraint)\n\nmodels = list(all_smt(solver))\nfor model in models: print(model)",
          "symPyProgram": "from sympy import Symbol\nfrom sympy import simplify\nfrom sympy.core.relational import Eq, Ne, StrictGreaterThan, StrictLessThan, LessThan, GreaterThan\nfrom sympy.printing import ccode\n\nsrcDir = Symbol('srcDir')\ndestDir = Symbol('destDir')\nsrcDir_exists = Symbol('srcDir_exists')\nsrcDir_isDirectory = Symbol('srcDir_isDirectory')\ndestDir_exists = Symbol('destDir_exists')\nsrcDir_renameTo = Symbol('srcDir_renameTo')\ndestDir_getCanonicalPath_startsWith = Symbol('destDir_getCanonicalPath_startsWith')\ndestDir_getCanonicalPath = Symbol('destDir_getCanonicalPath')\nsrcDir_getCanonicalPath = Symbol('srcDir_getCanonicalPath')\nFiles_isSymbolicLink = Symbol('Files_isSymbolicLink')\nsrcDir_toPath = Symbol('srcDir_toPath')\nsrcDir_delete = Symbol('srcDir_delete')\nnull = Symbol('null')\npath_conjunction = (((((((((((~((Eq(srcDir, null)))) & (~((Eq(destDir, null))))) & (~((~(srcDir_exists))))) & (~((~(srcDir_isDirectory))))) & (~(destDir_exists))) & (~(srcDir_renameTo))) & (~(destDir_getCanonicalPath_startsWith))) & (~((~(srcDir_exists))))) & (~((Eq(srcDir, null))))) & (~((~(Files_isSymbolicLink))))) & (~(srcDir_delete)))\nprint(ccode(simplify(path_conjunction)))",
          "soundSymbolic": false,
          "soundBackwards": false,
          "maybe": true,
          "line": 2909,
          "throwingLine": 2931,
          "isStatic": true,
          "targetOnlyArguments": false
        },
        {
          "qualifiedSignature": "org.apache.commons.io.FileUtils.moveDirectory(java.io.File, java.io.File)",
          "exception": "throw new FileNotFoundException(\"Source '\" + srcDir + \"' does not exist\");",
          "pathCojunction": "(!(srcDir == null)) && (!(destDir == null)) && (!(srcDir.exists()))",
          "symbolicPathConjunction": "(!(srcDir == null)) && (!(destDir == null)) && (!srcDir.exists())",
          "backwardsPathConjunction": "(!(srcDir == null)) && (!(destDir == null)) && (!(srcDir.exists()))",
          "simplifiedPathConjunction": "!srcDir.exists() && destDir != null && null != srcDir",
          "z3Program": "from z3 import *\nfrom z3_all_models import *\n\nsrcDir0_isNull = Bool('srcDir0_isNull')\ndestDir0_isNull = Bool('destDir0_isNull')\n\nconstraints = [\n  And(And(Not(srcDir0_isNull), Not(destDir0_isNull)), Not(srcDir0.exists()))\n]\n\nsolver = Solver()\nfor constraint in constraints:\n  solver.add(constraint)\n\nmodels = list(all_smt(solver))\nfor model in models: print(model)",
          "symPyProgram": "from sympy import Symbol\nfrom sympy import simplify\nfrom sympy.core.relational import Eq, Ne, StrictGreaterThan, StrictLessThan, LessThan, GreaterThan\nfrom sympy.printing import ccode\n\nsrcDir = Symbol('srcDir')\ndestDir = Symbol('destDir')\nsrcDir_exists = Symbol('srcDir_exists')\nnull = Symbol('null')\npath_conjunction = (((~((Eq(srcDir, null)))) & (~((Eq(destDir, null))))) & (~(srcDir_exists)))\nprint(ccode(simplify(path_conjunction)))",
          "soundSymbolic": false,
          "soundBackwards": true,
          "maybe": true,
          "line": 2909,
          "throwingLine": 2917,
          "isStatic": true,
          "targetOnlyArguments": true
        },
        {
          "qualifiedSignature": "org.apache.commons.io.FileUtils.moveDirectory(java.io.File, java.io.File)",
          "exception": "throw new IOException(\"Cannot move directory: \" + srcDir + \" to a subdirectory of itself: \" + destDir);",
          "pathCojunction": "(!(srcDir == null)) && (!(destDir == null)) && (!(!srcDir.exists())) && (!(!srcDir.isDirectory())) && (!(destDir.exists())) && (!(rename)) && (destDir.getCanonicalPath().startsWith(srcDir.getCanonicalPath() + File.separator))",
          "symbolicPathConjunction": "(!(srcDir == null)) && (!(destDir == null)) && (!(!srcDir.exists())) && (!(!srcDir.isDirectory())) && (!(destDir.exists())) && (!(rename)) && (destDir.getCanonicalPath().startsWith(srcDir.getCanonicalPath() + File.separator))",
          "backwardsPathConjunction": "(!(srcDir == null)) && (!(destDir == null)) && (!(!srcDir.exists())) && (!(!srcDir.isDirectory())) && (!(destDir.exists())) && (!(srcDir.renameTo(destDir))) && (destDir.getCanonicalPath().startsWith(srcDir.getCanonicalPath() + File.separator))",
          "simplifiedPathConjunction": "destDir.getCanonicalPath().startsWith(srcDir.getCanonicalPath() + File.separator) && srcDir.exists() && srcDir.isDirectory() && !destDir.exists() && !srcDir.renameTo(destDir) && destDir != null && null != srcDir",
          "z3Program": "from z3 import *\nfrom z3_all_models import *\n\nrename0 = Bool('rename0')\nFile_separator0 = String('File_separator0')\nsrcDir0_isNull = Bool('srcDir0_isNull')\ndestDir0_isNull = Bool('destDir0_isNull')\n\nconstraints = [\n  rename0 == srcDir0.renameTo(destDir0),\n  And(And(And(And(And(And(Not(srcDir0_isNull), Not(destDir0_isNull)), Not(Not(srcDir0.exists()))), Not(Not(srcDir0.isDirectory()))), Not(destDir0.exists())), Not(rename0)), destDir0.getCanonicalPath().startsWith(srcDir0.getCanonicalPath() + File_separator0))\n]\n\nsolver = Solver()\nfor constraint in constraints:\n  solver.add(constraint)\n\nmodels = list(all_smt(solver))\nfor model in models: print(model)",
          "symPyProgram": "from sympy import Symbol\nfrom sympy import simplify\nfrom sympy.core.relational import Eq, Ne, StrictGreaterThan, StrictLessThan, LessThan, GreaterThan\nfrom sympy.printing import ccode\n\nsrcDir = Symbol('srcDir')\ndestDir = Symbol('destDir')\nsrcDir_exists = Symbol('srcDir_exists')\nsrcDir_isDirectory = Symbol('srcDir_isDirectory')\ndestDir_exists = Symbol('destDir_exists')\nsrcDir_renameTo = Symbol('srcDir_renameTo')\ndestDir_getCanonicalPath_startsWith = Symbol('destDir_getCanonicalPath_startsWith')\ndestDir_getCanonicalPath = Symbol('destDir_getCanonicalPath')\nsrcDir_getCanonicalPath = Symbol('srcDir_getCanonicalPath')\nnull = Symbol('null')\npath_conjunction = (((((((~((Eq(srcDir, null)))) & (~((Eq(destDir, null))))) & (~((~(srcDir_exists))))) & (~((~(srcDir_isDirectory))))) & (~(destDir_exists))) & (~(srcDir_renameTo))) & destDir_getCanonicalPath_startsWith)\nprint(ccode(simplify(path_conjunction)))",
          "soundSymbolic": false,
          "soundBackwards": false,
          "maybe": true,
          "line": 2909,
          "throwingLine": 2928,
          "isStatic": true,
          "targetOnlyArguments": false
        },
        {
          "qualifiedSignature": "org.apache.commons.io.FileUtils.moveDirectory(java.io.File, java.io.File)",
          "exception": "throw new IOException(\"Failed to delete original directory '\" + srcDir + \"' after copy to '\" + destDir + \"'\");",
          "pathCojunction": "(!(srcDir == null)) && (!(destDir == null)) && (!(!srcDir.exists())) && (!(!srcDir.isDirectory())) && (!(destDir.exists())) && (!(rename)) && (!(destDir.getCanonicalPath().startsWith(srcDir.getCanonicalPath() + File.separator))) && (!(!srcDir.exists())) && (!(srcDir == null)) && (!(Files.isSymbolicLink(srcDir.toPath()))) && (!(!srcDir.delete())) && (srcDir.exists())",
          "symbolicPathConjunction": "(!(srcDir == null)) && (!(destDir == null)) && (!(!srcDir.exists())) && (!(!srcDir.isDirectory())) && (!(destDir.exists())) && (!(rename)) && (!(destDir.getCanonicalPath().startsWith(srcDir.getCanonicalPath() + File.separator))) && (!(copyDirectory(srcDir, destDir))) && (!(deleteDirectory(srcDir))) && (srcDir.exists())",
          "backwardsPathConjunction": "(!(srcDir == null)) && (!(destDir == null)) && (!(!srcDir.exists())) && (!(!srcDir.isDirectory())) && (!(destDir.exists())) && (!(srcDir.renameTo(destDir))) && (!(destDir.getCanonicalPath().startsWith(srcDir.getCanonicalPath() + File.separator))) && (!(!srcDir.exists())) && (!(srcDir == null)) && (!(Files.isSymbolicLink(srcDir.toPath()))) && (!(!srcDir.delete())) && (srcDir.exists())",
          "simplifiedPathConjunction": "srcDir.delete() && srcDir.exists() && srcDir.isDirectory() && !Files.isSymbolicLink(srcDir.toPath()) && !destDir.exists() && !destDir.getCanonicalPath().startsWith(srcDir.getCanonicalPath() + File.separator) && !srcDir.renameTo(destDir) && destDir != null && null != srcDir",
          "z3Program": "from z3 import *\nfrom z3_all_models import *\n\nrename0 = Bool('rename0')\nsrcDir0_isNull = Bool('srcDir0_isNull')\ndestDir0_isNull = Bool('destDir0_isNull')\n\nconstraints = [\n  rename0 == srcDir0.renameTo(destDir0),\n  And(And(And(And(And(And(And(And(And(And(And(Not(srcDir0_isNull), Not(destDir0_isNull)), Not(Not(srcDir0.exists()))), Not(Not(srcDir0.isDirectory()))), Not(destDir0.exists())), Not(rename0)), Not(destDir0.getCanonicalPath().startsWith(srcDir0.getCanonicalPath() + File.separator))), Not(Not(srcDir0.exists()))), Not(srcDir0_isNull)), Not(Files.isSymbolicLink(srcDir0.toPath()))), Not(Not(srcDir0.delete()))), srcDir0.exists())\n]\n\nsolver = Solver()\nfor constraint in constraints:\n  solver.add(constraint)\n\nmodels = list(all_smt(solver))\nfor model in models: print(model)",
          "symPyProgram": "from sympy import Symbol\nfrom sympy import simplify\nfrom sympy.core.relational import Eq, Ne, StrictGreaterThan, StrictLessThan, LessThan, GreaterThan\nfrom sympy.printing import ccode\n\nsrcDir = Symbol('srcDir')\ndestDir = Symbol('destDir')\nsrcDir_exists = Symbol('srcDir_exists')\nsrcDir_isDirectory = Symbol('srcDir_isDirectory')\ndestDir_exists = Symbol('destDir_exists')\nsrcDir_renameTo = Symbol('srcDir_renameTo')\ndestDir_getCanonicalPath_startsWith = Symbol('destDir_getCanonicalPath_startsWith')\ndestDir_getCanonicalPath = Symbol('destDir_getCanonicalPath')\nsrcDir_getCanonicalPath = Symbol('srcDir_getCanonicalPath')\nFiles_isSymbolicLink = Symbol('Files_isSymbolicLink')\nsrcDir_toPath = Symbol('srcDir_toPath')\nsrcDir_delete = Symbol('srcDir_delete')\nnull = Symbol('null')\npath_conjunction = ((((((((((((~((Eq(srcDir, null)))) & (~((Eq(destDir, null))))) & (~((~(srcDir_exists))))) & (~((~(srcDir_isDirectory))))) & (~(destDir_exists))) & (~(srcDir_renameTo))) & (~(destDir_getCanonicalPath_startsWith))) & (~((~(srcDir_exists))))) & (~((Eq(srcDir, null))))) & (~(Files_isSymbolicLink))) & (~((~(srcDir_delete))))) & srcDir_exists)\nprint(ccode(simplify(path_conjunction)))",
          "soundSymbolic": false,
          "soundBackwards": false,
          "maybe": true,
          "line": 2909,
          "throwingLine": 2933,
          "isStatic": true,
          "targetOnlyArguments": false
        },
        {
          "qualifiedSignature": "org.apache.commons.io.FileUtils.moveDirectoryToDirectory(java.io.File, java.io.File, boolean)",
          "exception": "throw new IOException(\"Destination '\" + destDir + \"' is not a directory\");",
          "pathCojunction": "(!(src == null)) && (!(destDir == null)) && (!(!destDir.exists() && createDestDir)) && (!(!destDir.exists())) && (!(destDir.isDirectory()))",
          "symbolicPathConjunction": "(!(src == null)) && (!(destDir == null)) && (!(!destDir.exists() && createDestDir)) && (!(!destDir.exists())) && (!destDir.isDirectory())",
          "backwardsPathConjunction": "(!(src == null)) && (!(destDir == null)) && (!(!destDir.exists() && createDestDir)) && (!(!destDir.exists())) && (!(destDir.isDirectory()))",
          "simplifiedPathConjunction": "destDir.exists() && !destDir.isDirectory() && destDir != null && null != src",
          "z3Program": "from z3 import *\nfrom z3_all_models import *\n\ncreateDestDir0 = Bool('createDestDir0')\nsrc0_isNull = Bool('src0_isNull')\ndestDir0_isNull = Bool('destDir0_isNull')\n\nconstraints = [\n  And(And(And(And(Not(src0_isNull), Not(destDir0_isNull)), Not(And(Not(destDir0.exists()), createDestDir0))), Not(Not(destDir0.exists()))), Not(destDir0.isDirectory()))\n]\n\nsolver = Solver()\nfor constraint in constraints:\n  solver.add(constraint)\n\nmodels = list(all_smt(solver))\nfor model in models: print(model)",
          "symPyProgram": "from sympy import Symbol\nfrom sympy import simplify\nfrom sympy.core.relational import Eq, Ne, StrictGreaterThan, StrictLessThan, LessThan, GreaterThan\nfrom sympy.printing import ccode\n\nsrc = Symbol('src')\ndestDir = Symbol('destDir')\ncreateDestDir = Symbol('createDestDir')\ndestDir_exists = Symbol('destDir_exists')\ndestDir_isDirectory = Symbol('destDir_isDirectory')\nnull = Symbol('null')\npath_conjunction = (((((~((Eq(src, null)))) & (~((Eq(destDir, null))))) & (~(((~(destDir_exists)) & createDestDir)))) & (~((~(destDir_exists))))) & (~(destDir_isDirectory)))\nprint(ccode(simplify(path_conjunction)))",
          "soundSymbolic": false,
          "soundBackwards": true,
          "maybe": true,
          "line": 2953,
          "throwingLine": 2968,
          "isStatic": true,
          "targetOnlyArguments": true
        },
        {
          "qualifiedSignature": "org.apache.commons.io.FileUtils.moveDirectoryToDirectory(java.io.File, java.io.File, boolean)",
          "exception": "throw new NullPointerException(\"Destination directory must not be null\");",
          "pathCojunction": "(!(src == null)) && (destDir == null)",
          "symbolicPathConjunction": "(!(src == null)) && (destDir == null)",
          "backwardsPathConjunction": "(!(src == null)) && (destDir == null)",
          "simplifiedPathConjunction": "destDir == null && null != src",
          "z3Inputs": "[destDir0_isNull = True, src0_isNull = False]\n",
          "z3Program": "from z3 import *\nfrom z3_all_models import *\n\ncreateDestDir0 = Bool('createDestDir0')\nsrc0_isNull = Bool('src0_isNull')\ndestDir0_isNull = Bool('destDir0_isNull')\n\nconstraints = [\n  And(Not(src0_isNull), destDir0_isNull)\n]\n\nsolver = Solver()\nfor constraint in constraints:\n  solver.add(constraint)\n\nmodels = list(all_smt(solver))\nfor model in models: print(model)",
          "symPyProgram": "from sympy import Symbol\nfrom sympy import simplify\nfrom sympy.core.relational import Eq, Ne, StrictGreaterThan, StrictLessThan, LessThan, GreaterThan\nfrom sympy.printing import ccode\n\nsrc = Symbol('src')\ndestDir = Symbol('destDir')\nnull = Symbol('null')\npath_conjunction = ((~((Eq(src, null)))) & (Eq(destDir, null)))\nprint(ccode(simplify(path_conjunction)))",
          "soundSymbolic": true,
          "soundBackwards": true,
          "maybe": false,
          "line": 2953,
          "throwingLine": 2958,
          "isStatic": true,
          "targetOnlyArguments": true
        },
        {
          "qualifiedSignature": "org.apache.commons.io.FileUtils.moveDirectoryToDirectory(java.io.File, java.io.File, boolean)",
          "exception": "throw new FileNotFoundException(\"Destination directory '\" + destDir + \"' does not exist [createDestDir=\" + createDestDir + \"]\");",
          "pathCojunction": "(!(src == null)) && (!(destDir == null)) && (!destDir.exists() && createDestDir) && (!(destDir.exists()))",
          "symbolicPathConjunction": "(!(src == null)) && (!(destDir == null)) && (!destDir.exists() && createDestDir) && (!destDir.exists())",
          "backwardsPathConjunction": "(!(src == null)) && (!(destDir == null)) && (!destDir.exists() && createDestDir) && (!(destDir.exists()))",
          "simplifiedPathConjunction": "createDestDir && !destDir.exists() && destDir != null && null != src",
          "z3Program": "from z3 import *\nfrom z3_all_models import *\n\ncreateDestDir0 = Bool('createDestDir0')\nsrc0_isNull = Bool('src0_isNull')\ndestDir0_isNull = Bool('destDir0_isNull')\n\nconstraints = [\n  And(And(And(Not(src0_isNull), Not(destDir0_isNull)), And(Not(destDir0.exists()), createDestDir0)), Not(destDir0.exists()))\n]\n\nsolver = Solver()\nfor constraint in constraints:\n  solver.add(constraint)\n\nmodels = list(all_smt(solver))\nfor model in models: print(model)",
          "symPyProgram": "from sympy import Symbol\nfrom sympy import simplify\nfrom sympy.core.relational import Eq, Ne, StrictGreaterThan, StrictLessThan, LessThan, GreaterThan\nfrom sympy.printing import ccode\n\nsrc = Symbol('src')\ndestDir = Symbol('destDir')\ncreateDestDir = Symbol('createDestDir')\ndestDir_exists = Symbol('destDir_exists')\nnull = Symbol('null')\npath_conjunction = ((((~((Eq(src, null)))) & (~((Eq(destDir, null))))) & ((~(destDir_exists)) & createDestDir)) & (~(destDir_exists)))\nprint(ccode(simplify(path_conjunction)))",
          "soundSymbolic": false,
          "soundBackwards": true,
          "maybe": true,
          "line": 2953,
          "throwingLine": 2964,
          "isStatic": true,
          "targetOnlyArguments": true
        },
        {
          "qualifiedSignature": "org.apache.commons.io.FileUtils.moveDirectoryToDirectory(java.io.File, java.io.File, boolean)",
          "exception": "throw new FileNotFoundException(\"Destination directory '\" + destDir + \"' does not exist [createDestDir=\" + createDestDir + \"]\");",
          "pathCojunction": "(!(src == null)) && (!(destDir == null)) && (!(!destDir.exists() && createDestDir)) && (!(destDir.exists()))",
          "symbolicPathConjunction": "(!(src == null)) && (!(destDir == null)) && (!(!destDir.exists() && createDestDir)) && (!destDir.exists())",
          "backwardsPathConjunction": "(!(src == null)) && (!(destDir == null)) && (!(!destDir.exists() && createDestDir)) && (!(destDir.exists()))",
          "simplifiedPathConjunction": "!createDestDir && !destDir.exists() && destDir != null && null != src",
          "z3Program": "from z3 import *\nfrom z3_all_models import *\n\ncreateDestDir0 = Bool('createDestDir0')\nsrc0_isNull = Bool('src0_isNull')\ndestDir0_isNull = Bool('destDir0_isNull')\n\nconstraints = [\n  And(And(And(Not(src0_isNull), Not(destDir0_isNull)), Not(And(Not(destDir0.exists()), createDestDir0))), Not(destDir0.exists()))\n]\n\nsolver = Solver()\nfor constraint in constraints:\n  solver.add(constraint)\n\nmodels = list(all_smt(solver))\nfor model in models: print(model)",
          "symPyProgram": "from sympy import Symbol\nfrom sympy import simplify\nfrom sympy.core.relational import Eq, Ne, StrictGreaterThan, StrictLessThan, LessThan, GreaterThan\nfrom sympy.printing import ccode\n\nsrc = Symbol('src')\ndestDir = Symbol('destDir')\ncreateDestDir = Symbol('createDestDir')\ndestDir_exists = Symbol('destDir_exists')\nnull = Symbol('null')\npath_conjunction = ((((~((Eq(src, null)))) & (~((Eq(destDir, null))))) & (~(((~(destDir_exists)) & createDestDir)))) & (~(destDir_exists)))\nprint(ccode(simplify(path_conjunction)))",
          "soundSymbolic": false,
          "soundBackwards": true,
          "maybe": true,
          "line": 2953,
          "throwingLine": 2964,
          "isStatic": true,
          "targetOnlyArguments": true
        },
        {
          "qualifiedSignature": "org.apache.commons.io.FileUtils.moveDirectoryToDirectory(java.io.File, java.io.File, boolean)",
          "exception": "throw new NullPointerException(\"Source must not be null\");",
          "pathCojunction": "(src == null)",
          "symbolicPathConjunction": "(src == null)",
          "backwardsPathConjunction": "(src == null)",
          "simplifiedPathConjunction": "null == src",
          "z3Inputs": "[src0_isNull = True]\n",
          "z3Program": "from z3 import *\nfrom z3_all_models import *\n\ncreateDestDir0 = Bool('createDestDir0')\nsrc0_isNull = Bool('src0_isNull')\n\nconstraints = [\n  src0_isNull\n]\n\nsolver = Solver()\nfor constraint in constraints:\n  solver.add(constraint)\n\nmodels = list(all_smt(solver))\nfor model in models: print(model)",
          "symPyProgram": "from sympy import Symbol\nfrom sympy import simplify\nfrom sympy.core.relational import Eq, Ne, StrictGreaterThan, StrictLessThan, LessThan, GreaterThan\nfrom sympy.printing import ccode\n\nsrc = Symbol('src')\nnull = Symbol('null')\npath_conjunction = (Eq(src, null))\nprint(ccode(simplify(path_conjunction)))",
          "soundSymbolic": true,
          "soundBackwards": true,
          "maybe": false,
          "line": 2953,
          "throwingLine": 2955,
          "isStatic": true,
          "targetOnlyArguments": true
        },
        {
          "qualifiedSignature": "org.apache.commons.io.FileUtils.moveFile(java.io.File, java.io.File)",
          "exception": "throw new IOException(\"Destination '\" + destFile + \"' is a directory\");",
          "pathCojunction": "(!(srcFile == null)) && (!(destFile == null)) && (!(!srcFile.exists())) && (!(srcFile.isDirectory())) && (!(destFile.exists())) && (destFile.isDirectory())",
          "symbolicPathConjunction": "(!(srcFile == null)) && (!(destFile == null)) && (!(!srcFile.exists())) && (!(srcFile.isDirectory())) && (!(destFile.exists())) && (destFile.isDirectory())",
          "backwardsPathConjunction": "(!(srcFile == null)) && (!(destFile == null)) && (!(!srcFile.exists())) && (!(srcFile.isDirectory())) && (!(destFile.exists())) && (destFile.isDirectory())",
          "simplifiedPathConjunction": "destFile.isDirectory() && srcFile.exists() && !destFile.exists() && !srcFile.isDirectory() && destFile != null && null != srcFile",
          "z3Program": "from z3 import *\nfrom z3_all_models import *\n\nsrcFile0_isNull = Bool('srcFile0_isNull')\ndestFile0_isNull = Bool('destFile0_isNull')\n\nconstraints = [\n  And(And(And(And(And(Not(srcFile0_isNull), Not(destFile0_isNull)), Not(Not(srcFile0.exists()))), Not(srcFile0.isDirectory())), Not(destFile0.exists())), destFile0.isDirectory())\n]\n\nsolver = Solver()\nfor constraint in constraints:\n  solver.add(constraint)\n\nmodels = list(all_smt(solver))\nfor model in models: print(model)",
          "symPyProgram": "from sympy import Symbol\nfrom sympy import simplify\nfrom sympy.core.relational import Eq, Ne, StrictGreaterThan, StrictLessThan, LessThan, GreaterThan\nfrom sympy.printing import ccode\n\nsrcFile = Symbol('srcFile')\ndestFile = Symbol('destFile')\nsrcFile_exists = Symbol('srcFile_exists')\nsrcFile_isDirectory = Symbol('srcFile_isDirectory')\ndestFile_exists = Symbol('destFile_exists')\ndestFile_isDirectory = Symbol('destFile_isDirectory')\nnull = Symbol('null')\npath_conjunction = ((((((~((Eq(srcFile, null)))) & (~((Eq(destFile, null))))) & (~((~(srcFile_exists))))) & (~(srcFile_isDirectory))) & (~(destFile_exists))) & destFile_isDirectory)\nprint(ccode(simplify(path_conjunction)))",
          "soundSymbolic": false,
          "soundBackwards": true,
          "maybe": true,
          "line": 2987,
          "throwingLine": 3004,
          "isStatic": true,
          "targetOnlyArguments": true
        },
        {
          "qualifiedSignature": "org.apache.commons.io.FileUtils.moveFile(java.io.File, java.io.File)",
          "exception": "throw new FileNotFoundException(\"Source '\" + srcFile + \"' does not exist\");",
          "pathCojunction": "(!(srcFile == null)) && (!(destFile == null)) && (!(srcFile.exists()))",
          "symbolicPathConjunction": "(!(srcFile == null)) && (!(destFile == null)) && (!srcFile.exists())",
          "backwardsPathConjunction": "(!(srcFile == null)) && (!(destFile == null)) && (!(srcFile.exists()))",
          "simplifiedPathConjunction": "!srcFile.exists() && destFile != null && null != srcFile",
          "z3Program": "from z3 import *\nfrom z3_all_models import *\n\nsrcFile0_isNull = Bool('srcFile0_isNull')\ndestFile0_isNull = Bool('destFile0_isNull')\n\nconstraints = [\n  And(And(Not(srcFile0_isNull), Not(destFile0_isNull)), Not(srcFile0.exists()))\n]\n\nsolver = Solver()\nfor constraint in constraints:\n  solver.add(constraint)\n\nmodels = list(all_smt(solver))\nfor model in models: print(model)",
          "symPyProgram": "from sympy import Symbol\nfrom sympy import simplify\nfrom sympy.core.relational import Eq, Ne, StrictGreaterThan, StrictLessThan, LessThan, GreaterThan\nfrom sympy.printing import ccode\n\nsrcFile = Symbol('srcFile')\ndestFile = Symbol('destFile')\nsrcFile_exists = Symbol('srcFile_exists')\nnull = Symbol('null')\npath_conjunction = (((~((Eq(srcFile, null)))) & (~((Eq(destFile, null))))) & (~(srcFile_exists)))\nprint(ccode(simplify(path_conjunction)))",
          "soundSymbolic": false,
          "soundBackwards": true,
          "maybe": true,
          "line": 2987,
          "throwingLine": 2995,
          "isStatic": true,
          "targetOnlyArguments": true
        },
        {
          "qualifiedSignature": "org.apache.commons.io.FileUtils.moveFile(java.io.File, java.io.File)",
          "exception": "throw new NullPointerException(\"Source must not be null\");",
          "pathCojunction": "(srcFile == null)",
          "symbolicPathConjunction": "(srcFile == null)",
          "backwardsPathConjunction": "(srcFile == null)",
          "simplifiedPathConjunction": "null == srcFile",
          "z3Inputs": "[srcFile0_isNull = True]\n",
          "z3Program": "from z3 import *\nfrom z3_all_models import *\n\nsrcFile0_isNull = Bool('srcFile0_isNull')\n\nconstraints = [\n  srcFile0_isNull\n]\n\nsolver = Solver()\nfor constraint in constraints:\n  solver.add(constraint)\n\nmodels = list(all_smt(solver))\nfor model in models: print(model)",
          "symPyProgram": "from sympy import Symbol\nfrom sympy import simplify\nfrom sympy.core.relational import Eq, Ne, StrictGreaterThan, StrictLessThan, LessThan, GreaterThan\nfrom sympy.printing import ccode\n\nsrcFile = Symbol('srcFile')\nnull = Symbol('null')\npath_conjunction = (Eq(srcFile, null))\nprint(ccode(simplify(path_conjunction)))",
          "soundSymbolic": true,
          "soundBackwards": true,
          "maybe": false,
          "line": 2987,
          "throwingLine": 2989,
          "isStatic": true,
          "targetOnlyArguments": true
        },
        {
          "qualifiedSignature": "org.apache.commons.io.FileUtils.moveFile(java.io.File, java.io.File)",
          "exception": "throw new IOException(\"Source '\" + srcFile + \"' and destination '\" + destFile + \"' are the same\")",
          "pathCojunction": "(!(srcFile == null)) && (!(destFile == null)) && (!(!srcFile.exists())) && (!(srcFile.isDirectory())) && (!(destFile.exists())) && (!(destFile.isDirectory())) && (!(rename)) && (!(srcFile == null)) && (!(destFile == null)) && (!(!srcFile.exists())) && (!(srcFile.isDirectory())) && (srcFile.getCanonicalPath().equals(destFile.getCanonicalPath()))",
          "symbolicPathConjunction": "(!(srcFile == null)) && (!(destFile == null)) && (!(!srcFile.exists())) && (!(srcFile.isDirectory())) && (!(destFile.exists())) && (!(destFile.isDirectory())) && (!(rename)) && (!(copyFile(srcFile, destFile)))",
          "backwardsPathConjunction": "(!(srcFile == null)) && (!(destFile == null)) && (!(!srcFile.exists())) && (!(srcFile.isDirectory())) && (!(destFile.exists())) && (!(destFile.isDirectory())) && (!(srcFile.renameTo(destFile))) && (!(srcFile == null)) && (!(destFile == null)) && (!(!srcFile.exists())) && (!(srcFile.isDirectory())) && (srcFile.getCanonicalPath().equals(destFile.getCanonicalPath()))",
          "simplifiedPathConjunction": "srcFile.exists() && srcFile.getCanonicalPath().equals(destFile.getCanonicalPath()) && !destFile.exists() && !destFile.isDirectory() && !srcFile.isDirectory() && !srcFile.renameTo(destFile) && destFile != null && null != srcFile",
          "z3Program": "from z3 import *\nfrom z3_all_models import *\n\nrename0 = Bool('rename0')\nsrcFile0_isNull = Bool('srcFile0_isNull')\ndestFile0_isNull = Bool('destFile0_isNull')\n\nconstraints = [\n  rename0 == srcFile0.renameTo(destFile0),\n  And(And(And(And(And(And(And(And(And(And(And(Not(srcFile0_isNull), Not(destFile0_isNull)), Not(Not(srcFile0.exists()))), Not(srcFile0.isDirectory())), Not(destFile0.exists())), Not(destFile0.isDirectory())), Not(rename0)), Not(srcFile0_isNull)), Not(destFile0_isNull)), Not(Not(srcFile0.exists()))), Not(srcFile0.isDirectory())), srcFile0.getCanonicalPath().equals(destFile0.getCanonicalPath()))\n]\n\nsolver = Solver()\nfor constraint in constraints:\n  solver.add(constraint)\n\nmodels = list(all_smt(solver))\nfor model in models: print(model)",
          "symPyProgram": "from sympy import Symbol\nfrom sympy import simplify\nfrom sympy.core.relational import Eq, Ne, StrictGreaterThan, StrictLessThan, LessThan, GreaterThan\nfrom sympy.printing import ccode\n\nsrcFile = Symbol('srcFile')\ndestFile = Symbol('destFile')\nsrcFile_exists = Symbol('srcFile_exists')\nsrcFile_isDirectory = Symbol('srcFile_isDirectory')\ndestFile_exists = Symbol('destFile_exists')\ndestFile_isDirectory = Symbol('destFile_isDirectory')\nsrcFile_renameTo = Symbol('srcFile_renameTo')\nsrcFile_getCanonicalPath_equals = Symbol('srcFile_getCanonicalPath_equals')\nsrcFile_getCanonicalPath = Symbol('srcFile_getCanonicalPath')\ndestFile_getCanonicalPath = Symbol('destFile_getCanonicalPath')\nnull = Symbol('null')\npath_conjunction = ((((((((((((~((Eq(srcFile, null)))) & (~((Eq(destFile, null))))) & (~((~(srcFile_exists))))) & (~(srcFile_isDirectory))) & (~(destFile_exists))) & (~(destFile_isDirectory))) & (~(srcFile_renameTo))) & (~((Eq(srcFile, null))))) & (~((Eq(destFile, null))))) & (~((~(srcFile_exists))))) & (~(srcFile_isDirectory))) & srcFile_getCanonicalPath_equals)\nprint(ccode(simplify(path_conjunction)))",
          "soundSymbolic": false,
          "soundBackwards": true,
          "maybe": true,
          "line": 2987,
          "throwingLine": 3008,
          "isStatic": true,
          "targetOnlyArguments": false
        },
        {
          "qualifiedSignature": "org.apache.commons.io.FileUtils.moveFile(java.io.File, java.io.File)",
          "exception": "throw new IOException(\"Source '\" + srcFile + \"' is a directory\");",
          "pathCojunction": "(!(srcFile == null)) && (!(destFile == null)) && (!(!srcFile.exists())) && (srcFile.isDirectory())",
          "symbolicPathConjunction": "(!(srcFile == null)) && (!(destFile == null)) && (!(!srcFile.exists())) && (srcFile.isDirectory())",
          "backwardsPathConjunction": "(!(srcFile == null)) && (!(destFile == null)) && (!(!srcFile.exists())) && (srcFile.isDirectory())",
          "simplifiedPathConjunction": "srcFile.exists() && srcFile.isDirectory() && destFile != null && null != srcFile",
          "z3Program": "from z3 import *\nfrom z3_all_models import *\n\nsrcFile0_isNull = Bool('srcFile0_isNull')\ndestFile0_isNull = Bool('destFile0_isNull')\n\nconstraints = [\n  And(And(And(Not(srcFile0_isNull), Not(destFile0_isNull)), Not(Not(srcFile0.exists()))), srcFile0.isDirectory())\n]\n\nsolver = Solver()\nfor constraint in constraints:\n  solver.add(constraint)\n\nmodels = list(all_smt(solver))\nfor model in models: print(model)",
          "symPyProgram": "from sympy import Symbol\nfrom sympy import simplify\nfrom sympy.core.relational import Eq, Ne, StrictGreaterThan, StrictLessThan, LessThan, GreaterThan\nfrom sympy.printing import ccode\n\nsrcFile = Symbol('srcFile')\ndestFile = Symbol('destFile')\nsrcFile_exists = Symbol('srcFile_exists')\nsrcFile_isDirectory = Symbol('srcFile_isDirectory')\nnull = Symbol('null')\npath_conjunction = ((((~((Eq(srcFile, null)))) & (~((Eq(destFile, null))))) & (~((~(srcFile_exists))))) & srcFile_isDirectory)\nprint(ccode(simplify(path_conjunction)))",
          "soundSymbolic": false,
          "soundBackwards": true,
          "maybe": true,
          "line": 2987,
          "throwingLine": 2998,
          "isStatic": true,
          "targetOnlyArguments": true
        },
        {
          "qualifiedSignature": "org.apache.commons.io.FileUtils.moveFile(java.io.File, java.io.File)",
          "exception": "throw new FileExistsException(\"Destination '\" + destFile + \"' already exists\");",
          "pathCojunction": "(!(srcFile == null)) && (!(destFile == null)) && (!(!srcFile.exists())) && (!(srcFile.isDirectory())) && (destFile.exists())",
          "symbolicPathConjunction": "(!(srcFile == null)) && (!(destFile == null)) && (!(!srcFile.exists())) && (!(srcFile.isDirectory())) && (destFile.exists())",
          "backwardsPathConjunction": "(!(srcFile == null)) && (!(destFile == null)) && (!(!srcFile.exists())) && (!(srcFile.isDirectory())) && (destFile.exists())",
          "simplifiedPathConjunction": "destFile.exists() && srcFile.exists() && !srcFile.isDirectory() && destFile != null && null != srcFile",
          "z3Program": "from z3 import *\nfrom z3_all_models import *\n\nsrcFile0_isNull = Bool('srcFile0_isNull')\ndestFile0_isNull = Bool('destFile0_isNull')\n\nconstraints = [\n  And(And(And(And(Not(srcFile0_isNull), Not(destFile0_isNull)), Not(Not(srcFile0.exists()))), Not(srcFile0.isDirectory())), destFile0.exists())\n]\n\nsolver = Solver()\nfor constraint in constraints:\n  solver.add(constraint)\n\nmodels = list(all_smt(solver))\nfor model in models: print(model)",
          "symPyProgram": "from sympy import Symbol\nfrom sympy import simplify\nfrom sympy.core.relational import Eq, Ne, StrictGreaterThan, StrictLessThan, LessThan, GreaterThan\nfrom sympy.printing import ccode\n\nsrcFile = Symbol('srcFile')\ndestFile = Symbol('destFile')\nsrcFile_exists = Symbol('srcFile_exists')\nsrcFile_isDirectory = Symbol('srcFile_isDirectory')\ndestFile_exists = Symbol('destFile_exists')\nnull = Symbol('null')\npath_conjunction = (((((~((Eq(srcFile, null)))) & (~((Eq(destFile, null))))) & (~((~(srcFile_exists))))) & (~(srcFile_isDirectory))) & destFile_exists)\nprint(ccode(simplify(path_conjunction)))",
          "soundSymbolic": false,
          "soundBackwards": true,
          "maybe": true,
          "line": 2987,
          "throwingLine": 3001,
          "isStatic": true,
          "targetOnlyArguments": true
        },
        {
          "qualifiedSignature": "org.apache.commons.io.FileUtils.moveFile(java.io.File, java.io.File)",
          "exception": "throw new NullPointerException(\"Destination must not be null\");",
          "pathCojunction": "(!(srcFile == null)) && (destFile == null)",
          "symbolicPathConjunction": "(!(srcFile == null)) && (destFile == null)",
          "backwardsPathConjunction": "(!(srcFile == null)) && (destFile == null)",
          "simplifiedPathConjunction": "destFile == null && null != srcFile",
          "z3Inputs": "[destFile0_isNull = True, srcFile0_isNull = False]\n",
          "z3Program": "from z3 import *\nfrom z3_all_models import *\n\nsrcFile0_isNull = Bool('srcFile0_isNull')\ndestFile0_isNull = Bool('destFile0_isNull')\n\nconstraints = [\n  And(Not(srcFile0_isNull), destFile0_isNull)\n]\n\nsolver = Solver()\nfor constraint in constraints:\n  solver.add(constraint)\n\nmodels = list(all_smt(solver))\nfor model in models: print(model)",
          "symPyProgram": "from sympy import Symbol\nfrom sympy import simplify\nfrom sympy.core.relational import Eq, Ne, StrictGreaterThan, StrictLessThan, LessThan, GreaterThan\nfrom sympy.printing import ccode\n\nsrcFile = Symbol('srcFile')\ndestFile = Symbol('destFile')\nnull = Symbol('null')\npath_conjunction = ((~((Eq(srcFile, null)))) & (Eq(destFile, null)))\nprint(ccode(simplify(path_conjunction)))",
          "soundSymbolic": true,
          "soundBackwards": true,
          "maybe": false,
          "line": 2987,
          "throwingLine": 2992,
          "isStatic": true,
          "targetOnlyArguments": true
        },
        {
          "qualifiedSignature": "org.apache.commons.io.FileUtils.moveFileToDirectory(java.io.File, java.io.File, boolean)",
          "exception": "throw new FileNotFoundException(\"Destination directory '\" + destDir + \"' does not exist [createDestDir=\" + createDestDir + \"]\");",
          "pathCojunction": "(!(srcFile == null)) && (!(destDir == null)) && (!destDir.exists() && createDestDir) && (!(destDir.exists()))",
          "symbolicPathConjunction": "(!(srcFile == null)) && (!(destDir == null)) && (!destDir.exists() && createDestDir) && (!destDir.exists())",
          "backwardsPathConjunction": "(!(srcFile == null)) && (!(destDir == null)) && (!destDir.exists() && createDestDir) && (!(destDir.exists()))",
          "simplifiedPathConjunction": "createDestDir && !destDir.exists() && destDir != null && null != srcFile",
          "z3Program": "from z3 import *\nfrom z3_all_models import *\n\ncreateDestDir0 = Bool('createDestDir0')\nsrcFile0_isNull = Bool('srcFile0_isNull')\ndestDir0_isNull = Bool('destDir0_isNull')\n\nconstraints = [\n  And(And(And(Not(srcFile0_isNull), Not(destDir0_isNull)), And(Not(destDir0.exists()), createDestDir0)), Not(destDir0.exists()))\n]\n\nsolver = Solver()\nfor constraint in constraints:\n  solver.add(constraint)\n\nmodels = list(all_smt(solver))\nfor model in models: print(model)",
          "symPyProgram": "from sympy import Symbol\nfrom sympy import simplify\nfrom sympy.core.relational import Eq, Ne, StrictGreaterThan, StrictLessThan, LessThan, GreaterThan\nfrom sympy.printing import ccode\n\nsrcFile = Symbol('srcFile')\ndestDir = Symbol('destDir')\ncreateDestDir = Symbol('createDestDir')\ndestDir_exists = Symbol('destDir_exists')\nnull = Symbol('null')\npath_conjunction = ((((~((Eq(srcFile, null)))) & (~((Eq(destDir, null))))) & ((~(destDir_exists)) & createDestDir)) & (~(destDir_exists)))\nprint(ccode(simplify(path_conjunction)))",
          "soundSymbolic": false,
          "soundBackwards": true,
          "maybe": true,
          "line": 3031,
          "throwingLine": 3042,
          "isStatic": true,
          "targetOnlyArguments": true
        },
        {
          "qualifiedSignature": "org.apache.commons.io.FileUtils.moveFileToDirectory(java.io.File, java.io.File, boolean)",
          "exception": "throw new NullPointerException(\"Source must not be null\");",
          "pathCojunction": "(srcFile == null)",
          "symbolicPathConjunction": "(srcFile == null)",
          "backwardsPathConjunction": "(srcFile == null)",
          "simplifiedPathConjunction": "null == srcFile",
          "z3Inputs": "[srcFile0_isNull = True]\n",
          "z3Program": "from z3 import *\nfrom z3_all_models import *\n\ncreateDestDir0 = Bool('createDestDir0')\nsrcFile0_isNull = Bool('srcFile0_isNull')\n\nconstraints = [\n  srcFile0_isNull\n]\n\nsolver = Solver()\nfor constraint in constraints:\n  solver.add(constraint)\n\nmodels = list(all_smt(solver))\nfor model in models: print(model)",
          "symPyProgram": "from sympy import Symbol\nfrom sympy import simplify\nfrom sympy.core.relational import Eq, Ne, StrictGreaterThan, StrictLessThan, LessThan, GreaterThan\nfrom sympy.printing import ccode\n\nsrcFile = Symbol('srcFile')\nnull = Symbol('null')\npath_conjunction = (Eq(srcFile, null))\nprint(ccode(simplify(path_conjunction)))",
          "soundSymbolic": true,
          "soundBackwards": true,
          "maybe": false,
          "line": 3031,
          "throwingLine": 3033,
          "isStatic": true,
          "targetOnlyArguments": true
        },
        {
          "qualifiedSignature": "org.apache.commons.io.FileUtils.moveFileToDirectory(java.io.File, java.io.File, boolean)",
          "exception": "throw new FileNotFoundException(\"Destination directory '\" + destDir + \"' does not exist [createDestDir=\" + createDestDir + \"]\");",
          "pathCojunction": "(!(srcFile == null)) && (!(destDir == null)) && (!(!destDir.exists() && createDestDir)) && (!(destDir.exists()))",
          "symbolicPathConjunction": "(!(srcFile == null)) && (!(destDir == null)) && (!(!destDir.exists() && createDestDir)) && (!destDir.exists())",
          "backwardsPathConjunction": "(!(srcFile == null)) && (!(destDir == null)) && (!(!destDir.exists() && createDestDir)) && (!(destDir.exists()))",
          "simplifiedPathConjunction": "!createDestDir && !destDir.exists() && destDir != null && null != srcFile",
          "z3Program": "from z3 import *\nfrom z3_all_models import *\n\ncreateDestDir0 = Bool('createDestDir0')\nsrcFile0_isNull = Bool('srcFile0_isNull')\ndestDir0_isNull = Bool('destDir0_isNull')\n\nconstraints = [\n  And(And(And(Not(srcFile0_isNull), Not(destDir0_isNull)), Not(And(Not(destDir0.exists()), createDestDir0))), Not(destDir0.exists()))\n]\n\nsolver = Solver()\nfor constraint in constraints:\n  solver.add(constraint)\n\nmodels = list(all_smt(solver))\nfor model in models: print(model)",
          "symPyProgram": "from sympy import Symbol\nfrom sympy import simplify\nfrom sympy.core.relational import Eq, Ne, StrictGreaterThan, StrictLessThan, LessThan, GreaterThan\nfrom sympy.printing import ccode\n\nsrcFile = Symbol('srcFile')\ndestDir = Symbol('destDir')\ncreateDestDir = Symbol('createDestDir')\ndestDir_exists = Symbol('destDir_exists')\nnull = Symbol('null')\npath_conjunction = ((((~((Eq(srcFile, null)))) & (~((Eq(destDir, null))))) & (~(((~(destDir_exists)) & createDestDir)))) & (~(destDir_exists)))\nprint(ccode(simplify(path_conjunction)))",
          "soundSymbolic": false,
          "soundBackwards": true,
          "maybe": true,
          "line": 3031,
          "throwingLine": 3042,
          "isStatic": true,
          "targetOnlyArguments": true
        },
        {
          "qualifiedSignature": "org.apache.commons.io.FileUtils.moveFileToDirectory(java.io.File, java.io.File, boolean)",
          "exception": "throw new IOException(\"Destination '\" + destDir + \"' is not a directory\");",
          "pathCojunction": "(!(srcFile == null)) && (!(destDir == null)) && (!(!destDir.exists() && createDestDir)) && (!(!destDir.exists())) && (!(destDir.isDirectory()))",
          "symbolicPathConjunction": "(!(srcFile == null)) && (!(destDir == null)) && (!(!destDir.exists() && createDestDir)) && (!(!destDir.exists())) && (!destDir.isDirectory())",
          "backwardsPathConjunction": "(!(srcFile == null)) && (!(destDir == null)) && (!(!destDir.exists() && createDestDir)) && (!(!destDir.exists())) && (!(destDir.isDirectory()))",
          "simplifiedPathConjunction": "destDir.exists() && !destDir.isDirectory() && destDir != null && null != srcFile",
          "z3Program": "from z3 import *\nfrom z3_all_models import *\n\ncreateDestDir0 = Bool('createDestDir0')\nsrcFile0_isNull = Bool('srcFile0_isNull')\ndestDir0_isNull = Bool('destDir0_isNull')\n\nconstraints = [\n  And(And(And(And(Not(srcFile0_isNull), Not(destDir0_isNull)), Not(And(Not(destDir0.exists()), createDestDir0))), Not(Not(destDir0.exists()))), Not(destDir0.isDirectory()))\n]\n\nsolver = Solver()\nfor constraint in constraints:\n  solver.add(constraint)\n\nmodels = list(all_smt(solver))\nfor model in models: print(model)",
          "symPyProgram": "from sympy import Symbol\nfrom sympy import simplify\nfrom sympy.core.relational import Eq, Ne, StrictGreaterThan, StrictLessThan, LessThan, GreaterThan\nfrom sympy.printing import ccode\n\nsrcFile = Symbol('srcFile')\ndestDir = Symbol('destDir')\ncreateDestDir = Symbol('createDestDir')\ndestDir_exists = Symbol('destDir_exists')\ndestDir_isDirectory = Symbol('destDir_isDirectory')\nnull = Symbol('null')\npath_conjunction = (((((~((Eq(srcFile, null)))) & (~((Eq(destDir, null))))) & (~(((~(destDir_exists)) & createDestDir)))) & (~((~(destDir_exists))))) & (~(destDir_isDirectory)))\nprint(ccode(simplify(path_conjunction)))",
          "soundSymbolic": false,
          "soundBackwards": true,
          "maybe": true,
          "line": 3031,
          "throwingLine": 3046,
          "isStatic": true,
          "targetOnlyArguments": true
        },
        {
          "qualifiedSignature": "org.apache.commons.io.FileUtils.moveFileToDirectory(java.io.File, java.io.File, boolean)",
          "exception": "throw new NullPointerException(\"Destination directory must not be null\");",
          "pathCojunction": "(!(srcFile == null)) && (destDir == null)",
          "symbolicPathConjunction": "(!(srcFile == null)) && (destDir == null)",
          "backwardsPathConjunction": "(!(srcFile == null)) && (destDir == null)",
          "simplifiedPathConjunction": "destDir == null && null != srcFile",
          "z3Inputs": "[destDir0_isNull = True, srcFile0_isNull = False]\n",
          "z3Program": "from z3 import *\nfrom z3_all_models import *\n\ncreateDestDir0 = Bool('createDestDir0')\nsrcFile0_isNull = Bool('srcFile0_isNull')\ndestDir0_isNull = Bool('destDir0_isNull')\n\nconstraints = [\n  And(Not(srcFile0_isNull), destDir0_isNull)\n]\n\nsolver = Solver()\nfor constraint in constraints:\n  solver.add(constraint)\n\nmodels = list(all_smt(solver))\nfor model in models: print(model)",
          "symPyProgram": "from sympy import Symbol\nfrom sympy import simplify\nfrom sympy.core.relational import Eq, Ne, StrictGreaterThan, StrictLessThan, LessThan, GreaterThan\nfrom sympy.printing import ccode\n\nsrcFile = Symbol('srcFile')\ndestDir = Symbol('destDir')\nnull = Symbol('null')\npath_conjunction = ((~((Eq(srcFile, null)))) & (Eq(destDir, null)))\nprint(ccode(simplify(path_conjunction)))",
          "soundSymbolic": true,
          "soundBackwards": true,
          "maybe": false,
          "line": 3031,
          "throwingLine": 3036,
          "isStatic": true,
          "targetOnlyArguments": true
        },
        {
          "qualifiedSignature": "org.apache.commons.io.FileUtils.moveToDirectory(java.io.File, java.io.File, boolean)",
          "exception": "throw new NullPointerException(\"Destination must not be null\");",
          "pathCojunction": "(!(src == null)) && (destDir == null)",
          "symbolicPathConjunction": "(!(src == null)) && (destDir == null)",
          "backwardsPathConjunction": "(!(src == null)) && (destDir == null)",
          "simplifiedPathConjunction": "destDir == null && null != src",
          "z3Inputs": "[destDir0_isNull = True, src0_isNull = False]\n",
          "z3Program": "from z3 import *\nfrom z3_all_models import *\n\ncreateDestDir0 = Bool('createDestDir0')\nsrc0_isNull = Bool('src0_isNull')\ndestDir0_isNull = Bool('destDir0_isNull')\n\nconstraints = [\n  And(Not(src0_isNull), destDir0_isNull)\n]\n\nsolver = Solver()\nfor constraint in constraints:\n  solver.add(constraint)\n\nmodels = list(all_smt(solver))\nfor model in models: print(model)",
          "symPyProgram": "from sympy import Symbol\nfrom sympy import simplify\nfrom sympy.core.relational import Eq, Ne, StrictGreaterThan, StrictLessThan, LessThan, GreaterThan\nfrom sympy.printing import ccode\n\nsrc = Symbol('src')\ndestDir = Symbol('destDir')\nnull = Symbol('null')\npath_conjunction = ((~((Eq(src, null)))) & (Eq(destDir, null)))\nprint(ccode(simplify(path_conjunction)))",
          "soundSymbolic": true,
          "soundBackwards": true,
          "maybe": false,
          "line": 3067,
          "throwingLine": 3072,
          "isStatic": true,
          "targetOnlyArguments": true
        },
        {
          "qualifiedSignature": "org.apache.commons.io.FileUtils.moveToDirectory(java.io.File, java.io.File, boolean)",
          "exception": "throw new IOException(\"Destination '\" + destDir + \"' is not a directory\");",
          "pathCojunction": "(!(src == null)) && (!(destDir == null)) && (!(!src.exists())) && (src.isDirectory()) && (!(src == null)) && (!(destDir == null)) && (!(!destDir.exists() && createDestDir)) && (!(!destDir.exists())) && (!(destDir.isDirectory()))",
          "symbolicPathConjunction": "(!(src == null)) && (!(destDir == null)) && (!(!src.exists())) && (src.isDirectory()) && (moveDirectoryToDirectory(src, destDir, createDestDir))",
          "backwardsPathConjunction": "(!(src == null)) && (!(destDir == null)) && (!(!src.exists())) && (src.isDirectory()) && (!(src == null)) && (!(destDir == null)) && (!(!destDir.exists() && createDestDir)) && (!(!destDir.exists())) && (!(destDir.isDirectory()))",
          "simplifiedPathConjunction": "destDir.exists() && src.exists() && src.isDirectory() && !destDir.isDirectory() && destDir != null && null != src",
          "z3Program": "from z3 import *\nfrom z3_all_models import *\n\ncreateDestDir0 = Bool('createDestDir0')\nsrc0_isNull = Bool('src0_isNull')\ndestDir0_isNull = Bool('destDir0_isNull')\n\nconstraints = [\n  And(And(And(And(And(And(And(And(Not(src0_isNull), Not(destDir0_isNull)), Not(Not(src0.exists()))), src0.isDirectory()), Not(src0_isNull)), Not(destDir0_isNull)), Not(And(Not(destDir0.exists()), createDestDir0))), Not(Not(destDir0.exists()))), Not(destDir0.isDirectory()))\n]\n\nsolver = Solver()\nfor constraint in constraints:\n  solver.add(constraint)\n\nmodels = list(all_smt(solver))\nfor model in models: print(model)",
          "symPyProgram": "from sympy import Symbol\nfrom sympy import simplify\nfrom sympy.core.relational import Eq, Ne, StrictGreaterThan, StrictLessThan, LessThan, GreaterThan\nfrom sympy.printing import ccode\n\nsrc = Symbol('src')\ndestDir = Symbol('destDir')\ncreateDestDir = Symbol('createDestDir')\nsrc_exists = Symbol('src_exists')\nsrc_isDirectory = Symbol('src_isDirectory')\ndestDir_exists = Symbol('destDir_exists')\ndestDir_isDirectory = Symbol('destDir_isDirectory')\nnull = Symbol('null')\npath_conjunction = (((((((((~((Eq(src, null)))) & (~((Eq(destDir, null))))) & (~((~(src_exists))))) & src_isDirectory) & (~((Eq(src, null))))) & (~((Eq(destDir, null))))) & (~(((~(destDir_exists)) & createDestDir)))) & (~((~(destDir_exists))))) & (~(destDir_isDirectory)))\nprint(ccode(simplify(path_conjunction)))",
          "soundSymbolic": false,
          "soundBackwards": true,
          "maybe": true,
          "line": 3067,
          "throwingLine": 3078,
          "isStatic": true,
          "targetOnlyArguments": true
        },
        {
          "qualifiedSignature": "org.apache.commons.io.FileUtils.moveToDirectory(java.io.File, java.io.File, boolean)",
          "exception": "throw new FileNotFoundException(\"Destination directory '\" + destDir + \"' does not exist [createDestDir=\" + createDestDir + \"]\");",
          "pathCojunction": "(!(src == null)) && (!(destDir == null)) && (!(!src.exists())) && (src.isDirectory()) && (!(src == null)) && (!(destDir == null)) && (!(!destDir.exists() && createDestDir)) && (!(destDir.exists()))",
          "symbolicPathConjunction": "(!(src == null)) && (!(destDir == null)) && (!(!src.exists())) && (src.isDirectory()) && (moveDirectoryToDirectory(src, destDir, createDestDir))",
          "backwardsPathConjunction": "(!(src == null)) && (!(destDir == null)) && (!(!src.exists())) && (src.isDirectory()) && (!(src == null)) && (!(destDir == null)) && (!(!destDir.exists() && createDestDir)) && (!(destDir.exists()))",
          "simplifiedPathConjunction": "src.exists() && src.isDirectory() && !createDestDir && !destDir.exists() && destDir != null && null != src",
          "z3Program": "from z3 import *\nfrom z3_all_models import *\n\ncreateDestDir0 = Bool('createDestDir0')\nsrc0_isNull = Bool('src0_isNull')\ndestDir0_isNull = Bool('destDir0_isNull')\n\nconstraints = [\n  And(And(And(And(And(And(And(Not(src0_isNull), Not(destDir0_isNull)), Not(Not(src0.exists()))), src0.isDirectory()), Not(src0_isNull)), Not(destDir0_isNull)), Not(And(Not(destDir0.exists()), createDestDir0))), Not(destDir0.exists()))\n]\n\nsolver = Solver()\nfor constraint in constraints:\n  solver.add(constraint)\n\nmodels = list(all_smt(solver))\nfor model in models: print(model)",
          "symPyProgram": "from sympy import Symbol\nfrom sympy import simplify\nfrom sympy.core.relational import Eq, Ne, StrictGreaterThan, StrictLessThan, LessThan, GreaterThan\nfrom sympy.printing import ccode\n\nsrc = Symbol('src')\ndestDir = Symbol('destDir')\ncreateDestDir = Symbol('createDestDir')\nsrc_exists = Symbol('src_exists')\nsrc_isDirectory = Symbol('src_isDirectory')\ndestDir_exists = Symbol('destDir_exists')\nnull = Symbol('null')\npath_conjunction = ((((((((~((Eq(src, null)))) & (~((Eq(destDir, null))))) & (~((~(src_exists))))) & src_isDirectory) & (~((Eq(src, null))))) & (~((Eq(destDir, null))))) & (~(((~(destDir_exists)) & createDestDir)))) & (~(destDir_exists)))\nprint(ccode(simplify(path_conjunction)))",
          "soundSymbolic": false,
          "soundBackwards": true,
          "maybe": true,
          "line": 3067,
          "throwingLine": 3078,
          "isStatic": true,
          "targetOnlyArguments": true
        },
        {
          "qualifiedSignature": "org.apache.commons.io.FileUtils.moveToDirectory(java.io.File, java.io.File, boolean)",
          "exception": "throw new FileNotFoundException(\"Source '\" + src + \"' does not exist\");",
          "pathCojunction": "(!(src == null)) && (!(destDir == null)) && (!(src.exists()))",
          "symbolicPathConjunction": "(!(src == null)) && (!(destDir == null)) && (!src.exists())",
          "backwardsPathConjunction": "(!(src == null)) && (!(destDir == null)) && (!(src.exists()))",
          "simplifiedPathConjunction": "!src.exists() && destDir != null && null != src",
          "z3Program": "from z3 import *\nfrom z3_all_models import *\n\ncreateDestDir0 = Bool('createDestDir0')\nsrc0_isNull = Bool('src0_isNull')\ndestDir0_isNull = Bool('destDir0_isNull')\n\nconstraints = [\n  And(And(Not(src0_isNull), Not(destDir0_isNull)), Not(src0.exists()))\n]\n\nsolver = Solver()\nfor constraint in constraints:\n  solver.add(constraint)\n\nmodels = list(all_smt(solver))\nfor model in models: print(model)",
          "symPyProgram": "from sympy import Symbol\nfrom sympy import simplify\nfrom sympy.core.relational import Eq, Ne, StrictGreaterThan, StrictLessThan, LessThan, GreaterThan\nfrom sympy.printing import ccode\n\nsrc = Symbol('src')\ndestDir = Symbol('destDir')\nsrc_exists = Symbol('src_exists')\nnull = Symbol('null')\npath_conjunction = (((~((Eq(src, null)))) & (~((Eq(destDir, null))))) & (~(src_exists)))\nprint(ccode(simplify(path_conjunction)))",
          "soundSymbolic": false,
          "soundBackwards": true,
          "maybe": true,
          "line": 3067,
          "throwingLine": 3075,
          "isStatic": true,
          "targetOnlyArguments": true
        },
        {
          "qualifiedSignature": "org.apache.commons.io.FileUtils.moveToDirectory(java.io.File, java.io.File, boolean)",
          "exception": "throw new IOException(\"Destination '\" + destDir + \"' is not a directory\")",
          "pathCojunction": "(!(src == null)) && (!(destDir == null)) && (!(!src.exists())) && (!(src.isDirectory())) && (!(src == null)) && (!(destDir == null)) && (!(!destDir.exists() && createDestDir)) && (!(!destDir.exists())) && (!(destDir.isDirectory()))",
          "symbolicPathConjunction": "(!(src == null)) && (!(destDir == null)) && (!(!src.exists())) && (!(src.isDirectory())) && (!(moveFileToDirectory(src, destDir, createDestDir)))",
          "backwardsPathConjunction": "(!(src == null)) && (!(destDir == null)) && (!(!src.exists())) && (!(src.isDirectory())) && (!(src == null)) && (!(destDir == null)) && (!(!destDir.exists() && createDestDir)) && (!(!destDir.exists())) && (!(destDir.isDirectory()))",
          "simplifiedPathConjunction": "destDir.exists() && src.exists() && !destDir.isDirectory() && !src.isDirectory() && destDir != null && null != src",
          "z3Program": "from z3 import *\nfrom z3_all_models import *\n\ncreateDestDir0 = Bool('createDestDir0')\nsrc0_isNull = Bool('src0_isNull')\ndestDir0_isNull = Bool('destDir0_isNull')\n\nconstraints = [\n  And(And(And(And(And(And(And(And(Not(src0_isNull), Not(destDir0_isNull)), Not(Not(src0.exists()))), Not(src0.isDirectory())), Not(src0_isNull)), Not(destDir0_isNull)), Not(And(Not(destDir0.exists()), createDestDir0))), Not(Not(destDir0.exists()))), Not(destDir0.isDirectory()))\n]\n\nsolver = Solver()\nfor constraint in constraints:\n  solver.add(constraint)\n\nmodels = list(all_smt(solver))\nfor model in models: print(model)",
          "symPyProgram": "from sympy import Symbol\nfrom sympy import simplify\nfrom sympy.core.relational import Eq, Ne, StrictGreaterThan, StrictLessThan, LessThan, GreaterThan\nfrom sympy.printing import ccode\n\nsrc = Symbol('src')\ndestDir = Symbol('destDir')\ncreateDestDir = Symbol('createDestDir')\nsrc_exists = Symbol('src_exists')\nsrc_isDirectory = Symbol('src_isDirectory')\ndestDir_exists = Symbol('destDir_exists')\ndestDir_isDirectory = Symbol('destDir_isDirectory')\nnull = Symbol('null')\npath_conjunction = (((((((((~((Eq(src, null)))) & (~((Eq(destDir, null))))) & (~((~(src_exists))))) & (~(src_isDirectory))) & (~((Eq(src, null))))) & (~((Eq(destDir, null))))) & (~(((~(destDir_exists)) & createDestDir)))) & (~((~(destDir_exists))))) & (~(destDir_isDirectory)))\nprint(ccode(simplify(path_conjunction)))",
          "soundSymbolic": false,
          "soundBackwards": true,
          "maybe": true,
          "line": 3067,
          "throwingLine": 3080,
          "isStatic": true,
          "targetOnlyArguments": true
        },
        {
          "qualifiedSignature": "org.apache.commons.io.FileUtils.moveToDirectory(java.io.File, java.io.File, boolean)",
          "exception": "throw new NullPointerException(\"Source must not be null\");",
          "pathCojunction": "(src == null)",
          "symbolicPathConjunction": "(src == null)",
          "backwardsPathConjunction": "(src == null)",
          "simplifiedPathConjunction": "null == src",
          "z3Inputs": "[src0_isNull = True]\n",
          "z3Program": "from z3 import *\nfrom z3_all_models import *\n\ncreateDestDir0 = Bool('createDestDir0')\nsrc0_isNull = Bool('src0_isNull')\n\nconstraints = [\n  src0_isNull\n]\n\nsolver = Solver()\nfor constraint in constraints:\n  solver.add(constraint)\n\nmodels = list(all_smt(solver))\nfor model in models: print(model)",
          "symPyProgram": "from sympy import Symbol\nfrom sympy import simplify\nfrom sympy.core.relational import Eq, Ne, StrictGreaterThan, StrictLessThan, LessThan, GreaterThan\nfrom sympy.printing import ccode\n\nsrc = Symbol('src')\nnull = Symbol('null')\npath_conjunction = (Eq(src, null))\nprint(ccode(simplify(path_conjunction)))",
          "soundSymbolic": true,
          "soundBackwards": true,
          "maybe": false,
          "line": 3067,
          "throwingLine": 3069,
          "isStatic": true,
          "targetOnlyArguments": true
        },
        {
          "qualifiedSignature": "org.apache.commons.io.FileUtils.moveToDirectory(java.io.File, java.io.File, boolean)",
          "exception": "throw new FileNotFoundException(\"Destination directory '\" + destDir + \"' does not exist [createDestDir=\" + createDestDir + \"]\")",
          "pathCojunction": "(!(src == null)) && (!(destDir == null)) && (!(!src.exists())) && (!(src.isDirectory())) && (!(src == null)) && (!(destDir == null)) && (!(!destDir.exists() && createDestDir)) && (!(destDir.exists()))",
          "symbolicPathConjunction": "(!(src == null)) && (!(destDir == null)) && (!(!src.exists())) && (!(src.isDirectory())) && (!(moveFileToDirectory(src, destDir, createDestDir)))",
          "backwardsPathConjunction": "(!(src == null)) && (!(destDir == null)) && (!(!src.exists())) && (!(src.isDirectory())) && (!(src == null)) && (!(destDir == null)) && (!(!destDir.exists() && createDestDir)) && (!(destDir.exists()))",
          "simplifiedPathConjunction": "src.exists() && !createDestDir && !destDir.exists() && !src.isDirectory() && destDir != null && null != src",
          "z3Program": "from z3 import *\nfrom z3_all_models import *\n\ncreateDestDir0 = Bool('createDestDir0')\nsrc0_isNull = Bool('src0_isNull')\ndestDir0_isNull = Bool('destDir0_isNull')\n\nconstraints = [\n  And(And(And(And(And(And(And(Not(src0_isNull), Not(destDir0_isNull)), Not(Not(src0.exists()))), Not(src0.isDirectory())), Not(src0_isNull)), Not(destDir0_isNull)), Not(And(Not(destDir0.exists()), createDestDir0))), Not(destDir0.exists()))\n]\n\nsolver = Solver()\nfor constraint in constraints:\n  solver.add(constraint)\n\nmodels = list(all_smt(solver))\nfor model in models: print(model)",
          "symPyProgram": "from sympy import Symbol\nfrom sympy import simplify\nfrom sympy.core.relational import Eq, Ne, StrictGreaterThan, StrictLessThan, LessThan, GreaterThan\nfrom sympy.printing import ccode\n\nsrc = Symbol('src')\ndestDir = Symbol('destDir')\ncreateDestDir = Symbol('createDestDir')\nsrc_exists = Symbol('src_exists')\nsrc_isDirectory = Symbol('src_isDirectory')\ndestDir_exists = Symbol('destDir_exists')\nnull = Symbol('null')\npath_conjunction = ((((((((~((Eq(src, null)))) & (~((Eq(destDir, null))))) & (~((~(src_exists))))) & (~(src_isDirectory))) & (~((Eq(src, null))))) & (~((Eq(destDir, null))))) & (~(((~(destDir_exists)) & createDestDir)))) & (~(destDir_exists)))\nprint(ccode(simplify(path_conjunction)))",
          "soundSymbolic": false,
          "soundBackwards": true,
          "maybe": true,
          "line": 3067,
          "throwingLine": 3080,
          "isStatic": true,
          "targetOnlyArguments": true
        },
        {
          "qualifiedSignature": "org.apache.commons.io.FileUtils.moveToDirectory(java.io.File, java.io.File, boolean)",
          "exception": "throw new FileNotFoundException(\"Destination directory '\" + destDir + \"' does not exist [createDestDir=\" + createDestDir + \"]\");",
          "pathCojunction": "(!(src == null)) && (!(destDir == null)) && (!(!src.exists())) && (src.isDirectory()) && (!(src == null)) && (!(destDir == null)) && (!destDir.exists() && createDestDir) && (!(destDir.exists()))",
          "symbolicPathConjunction": "(!(src == null)) && (!(destDir == null)) && (!(!src.exists())) && (src.isDirectory()) && (moveDirectoryToDirectory(src, destDir, createDestDir))",
          "backwardsPathConjunction": "(!(src == null)) && (!(destDir == null)) && (!(!src.exists())) && (src.isDirectory()) && (!(src == null)) && (!(destDir == null)) && (!destDir.exists() && createDestDir) && (!(destDir.exists()))",
          "simplifiedPathConjunction": "createDestDir && src.exists() && src.isDirectory() && !destDir.exists() && destDir != null && null != src",
          "z3Program": "from z3 import *\nfrom z3_all_models import *\n\ncreateDestDir0 = Bool('createDestDir0')\nsrc0_isNull = Bool('src0_isNull')\ndestDir0_isNull = Bool('destDir0_isNull')\n\nconstraints = [\n  And(And(And(And(And(And(And(Not(src0_isNull), Not(destDir0_isNull)), Not(Not(src0.exists()))), src0.isDirectory()), Not(src0_isNull)), Not(destDir0_isNull)), And(Not(destDir0.exists()), createDestDir0)), Not(destDir0.exists()))\n]\n\nsolver = Solver()\nfor constraint in constraints:\n  solver.add(constraint)\n\nmodels = list(all_smt(solver))\nfor model in models: print(model)",
          "symPyProgram": "from sympy import Symbol\nfrom sympy import simplify\nfrom sympy.core.relational import Eq, Ne, StrictGreaterThan, StrictLessThan, LessThan, GreaterThan\nfrom sympy.printing import ccode\n\nsrc = Symbol('src')\ndestDir = Symbol('destDir')\ncreateDestDir = Symbol('createDestDir')\nsrc_exists = Symbol('src_exists')\nsrc_isDirectory = Symbol('src_isDirectory')\ndestDir_exists = Symbol('destDir_exists')\nnull = Symbol('null')\npath_conjunction = ((((((((~((Eq(src, null)))) & (~((Eq(destDir, null))))) & (~((~(src_exists))))) & src_isDirectory) & (~((Eq(src, null))))) & (~((Eq(destDir, null))))) & ((~(destDir_exists)) & createDestDir)) & (~(destDir_exists)))\nprint(ccode(simplify(path_conjunction)))",
          "soundSymbolic": false,
          "soundBackwards": true,
          "maybe": true,
          "line": 3067,
          "throwingLine": 3078,
          "isStatic": true,
          "targetOnlyArguments": true
        },
        {
          "qualifiedSignature": "org.apache.commons.io.FileUtils.isSymlink(java.io.File)",
          "exception": "throw new NullPointerException(\"File must not be null\");",
          "pathCojunction": "(file == null)",
          "symbolicPathConjunction": "(file == null)",
          "backwardsPathConjunction": "(file == null)",
          "simplifiedPathConjunction": "file == null",
          "z3Inputs": "[file0_isNull = True]\n",
          "z3Program": "from z3 import *\nfrom z3_all_models import *\n\nfile0_isNull = Bool('file0_isNull')\n\nconstraints = [\n  file0_isNull\n]\n\nsolver = Solver()\nfor constraint in constraints:\n  solver.add(constraint)\n\nmodels = list(all_smt(solver))\nfor model in models: print(model)",
          "symPyProgram": "from sympy import Symbol\nfrom sympy import simplify\nfrom sympy.core.relational import Eq, Ne, StrictGreaterThan, StrictLessThan, LessThan, GreaterThan\nfrom sympy.printing import ccode\n\nfile = Symbol('file')\nnull = Symbol('null')\npath_conjunction = (Eq(file, null))\nprint(ccode(simplify(path_conjunction)))",
          "soundSymbolic": true,
          "soundBackwards": true,
          "maybe": false,
          "line": 3103,
          "throwingLine": 3105,
          "isStatic": true,
          "targetOnlyArguments": true
        }
      ]
    },
    {
      "path": "/home/yanghengqin/commons-io-commons-io-2.6/src/main/java/org/apache/commons/io/output/ByteArrayOutputStream.java",
      "methods": [
        {
          "qualifiedSignature": "org.apache.commons.io.output.ByteArrayOutputStream.write(byte[], int, int)",
          "exception": "throw new IndexOutOfBoundsException();",
          "pathCojunction": "(off < 0) || (off > b.length) || (len < 0) || ((off + len) > b.length) || ((off + len) < 0)",
          "symbolicPathConjunction": "((off < 0) || (off > b.length) || (len < 0) || ((off + len) > b.length) || ((off + len) < 0))",
          "backwardsPathConjunction": "(off < 0) || (off > b.length) || (len < 0) || ((off + len) > b.length) || ((off + len) < 0)",
          "simplifiedPathConjunction": "b.length < off || b.length < len + off || len < 0 || len < -off || off < 0",
          "z3Inputs": "[off0 = 2, b0_length = 0, len0 = -1]\n[off0 = 0, b0_length = 1, len0 = -1]\n[off0 = -1, b0_length = 1]\n[off0 = -2, b0_length = 1, len0 = -2]\n[off0 = -3, b0_length = 1, len0 = -3]\n[b0_length = 2, len0 = -3]\n[b0_length = 3, len0 = -3]\n[off0 = -4, b0_length = 4]\n[off0 = -4, b0_length = 5]\n[off0 = -4, b0_length = 6, len0 = -4]\n",
          "z3Program": "from z3 import *\nfrom z3_all_models import *\n\noff0 = Int('off0')\nlen0 = Int('len0')\nb0_length = Int('b0_length')\n\nconstraints = [\n  b0_length >= 0, # implicit\n  Or(Or(Or(Or(off0 < 0, off0 > b0_length), len0 < 0), off0 + len0 > b0_length), off0 + len0 < 0)\n]\n\nsolver = Solver()\nfor constraint in constraints:\n  solver.add(constraint)\n\nmodels = list(all_smt(solver))\nfor model in models: print(model)",
          "symPyProgram": "from sympy import Symbol\nfrom sympy import simplify\nfrom sympy.core.relational import Eq, Ne, StrictGreaterThan, StrictLessThan, LessThan, GreaterThan\nfrom sympy.printing import ccode\n\nb = Symbol('b')\noff = Symbol('off', integer=True)\nlen = Symbol('len', integer=True)\nb_length = Symbol('b_length', integer=True)\npath_conjunction = (((((StrictLessThan(off, 0)) | (StrictGreaterThan(off, b_length))) | (StrictLessThan(len, 0))) | (StrictGreaterThan((off + len), b_length))) | (StrictLessThan((off + len), 0)))\nprint(ccode(simplify(path_conjunction)))",
          "soundSymbolic": true,
          "soundBackwards": true,
          "maybe": false,
          "line": 140,
          "throwingLine": 146,
          "isStatic": false,
          "targetOnlyArguments": true
        }
      ]
    },
    {
      "path": "/home/yanghengqin/commons-io-commons-io-2.6/src/main/java/org/apache/commons/io/HexDump.java",
      "methods": [
        {
          "qualifiedSignature": "org.apache.commons.io.HexDump.dump(byte[], long, java.io.OutputStream, int)",
          "exception": "throw new IllegalArgumentException(\"cannot write to nullstream\");",
          "pathCojunction": "(!(index < 0 || index >= data.length)) && (stream == null)",
          "symbolicPathConjunction": "(!(index < 0 || index >= data.length)) && (stream == null)",
          "backwardsPathConjunction": "(!(index < 0 || index >= data.length)) && (stream == null)",
          "simplifiedPathConjunction": "null == stream && index >= 0 && data.length > index",
          "z3Inputs": "[offset0 = 0,\n data0_length = 1,\n index0 = 0,\n stream0_isNull = True]\n[offset0 = -1,\n data0_length = 2,\n index0 = 1,\n stream0_isNull = True]\n[offset0 = -2,\n data0_length = 2,\n index0 = 0,\n stream0_isNull = True]\n[offset0 = -3,\n data0_length = 2,\n index0 = 0,\n stream0_isNull = True]\n[offset0 = -3,\n data0_length = 1,\n index0 = 0,\n stream0_isNull = True]\n[offset0 = -4,\n data0_length = 1,\n index0 = 0,\n stream0_isNull = True]\n[offset0 = -4,\n data0_length = 2,\n index0 = 0,\n stream0_isNull = True]\n[offset0 = -5,\n data0_length = 2,\n index0 = 0,\n stream0_isNull = True]\n[offset0 = -6,\n data0_length = 2,\n index0 = 0,\n stream0_isNull = True]\n[offset0 = -7,\n data0_length = 2,\n index0 = 0,\n stream0_isNull = True]\n",
          "z3Program": "from z3 import *\nfrom z3_all_models import *\n\noffset0 = Int('offset0')\nindex0 = Int('index0')\nstream0_isNull = Bool('stream0_isNull')\ndata0_length = Int('data0_length')\n\nconstraints = [\n  data0_length >= 0, # implicit\n  offset0 >= -9223372036854775808, offset0 <= 9223372036854775807, # implicit\n  And(Not(Or(index0 < 0, index0 >= data0_length)), stream0_isNull)\n]\n\nsolver = Solver()\nfor constraint in constraints:\n  solver.add(constraint)\n\nmodels = list(all_smt(solver))\nfor model in models: print(model)",
          "symPyProgram": "from sympy import Symbol\nfrom sympy import simplify\nfrom sympy.core.relational import Eq, Ne, StrictGreaterThan, StrictLessThan, LessThan, GreaterThan\nfrom sympy.printing import ccode\n\ndata = Symbol('data')\nstream = Symbol('stream')\nindex = Symbol('index', integer=True)\ndata_length = Symbol('data_length', integer=True)\nnull = Symbol('null')\npath_conjunction = ((~(((StrictLessThan(index, 0)) | (GreaterThan(index, data_length))))) & (Eq(stream, null)))\nprint(ccode(simplify(path_conjunction)))",
          "soundSymbolic": true,
          "soundBackwards": true,
          "maybe": false,
          "line": 74,
          "throwingLine": 82,
          "isStatic": true,
          "targetOnlyArguments": true
        },
        {
          "qualifiedSignature": "org.apache.commons.io.HexDump.dump(byte[], long, java.io.OutputStream, int)",
          "exception": "throw new ArrayIndexOutOfBoundsException(\"illegal index: \" + index + \" into array of length \" + data.length);",
          "pathCojunction": "(index < 0 || index >= data.length)",
          "symbolicPathConjunction": "(index < 0 || index >= data.length)",
          "backwardsPathConjunction": "(index < 0 || index >= data.length)",
          "simplifiedPathConjunction": "data.length <= index || index < 0",
          "z3Inputs": "[offset0 = 0, data0_length = 0, index0 = -1]\n[offset0 = -1, data0_length = 1, index0 = -2]\n[offset0 = -1, data0_length = 1, index0 = -3]\n[offset0 = -1, data0_length = 1, index0 = -4]\n[offset0 = -2, data0_length = 1, index0 = -4]\n[offset0 = -3, data0_length = 1, index0 = -4]\n[offset0 = -3, data0_length = 2, index0 = -4]\n[offset0 = -3, data0_length = 3, index0 = -4]\n[offset0 = -3, data0_length = 4, index0 = -4]\n[offset0 = -3, data0_length = 5, index0 = -4]\n",
          "z3Program": "from z3 import *\nfrom z3_all_models import *\n\noffset0 = Int('offset0')\nindex0 = Int('index0')\ndata0_length = Int('data0_length')\n\nconstraints = [\n  data0_length >= 0, # implicit\n  offset0 >= -9223372036854775808, offset0 <= 9223372036854775807, # implicit\n  Or(index0 < 0, index0 >= data0_length)\n]\n\nsolver = Solver()\nfor constraint in constraints:\n  solver.add(constraint)\n\nmodels = list(all_smt(solver))\nfor model in models: print(model)",
          "symPyProgram": "from sympy import Symbol\nfrom sympy import simplify\nfrom sympy.core.relational import Eq, Ne, StrictGreaterThan, StrictLessThan, LessThan, GreaterThan\nfrom sympy.printing import ccode\n\ndata = Symbol('data')\nindex = Symbol('index', integer=True)\ndata_length = Symbol('data_length', integer=True)\npath_conjunction = ((StrictLessThan(index, 0)) | (GreaterThan(index, data_length)))\nprint(ccode(simplify(path_conjunction)))",
          "soundSymbolic": true,
          "soundBackwards": true,
          "maybe": false,
          "line": 74,
          "throwingLine": 77,
          "isStatic": true,
          "targetOnlyArguments": true
        }
      ]
    },
    {
      "path": "/home/yanghengqin/commons-io-commons-io-2.6/src/main/java/org/apache/commons/io/input/NullReader.java",
      "methods": [
        {
          "qualifiedSignature": "org.apache.commons.io.input.NullReader.mark(int)",
          "exception": "throw new UnsupportedOperationException(\"Mark not supported\");",
          "pathCojunction": "(!(markSupported))",
          "symbolicPathConjunction": "(!(markSupported))",
          "backwardsPathConjunction": "(!(markSupported))",
          "simplifiedPathConjunction": "!markSupported",
          "z3Inputs": "[markSupported0 = False]\n",
          "z3Program": "from z3 import *\nfrom z3_all_models import *\n\nreadlimit0 = Int('readlimit0')\nmarkSupported0 = Bool('markSupported0')\n\nconstraints = [\n  Not(markSupported0)\n]\n\nsolver = Solver()\nfor constraint in constraints:\n  solver.add(constraint)\n\nmodels = list(all_smt(solver))\nfor model in models: print(model)",
          "symPyProgram": "from sympy import Symbol\nfrom sympy import simplify\nfrom sympy.core.relational import Eq, Ne, StrictGreaterThan, StrictLessThan, LessThan, GreaterThan\nfrom sympy.printing import ccode\n\nmarkSupported = Symbol('markSupported')\npath_conjunction = (~(markSupported))\nprint(ccode(simplify(path_conjunction)))",
          "soundSymbolic": true,
          "soundBackwards": true,
          "maybe": false,
          "line": 141,
          "throwingLine": 143,
          "isStatic": false,
          "targetOnlyArguments": false
        },
        {
          "qualifiedSignature": "org.apache.commons.io.input.NullReader.read()",
          "exception": "throw new EOFException();",
          "pathCojunction": "(!(eof)) && (position == size) && (throwEofException)",
          "symbolicPathConjunction": "(!(eof)) && (position == size) && (throwEofException)",
          "backwardsPathConjunction": "(!(eof)) && (position == size) && (throwEofException)",
          "simplifiedPathConjunction": "throwEofException && position == size && !eof",
          "z3Inputs": "[size0 = -9223372036854775808,\n throwEofException0 = True,\n position0 = -9223372036854775808,\n eof0 = False]\n[eof0 = False,\n position0 = 0,\n throwEofException0 = True,\n size0 = 0]\n[eof0 = False,\n position0 = -1,\n throwEofException0 = True,\n size0 = -1]\n[eof0 = False,\n position0 = -2,\n throwEofException0 = True,\n size0 = -2]\n[eof0 = False,\n position0 = -3,\n throwEofException0 = True,\n size0 = -3]\n[eof0 = False,\n position0 = -4,\n throwEofException0 = True,\n size0 = -4]\n[eof0 = False,\n position0 = -5,\n throwEofException0 = True,\n size0 = -5]\n[eof0 = False,\n position0 = -6,\n throwEofException0 = True,\n size0 = -6]\n[eof0 = False,\n position0 = -7,\n throwEofException0 = True,\n size0 = -7]\n[eof0 = False,\n position0 = -8,\n throwEofException0 = True,\n size0 = -8]\n",
          "z3Program": "from z3 import *\nfrom z3_all_models import *\n\neof0 = Bool('eof0')\nposition0 = Int('position0')\nsize0 = Int('size0')\nthrowEofException0 = Bool('throwEofException0')\n\nconstraints = [\n  position0 >= -9223372036854775808, position0 <= 9223372036854775807, # implicit\n  size0 >= -9223372036854775808, size0 <= 9223372036854775807, # implicit\n  And(And(Not(eof0), position0 == size0), throwEofException0)\n]\n\nsolver = Solver()\nfor constraint in constraints:\n  solver.add(constraint)\n\nmodels = list(all_smt(solver))\nfor model in models: print(model)",
          "symPyProgram": "from sympy import Symbol\nfrom sympy import simplify\nfrom sympy.core.relational import Eq, Ne, StrictGreaterThan, StrictLessThan, LessThan, GreaterThan\nfrom sympy.printing import ccode\n\neof = Symbol('eof')\nposition = Symbol('position')\nsize = Symbol('size')\nthrowEofException = Symbol('throwEofException')\npath_conjunction = (((~(eof)) & (Eq(position, size))) & throwEofException)\nprint(ccode(simplify(path_conjunction)))",
          "soundSymbolic": true,
          "soundBackwards": true,
          "maybe": false,
          "line": 170,
          "throwingLine": 175,
          "isStatic": false,
          "targetOnlyArguments": false
        },
        {
          "qualifiedSignature": "org.apache.commons.io.input.NullReader.read()",
          "exception": "throw new IOException(\"Read after end of file\");",
          "pathCojunction": "(eof)",
          "symbolicPathConjunction": "(eof)",
          "backwardsPathConjunction": "(eof)",
          "simplifiedPathConjunction": "eof",
          "z3Inputs": "[eof0 = True]\n",
          "z3Program": "from z3 import *\nfrom z3_all_models import *\n\neof0 = Bool('eof0')\n\nconstraints = [\n  eof0\n]\n\nsolver = Solver()\nfor constraint in constraints:\n  solver.add(constraint)\n\nmodels = list(all_smt(solver))\nfor model in models: print(model)",
          "symPyProgram": "from sympy import Symbol\nfrom sympy import simplify\nfrom sympy.core.relational import Eq, Ne, StrictGreaterThan, StrictLessThan, LessThan, GreaterThan\nfrom sympy.printing import ccode\n\neof = Symbol('eof')\npath_conjunction = eof\nprint(ccode(simplify(path_conjunction)))",
          "soundSymbolic": true,
          "soundBackwards": true,
          "maybe": false,
          "line": 170,
          "throwingLine": 172,
          "isStatic": false,
          "targetOnlyArguments": false
        },
        {
          "qualifiedSignature": "org.apache.commons.io.input.NullReader.read(char[])",
          "exception": "throw new EOFException()",
          "pathCojunction": "(!(eof)) && (position == size) && (throwEofException)",
          "symbolicPathConjunction": "(read(chars, 0, chars.length))",
          "backwardsPathConjunction": "(!(eof)) && (position == size) && (throwEofException)",
          "simplifiedPathConjunction": "throwEofException && position == size && !eof",
          "z3Inputs": "[size0 = -9223372036854775808,\n throwEofException0 = True,\n position0 = -9223372036854775808,\n eof0 = False]\n[eof0 = False,\n position0 = 0,\n throwEofException0 = True,\n size0 = 0]\n[eof0 = False,\n position0 = -1,\n throwEofException0 = True,\n size0 = -1]\n[eof0 = False,\n position0 = -2,\n throwEofException0 = True,\n size0 = -2]\n[eof0 = False,\n position0 = -3,\n throwEofException0 = True,\n size0 = -3]\n[eof0 = False,\n position0 = -4,\n throwEofException0 = True,\n size0 = -4]\n[eof0 = False,\n position0 = -5,\n throwEofException0 = True,\n size0 = -5]\n[eof0 = False,\n position0 = -6,\n throwEofException0 = True,\n size0 = -6]\n[eof0 = False,\n position0 = -7,\n throwEofException0 = True,\n size0 = -7]\n[eof0 = False,\n position0 = -8,\n throwEofException0 = True,\n size0 = -8]\n",
          "z3Program": "from z3 import *\nfrom z3_all_models import *\n\nsize0 = Int('size0')\nposition0 = Int('position0')\nthrowEofException0 = Bool('throwEofException0')\neof0 = Bool('eof0')\n\nconstraints = [\n  size0 >= -9223372036854775808, size0 <= 9223372036854775807, # implicit\n  position0 >= -9223372036854775808, position0 <= 9223372036854775807, # implicit\n  And(And(Not(eof0), position0 == size0), throwEofException0)\n]\n\nsolver = Solver()\nfor constraint in constraints:\n  solver.add(constraint)\n\nmodels = list(all_smt(solver))\nfor model in models: print(model)",
          "symPyProgram": "from sympy import Symbol\nfrom sympy import simplify\nfrom sympy.core.relational import Eq, Ne, StrictGreaterThan, StrictLessThan, LessThan, GreaterThan\nfrom sympy.printing import ccode\n\nsize = Symbol('size')\nposition = Symbol('position')\nthrowEofException = Symbol('throwEofException')\neof = Symbol('eof')\npath_conjunction = (((~(eof)) & (Eq(position, size))) & throwEofException)\nprint(ccode(simplify(path_conjunction)))",
          "soundSymbolic": true,
          "soundBackwards": true,
          "maybe": false,
          "line": 193,
          "throwingLine": 194,
          "isStatic": false,
          "targetOnlyArguments": false
        },
        {
          "qualifiedSignature": "org.apache.commons.io.input.NullReader.read(char[])",
          "exception": "throw new IOException(\"Read after end of file\")",
          "pathCojunction": "(eof)",
          "symbolicPathConjunction": "(read(chars, 0, chars.length))",
          "backwardsPathConjunction": "(eof)",
          "simplifiedPathConjunction": "eof",
          "z3Inputs": "[eof0 = True]\n",
          "z3Program": "from z3 import *\nfrom z3_all_models import *\n\neof0 = Bool('eof0')\n\nconstraints = [\n  eof0\n]\n\nsolver = Solver()\nfor constraint in constraints:\n  solver.add(constraint)\n\nmodels = list(all_smt(solver))\nfor model in models: print(model)",
          "symPyProgram": "from sympy import Symbol\nfrom sympy import simplify\nfrom sympy.core.relational import Eq, Ne, StrictGreaterThan, StrictLessThan, LessThan, GreaterThan\nfrom sympy.printing import ccode\n\neof = Symbol('eof')\npath_conjunction = eof\nprint(ccode(simplify(path_conjunction)))",
          "soundSymbolic": true,
          "soundBackwards": true,
          "maybe": false,
          "line": 193,
          "throwingLine": 194,
          "isStatic": false,
          "targetOnlyArguments": false
        },
        {
          "qualifiedSignature": "org.apache.commons.io.input.NullReader.read(char[], int, int)",
          "exception": "throw new EOFException();",
          "pathCojunction": "(!(eof)) && (position == size) && (throwEofException)",
          "symbolicPathConjunction": "(!(eof)) && (position == size) && (throwEofException)",
          "backwardsPathConjunction": "(!(eof)) && (position == size) && (throwEofException)",
          "simplifiedPathConjunction": "throwEofException && position == size && !eof",
          "z3Inputs": "[size0 = -9223372036854775808,\n throwEofException0 = True,\n position0 = -9223372036854775808,\n eof0 = False]\n[eof0 = False,\n position0 = 0,\n throwEofException0 = True,\n size0 = 0]\n[eof0 = False,\n position0 = -1,\n throwEofException0 = True,\n size0 = -1]\n[eof0 = False,\n position0 = -2,\n throwEofException0 = True,\n size0 = -2]\n[eof0 = False,\n position0 = -3,\n throwEofException0 = True,\n size0 = -3]\n[eof0 = False,\n position0 = -4,\n throwEofException0 = True,\n size0 = -4]\n[eof0 = False,\n position0 = -5,\n throwEofException0 = True,\n size0 = -5]\n[eof0 = False,\n position0 = -6,\n throwEofException0 = True,\n size0 = -6]\n[eof0 = False,\n position0 = -7,\n throwEofException0 = True,\n size0 = -7]\n[eof0 = False,\n position0 = -8,\n throwEofException0 = True,\n size0 = -8]\n",
          "z3Program": "from z3 import *\nfrom z3_all_models import *\n\noffset0 = Int('offset0')\nlength0 = Int('length0')\neof0 = Bool('eof0')\nposition0 = Int('position0')\nsize0 = Int('size0')\nthrowEofException0 = Bool('throwEofException0')\n\nconstraints = [\n  position0 >= -9223372036854775808, position0 <= 9223372036854775807, # implicit\n  size0 >= -9223372036854775808, size0 <= 9223372036854775807, # implicit\n  And(And(Not(eof0), position0 == size0), throwEofException0)\n]\n\nsolver = Solver()\nfor constraint in constraints:\n  solver.add(constraint)\n\nmodels = list(all_smt(solver))\nfor model in models: print(model)",
          "symPyProgram": "from sympy import Symbol\nfrom sympy import simplify\nfrom sympy.core.relational import Eq, Ne, StrictGreaterThan, StrictLessThan, LessThan, GreaterThan\nfrom sympy.printing import ccode\n\neof = Symbol('eof')\nposition = Symbol('position')\nsize = Symbol('size')\nthrowEofException = Symbol('throwEofException')\npath_conjunction = (((~(eof)) & (Eq(position, size))) & throwEofException)\nprint(ccode(simplify(path_conjunction)))",
          "soundSymbolic": true,
          "soundBackwards": true,
          "maybe": false,
          "line": 211,
          "throwingLine": 216,
          "isStatic": false,
          "targetOnlyArguments": false
        },
        {
          "qualifiedSignature": "org.apache.commons.io.input.NullReader.read(char[], int, int)",
          "exception": "throw new IOException(\"Read after end of file\");",
          "pathCojunction": "(eof)",
          "symbolicPathConjunction": "(eof)",
          "backwardsPathConjunction": "(eof)",
          "simplifiedPathConjunction": "eof",
          "z3Inputs": "[eof0 = True]\n",
          "z3Program": "from z3 import *\nfrom z3_all_models import *\n\noffset0 = Int('offset0')\nlength0 = Int('length0')\neof0 = Bool('eof0')\n\nconstraints = [\n  eof0\n]\n\nsolver = Solver()\nfor constraint in constraints:\n  solver.add(constraint)\n\nmodels = list(all_smt(solver))\nfor model in models: print(model)",
          "symPyProgram": "from sympy import Symbol\nfrom sympy import simplify\nfrom sympy.core.relational import Eq, Ne, StrictGreaterThan, StrictLessThan, LessThan, GreaterThan\nfrom sympy.printing import ccode\n\neof = Symbol('eof')\npath_conjunction = eof\nprint(ccode(simplify(path_conjunction)))",
          "soundSymbolic": true,
          "soundBackwards": true,
          "maybe": false,
          "line": 211,
          "throwingLine": 213,
          "isStatic": false,
          "targetOnlyArguments": false
        },
        {
          "qualifiedSignature": "org.apache.commons.io.input.NullReader.reset()",
          "exception": "throw new IOException(\"No position has been marked\");",
          "pathCojunction": "(!(!markSupported)) && (mark < 0)",
          "symbolicPathConjunction": "(!(!markSupported)) && (mark < 0)",
          "backwardsPathConjunction": "(!(!markSupported)) && (mark < 0)",
          "simplifiedPathConjunction": "markSupported && mark < 0",
          "z3Inputs": "[mark0 = -1, markSupported0 = True]\n[mark0 = -2, markSupported0 = True]\n[mark0 = -3, markSupported0 = True]\n[mark0 = -4, markSupported0 = True]\n[mark0 = -5, markSupported0 = True]\n[mark0 = -6, markSupported0 = True]\n[mark0 = -7, markSupported0 = True]\n[mark0 = -8, markSupported0 = True]\n[mark0 = -9, markSupported0 = True]\n[mark0 = -10, markSupported0 = True]\n",
          "z3Program": "from z3 import *\nfrom z3_all_models import *\n\nmarkSupported0 = Bool('markSupported0')\nmark0 = Int('mark0')\n\nconstraints = [\n  And(Not(Not(markSupported0)), mark0 < 0)\n]\n\nsolver = Solver()\nfor constraint in constraints:\n  solver.add(constraint)\n\nmodels = list(all_smt(solver))\nfor model in models: print(model)",
          "symPyProgram": "from sympy import Symbol\nfrom sympy import simplify\nfrom sympy.core.relational import Eq, Ne, StrictGreaterThan, StrictLessThan, LessThan, GreaterThan\nfrom sympy.printing import ccode\n\nmarkSupported = Symbol('markSupported')\nmark = Symbol('mark', integer=True)\npath_conjunction = ((~((~(markSupported)))) & (StrictLessThan(mark, 0)))\nprint(ccode(simplify(path_conjunction)))",
          "soundSymbolic": true,
          "soundBackwards": true,
          "maybe": false,
          "line": 237,
          "throwingLine": 242,
          "isStatic": false,
          "targetOnlyArguments": false
        },
        {
          "qualifiedSignature": "org.apache.commons.io.input.NullReader.reset()",
          "exception": "throw new IOException(\"Marked position [\" + mark + \"] is no longer valid - passed the read limit [\" + readlimit + \"]\");",
          "pathCojunction": "(!(!markSupported)) && (!(mark < 0)) && (position > mark + readlimit)",
          "symbolicPathConjunction": "(!(!markSupported)) && (!(mark < 0)) && (position > mark + readlimit)",
          "backwardsPathConjunction": "(!(!markSupported)) && (!(mark < 0)) && (position > mark + readlimit)",
          "simplifiedPathConjunction": "markSupported && mark >= 0 && mark < position - readlimit",
          "z3Inputs": "[position0 = 0,\n readlimit0 = -1,\n mark0 = 0,\n markSupported0 = True]\n[position0 = -1,\n readlimit0 = -3,\n mark0 = 1,\n markSupported0 = True]\n[position0 = -2,\n readlimit0 = -3,\n mark0 = 0,\n markSupported0 = True]\n[position0 = -3,\n readlimit0 = -4,\n mark0 = 0,\n markSupported0 = True]\n[position0 = -4,\n readlimit0 = -5,\n mark0 = 0,\n markSupported0 = True]\n[position0 = -5,\n readlimit0 = -6,\n mark0 = 0,\n markSupported0 = True]\n[position0 = -6,\n readlimit0 = -7,\n mark0 = 0,\n markSupported0 = True]\n[position0 = -7,\n readlimit0 = -8,\n mark0 = 0,\n markSupported0 = True]\n[position0 = -8,\n readlimit0 = -9,\n mark0 = 0,\n markSupported0 = True]\n[position0 = -9,\n readlimit0 = -10,\n mark0 = 0,\n markSupported0 = True]\n",
          "z3Program": "from z3 import *\nfrom z3_all_models import *\n\nmarkSupported0 = Bool('markSupported0')\nmark0 = Int('mark0')\nposition0 = Int('position0')\nreadlimit0 = Int('readlimit0')\n\nconstraints = [\n  position0 >= -9223372036854775808, position0 <= 9223372036854775807, # implicit\n  readlimit0 >= -9223372036854775808, readlimit0 <= 9223372036854775807, # implicit\n  And(And(Not(Not(markSupported0)), Not(mark0 < 0)), position0 > mark0 + readlimit0)\n]\n\nsolver = Solver()\nfor constraint in constraints:\n  solver.add(constraint)\n\nmodels = list(all_smt(solver))\nfor model in models: print(model)",
          "symPyProgram": "from sympy import Symbol\nfrom sympy import simplify\nfrom sympy.core.relational import Eq, Ne, StrictGreaterThan, StrictLessThan, LessThan, GreaterThan\nfrom sympy.printing import ccode\n\nmarkSupported = Symbol('markSupported')\nmark = Symbol('mark', integer=True)\nposition = Symbol('position')\nreadlimit = Symbol('readlimit')\npath_conjunction = (((~((~(markSupported)))) & (~((StrictLessThan(mark, 0))))) & (StrictGreaterThan(position, (mark + readlimit))))\nprint(ccode(simplify(path_conjunction)))",
          "soundSymbolic": true,
          "soundBackwards": true,
          "maybe": false,
          "line": 237,
          "throwingLine": 245,
          "isStatic": false,
          "targetOnlyArguments": false
        },
        {
          "qualifiedSignature": "org.apache.commons.io.input.NullReader.reset()",
          "exception": "throw new UnsupportedOperationException(\"Mark not supported\");",
          "pathCojunction": "(!(markSupported))",
          "symbolicPathConjunction": "(!(markSupported))",
          "backwardsPathConjunction": "(!(markSupported))",
          "simplifiedPathConjunction": "!markSupported",
          "z3Inputs": "[markSupported0 = False]\n",
          "z3Program": "from z3 import *\nfrom z3_all_models import *\n\nmarkSupported0 = Bool('markSupported0')\n\nconstraints = [\n  Not(markSupported0)\n]\n\nsolver = Solver()\nfor constraint in constraints:\n  solver.add(constraint)\n\nmodels = list(all_smt(solver))\nfor model in models: print(model)",
          "symPyProgram": "from sympy import Symbol\nfrom sympy import simplify\nfrom sympy.core.relational import Eq, Ne, StrictGreaterThan, StrictLessThan, LessThan, GreaterThan\nfrom sympy.printing import ccode\n\nmarkSupported = Symbol('markSupported')\npath_conjunction = (~(markSupported))\nprint(ccode(simplify(path_conjunction)))",
          "soundSymbolic": true,
          "soundBackwards": true,
          "maybe": false,
          "line": 237,
          "throwingLine": 239,
          "isStatic": false,
          "targetOnlyArguments": false
        },
        {
          "qualifiedSignature": "org.apache.commons.io.input.NullReader.skip(long)",
          "exception": "throw new IOException(\"Skip after end of file\");",
          "pathCojunction": "(eof)",
          "symbolicPathConjunction": "(eof)",
          "backwardsPathConjunction": "(eof)",
          "simplifiedPathConjunction": "eof",
          "z3Inputs": "[numberOfChars0 = -9223372036854775808, eof0 = True]\n[eof0 = True, numberOfChars0 = 0]\n[eof0 = True, numberOfChars0 = -1]\n[eof0 = True, numberOfChars0 = -2]\n[eof0 = True, numberOfChars0 = -3]\n[eof0 = True, numberOfChars0 = -4]\n[eof0 = True, numberOfChars0 = -5]\n[eof0 = True, numberOfChars0 = -6]\n[eof0 = True, numberOfChars0 = -7]\n[eof0 = True, numberOfChars0 = -8]\n",
          "z3Program": "from z3 import *\nfrom z3_all_models import *\n\nnumberOfChars0 = Int('numberOfChars0')\neof0 = Bool('eof0')\n\nconstraints = [\n  numberOfChars0 >= -9223372036854775808, numberOfChars0 <= 9223372036854775807, # implicit\n  eof0\n]\n\nsolver = Solver()\nfor constraint in constraints:\n  solver.add(constraint)\n\nmodels = list(all_smt(solver))\nfor model in models: print(model)",
          "symPyProgram": "from sympy import Symbol\nfrom sympy import simplify\nfrom sympy.core.relational import Eq, Ne, StrictGreaterThan, StrictLessThan, LessThan, GreaterThan\nfrom sympy.printing import ccode\n\neof = Symbol('eof')\npath_conjunction = eof\nprint(ccode(simplify(path_conjunction)))",
          "soundSymbolic": true,
          "soundBackwards": true,
          "maybe": false,
          "line": 265,
          "throwingLine": 267,
          "isStatic": false,
          "targetOnlyArguments": false
        },
        {
          "qualifiedSignature": "org.apache.commons.io.input.NullReader.skip(long)",
          "exception": "throw new EOFException();",
          "pathCojunction": "(!(eof)) && (position == size) && (throwEofException)",
          "symbolicPathConjunction": "(!(eof)) && (position == size) && (throwEofException)",
          "backwardsPathConjunction": "(!(eof)) && (position == size) && (throwEofException)",
          "simplifiedPathConjunction": "throwEofException && position == size && !eof",
          "z3Inputs": "[size0 = 0,\n numberOfChars0 = 0,\n throwEofException0 = True,\n position0 = 0,\n eof0 = False]\n[eof0 = False,\n position0 = -1,\n throwEofException0 = True,\n size0 = -1,\n numberOfChars0 = -1]\n[eof0 = False,\n position0 = -2,\n throwEofException0 = True,\n size0 = -2,\n numberOfChars0 = -2]\n[eof0 = False,\n position0 = -3,\n throwEofException0 = True,\n size0 = -3,\n numberOfChars0 = -3]\n[eof0 = False,\n position0 = -4,\n throwEofException0 = True,\n size0 = -4,\n numberOfChars0 = -4]\n[eof0 = False,\n position0 = -5,\n throwEofException0 = True,\n size0 = -5,\n numberOfChars0 = -5]\n[eof0 = False,\n position0 = -6,\n throwEofException0 = True,\n size0 = -6,\n numberOfChars0 = -6]\n[eof0 = False,\n position0 = -7,\n throwEofException0 = True,\n size0 = -7,\n numberOfChars0 = -7]\n[eof0 = False,\n position0 = -8,\n throwEofException0 = True,\n size0 = -8,\n numberOfChars0 = -8]\n[eof0 = False,\n position0 = -9,\n throwEofException0 = True,\n size0 = -9,\n numberOfChars0 = -9]\n",
          "z3Program": "from z3 import *\nfrom z3_all_models import *\n\nnumberOfChars0 = Int('numberOfChars0')\neof0 = Bool('eof0')\nposition0 = Int('position0')\nsize0 = Int('size0')\nthrowEofException0 = Bool('throwEofException0')\n\nconstraints = [\n  numberOfChars0 >= -9223372036854775808, numberOfChars0 <= 9223372036854775807, # implicit\n  position0 >= -9223372036854775808, position0 <= 9223372036854775807, # implicit\n  size0 >= -9223372036854775808, size0 <= 9223372036854775807, # implicit\n  And(And(Not(eof0), position0 == size0), throwEofException0)\n]\n\nsolver = Solver()\nfor constraint in constraints:\n  solver.add(constraint)\n\nmodels = list(all_smt(solver))\nfor model in models: print(model)",
          "symPyProgram": "from sympy import Symbol\nfrom sympy import simplify\nfrom sympy.core.relational import Eq, Ne, StrictGreaterThan, StrictLessThan, LessThan, GreaterThan\nfrom sympy.printing import ccode\n\neof = Symbol('eof')\nposition = Symbol('position')\nsize = Symbol('size')\nthrowEofException = Symbol('throwEofException')\npath_conjunction = (((~(eof)) & (Eq(position, size))) & throwEofException)\nprint(ccode(simplify(path_conjunction)))",
          "soundSymbolic": true,
          "soundBackwards": true,
          "maybe": false,
          "line": 265,
          "throwingLine": 270,
          "isStatic": false,
          "targetOnlyArguments": false
        }
      ]
    },
    {
      "path": "/home/yanghengqin/commons-io-commons-io-2.6/src/main/java/org/apache/commons/io/input/BrokenInputStream.java",
      "methods": [
        {
          "qualifiedSignature": "org.apache.commons.io.input.BrokenInputStream.read()",
          "exception": "throw exception;",
          "pathCojunction": "true",
          "backwardsPathConjunction": "true",
          "simplifiedPathConjunction": "true",
          "soundSymbolic": false,
          "soundBackwards": true,
          "maybe": false,
          "line": 61,
          "throwingLine": 62,
          "isStatic": false,
          "targetOnlyArguments": true
        },
        {
          "qualifiedSignature": "org.apache.commons.io.input.BrokenInputStream.available()",
          "exception": "throw exception;",
          "pathCojunction": "true",
          "backwardsPathConjunction": "true",
          "simplifiedPathConjunction": "true",
          "soundSymbolic": false,
          "soundBackwards": true,
          "maybe": false,
          "line": 72,
          "throwingLine": 73,
          "isStatic": false,
          "targetOnlyArguments": true
        },
        {
          "qualifiedSignature": "org.apache.commons.io.input.BrokenInputStream.skip(long)",
          "exception": "throw exception;",
          "pathCojunction": "true",
          "backwardsPathConjunction": "true",
          "simplifiedPathConjunction": "true",
          "z3Program": "from z3 import *\nfrom z3_all_models import *\n\nn0 = Int('n0')\n\nconstraints = [\n  n0 >= -9223372036854775808, n0 <= 9223372036854775807, # implicit\n  True\n]\n\nsolver = Solver()\nfor constraint in constraints:\n  solver.add(constraint)\n\nmodels = list(all_smt(solver))\nfor model in models: print(model)",
          "soundSymbolic": false,
          "soundBackwards": true,
          "maybe": false,
          "line": 84,
          "throwingLine": 85,
          "isStatic": false,
          "targetOnlyArguments": true
        },
        {
          "qualifiedSignature": "org.apache.commons.io.input.BrokenInputStream.reset()",
          "exception": "throw exception;",
          "pathCojunction": "true",
          "backwardsPathConjunction": "true",
          "simplifiedPathConjunction": "true",
          "soundSymbolic": false,
          "soundBackwards": true,
          "maybe": false,
          "line": 94,
          "throwingLine": 95,
          "isStatic": false,
          "targetOnlyArguments": true
        },
        {
          "qualifiedSignature": "org.apache.commons.io.input.BrokenInputStream.close()",
          "exception": "throw exception;",
          "pathCojunction": "true",
          "backwardsPathConjunction": "true",
          "simplifiedPathConjunction": "true",
          "soundSymbolic": false,
          "soundBackwards": true,
          "maybe": false,
          "line": 104,
          "throwingLine": 105,
          "isStatic": false,
          "targetOnlyArguments": true
        }
      ]
    },
    {
      "path": "/home/yanghengqin/commons-io-commons-io-2.6/src/main/java/org/apache/commons/io/filefilter/AgeFileFilter.java",
      "methods": [
        {
          "qualifiedSignature": "org.apache.commons.io.filefilter.AgeFileFilter.accept(java.io.File)",
          "exception": "throw new IllegalArgumentException(\"No specified file\")",
          "pathCojunction": "(file == null)",
          "symbolicPathConjunction": "(FileUtils.isFileNewer(file, cutoff))",
          "backwardsPathConjunction": "(file == null)",
          "simplifiedPathConjunction": "file == null",
          "z3Inputs": "[cutoff0 = -9223372036854775808, file0_isNull = True]\n[file0_isNull = True, cutoff0 = 0]\n[file0_isNull = True, cutoff0 = -1]\n[file0_isNull = True, cutoff0 = -2]\n[file0_isNull = True, cutoff0 = -3]\n[file0_isNull = True, cutoff0 = -4]\n[file0_isNull = True, cutoff0 = -5]\n[file0_isNull = True, cutoff0 = -6]\n[file0_isNull = True, cutoff0 = -7]\n[file0_isNull = True, cutoff0 = -8]\n",
          "z3Program": "from z3 import *\nfrom z3_all_models import *\n\ncutoff0 = Int('cutoff0')\nfile0_isNull = Bool('file0_isNull')\n\nconstraints = [\n  cutoff0 >= -9223372036854775808, cutoff0 <= 9223372036854775807, # implicit\n  file0_isNull\n]\n\nsolver = Solver()\nfor constraint in constraints:\n  solver.add(constraint)\n\nmodels = list(all_smt(solver))\nfor model in models: print(model)",
          "symPyProgram": "from sympy import Symbol\nfrom sympy import simplify\nfrom sympy.core.relational import Eq, Ne, StrictGreaterThan, StrictLessThan, LessThan, GreaterThan\nfrom sympy.printing import ccode\n\nfile = Symbol('file')\nnull = Symbol('null')\npath_conjunction = (Eq(file, null))\nprint(ccode(simplify(path_conjunction)))",
          "soundSymbolic": true,
          "soundBackwards": true,
          "maybe": false,
          "line": 143,
          "throwingLine": 144,
          "isStatic": false,
          "targetOnlyArguments": true
        }
      ]
    },
    {
      "path": "/home/yanghengqin/commons-io-commons-io-2.6/src/main/java/org/apache/commons/io/IOCase.java",
      "methods": [
        {
          "qualifiedSignature": "org.apache.commons.io.IOCase.checkCompareTo(java.lang.String, java.lang.String)",
          "exception": "throw new NullPointerException(\"The strings must not be null\");",
          "pathCojunction": "(str1 == null || str2 == null)",
          "symbolicPathConjunction": "(str1 == null || str2 == null)",
          "backwardsPathConjunction": "(str1 == null || str2 == null)",
          "simplifiedPathConjunction": "null == str1 || null == str2",
          "z3Inputs": "[str10_isNull = True, str20_isNull = False]\n[str20_isNull = True]\n",
          "z3Program": "from z3 import *\nfrom z3_all_models import *\n\nstr10 = String('str10')\nstr20 = String('str20')\nstr10_isNull = Bool('str10_isNull')\nstr20_isNull = Bool('str20_isNull')\n\nconstraints = [\n  Or(str10_isNull, str20_isNull)\n]\n\nsolver = Solver()\nfor constraint in constraints:\n  solver.add(constraint)\n\nmodels = list(all_smt(solver))\nfor model in models: print(model)",
          "symPyProgram": "from sympy import Symbol\nfrom sympy import simplify\nfrom sympy.core.relational import Eq, Ne, StrictGreaterThan, StrictLessThan, LessThan, GreaterThan\nfrom sympy.printing import ccode\n\nstr1 = Symbol('str1')\nstr2 = Symbol('str2')\nnull = Symbol('null')\npath_conjunction = ((Eq(str1, null)) | (Eq(str2, null)))\nprint(ccode(simplify(path_conjunction)))",
          "soundSymbolic": true,
          "soundBackwards": true,
          "maybe": false,
          "line": 143,
          "throwingLine": 145,
          "isStatic": false,
          "targetOnlyArguments": true
        },
        {
          "qualifiedSignature": "org.apache.commons.io.IOCase.checkEquals(java.lang.String, java.lang.String)",
          "exception": "throw new NullPointerException(\"The strings must not be null\");",
          "pathCojunction": "(str1 == null || str2 == null)",
          "symbolicPathConjunction": "(str1 == null || str2 == null)",
          "backwardsPathConjunction": "(str1 == null || str2 == null)",
          "simplifiedPathConjunction": "null == str1 || null == str2",
          "z3Inputs": "[str10_isNull = True, str20_isNull = False]\n[str20_isNull = True]\n",
          "z3Program": "from z3 import *\nfrom z3_all_models import *\n\nstr10 = String('str10')\nstr20 = String('str20')\nstr10_isNull = Bool('str10_isNull')\nstr20_isNull = Bool('str20_isNull')\n\nconstraints = [\n  Or(str10_isNull, str20_isNull)\n]\n\nsolver = Solver()\nfor constraint in constraints:\n  solver.add(constraint)\n\nmodels = list(all_smt(solver))\nfor model in models: print(model)",
          "symPyProgram": "from sympy import Symbol\nfrom sympy import simplify\nfrom sympy.core.relational import Eq, Ne, StrictGreaterThan, StrictLessThan, LessThan, GreaterThan\nfrom sympy.printing import ccode\n\nstr1 = Symbol('str1')\nstr2 = Symbol('str2')\nnull = Symbol('null')\npath_conjunction = ((Eq(str1, null)) | (Eq(str2, null)))\nprint(ccode(simplify(path_conjunction)))",
          "soundSymbolic": true,
          "soundBackwards": true,
          "maybe": false,
          "line": 161,
          "throwingLine": 163,
          "isStatic": false,
          "targetOnlyArguments": true
        }
      ]
    },
    {
      "path": "/home/yanghengqin/commons-io-commons-io-2.6/src/main/java/org/apache/commons/io/input/BOMInputStream.java",
      "methods": [
        {
          "qualifiedSignature": "org.apache.commons.io.input.BOMInputStream.hasBOM(org.apache.commons.io.ByteOrderMark)",
          "exception": "throw new IllegalArgumentException(\"Stream not configure to detect \" + bom);",
          "pathCojunction": "(!(boms.contains(bom)))",
          "symbolicPathConjunction": "(!boms.contains(bom))",
          "backwardsPathConjunction": "(!(boms.contains(bom)))",
          "simplifiedPathConjunction": "!boms.contains(bom)",
          "z3Program": "from z3 import *\nfrom z3_all_models import *\n\n\nconstraints = [\n  Not(boms0.contains(bom0))\n]\n\nsolver = Solver()\nfor constraint in constraints:\n  solver.add(constraint)\n\nmodels = list(all_smt(solver))\nfor model in models: print(model)",
          "symPyProgram": "from sympy import Symbol\nfrom sympy import simplify\nfrom sympy.core.relational import Eq, Ne, StrictGreaterThan, StrictLessThan, LessThan, GreaterThan\nfrom sympy.printing import ccode\n\nbom = Symbol('bom')\nboms = Symbol('boms')\nboms_contains = Symbol('boms_contains')\npath_conjunction = (~(boms_contains))\nprint(ccode(simplify(path_conjunction)))",
          "soundSymbolic": false,
          "soundBackwards": true,
          "maybe": true,
          "line": 201,
          "throwingLine": 203,
          "isStatic": false,
          "targetOnlyArguments": false
        }
      ]
    },
    {
      "path": "/home/yanghengqin/commons-io-commons-io-2.6/src/main/java/org/apache/commons/io/input/CountingInputStream.java",
      "methods": [
        {
          "qualifiedSignature": "org.apache.commons.io.input.CountingInputStream.getCount()",
          "exception": "throw new ArithmeticException(\"The byte count \" + result + \" is too large to be converted to an int\");",
          "pathCojunction": "(result > Integer.MAX_VALUE)",
          "symbolicPathConjunction": "(getByteCount()) && (result > Integer.MAX_VALUE)",
          "backwardsPathConjunction": "(this.count > Integer.MAX_VALUE)",
          "z3Program": "from z3 import *\nfrom z3_all_models import *\n\nresult0 = Int('result0')\n\nconstraints = [\n  result0 == this.count,\n  result0 >= -9223372036854775808, result0 <= 9223372036854775807, # implicit\n  result0 > 2147483647\n]\n\nsolver = Solver()\nfor constraint in constraints:\n  solver.add(constraint)\n\nmodels = list(all_smt(solver))\nfor model in models: print(model)",
          "soundSymbolic": true,
          "soundBackwards": false,
          "maybe": true,
          "line": 88,
          "throwingLine": 91,
          "isStatic": false,
          "targetOnlyArguments": false
        },
        {
          "qualifiedSignature": "org.apache.commons.io.input.CountingInputStream.resetCount()",
          "exception": "throw new ArithmeticException(\"The byte count \" + result + \" is too large to be converted to an int\");",
          "pathCojunction": "(result > Integer.MAX_VALUE)",
          "symbolicPathConjunction": "(resetByteCount()) && (result > Integer.MAX_VALUE)",
          "backwardsPathConjunction": "(tmp > Integer.MAX_VALUE)",
          "z3Program": "from z3 import *\nfrom z3_all_models import *\n\ntmp0 = Int('tmp0')\nresult0 = Int('result0')\n\nconstraints = [\n  tmp0 == this.count,\n  result0 == tmp0,\n  tmp0 >= -9223372036854775808, tmp0 <= 9223372036854775807, # implicit\n  result0 >= -9223372036854775808, result0 <= 9223372036854775807, # implicit\n  result0 > 2147483647\n]\n\nsolver = Solver()\nfor constraint in constraints:\n  solver.add(constraint)\n\nmodels = list(all_smt(solver))\nfor model in models: print(model)",
          "symPyProgram": "from sympy import Symbol\nfrom sympy import simplify\nfrom sympy.core.relational import Eq, Ne, StrictGreaterThan, StrictLessThan, LessThan, GreaterThan\nfrom sympy.printing import ccode\n\nInteger_MAX_VALUE = Symbol('Integer_MAX_VALUE', integer=True)\nInteger_MAX_VALUE = Symbol('Integer_MAX_VALUE', integer=True)\npath_conjunction = (StrictGreaterThan(tmp, Integer_MAX_VALUE))\nprint(ccode(simplify(path_conjunction)))",
          "soundSymbolic": true,
          "soundBackwards": false,
          "maybe": true,
          "line": 106,
          "throwingLine": 109,
          "isStatic": false,
          "targetOnlyArguments": false
        }
      ]
    },
    {
      "path": "/home/yanghengqin/commons-io-commons-io-2.6/src/main/java/org/apache/commons/io/FilenameUtils.java",
      "methods": [
        {
          "qualifiedSignature": "org.apache.commons.io.FilenameUtils.normalize(java.lang.String)",
          "exception": "throw new IllegalArgumentException(\"Null byte present in file/path name. There are no \" + \"known legitimate use cases for such data, but several injection attacks may use it\")",
          "pathCojunction": "(!(filename == null)) && (0 < path.length()) && (filename.charAt(0) == 0)",
          "symbolicPathConjunction": "((!(filename == null)) && (!(failIfNullBytePresent(filename))))",
          "backwardsPathConjunction": "(!(filename == null)) && (0 < path.length()) && (filename.charAt(0) == 0)",
          "simplifiedPathConjunction": "filename.charAt(0) == 0 && path.length() > 0 && filename != null",
          "z3Program": "from z3 import *\nfrom z3_all_models import *\n\nfilename0 = String('filename0')\npath0 = String('path0')\nfilename0_isNull = Bool('filename0_isNull')\n\nconstraints = [\n  SYSTEM_SEPARATOR0 == File.separatorChar,\n  And(And(Not(filename0_isNull), 0 < Length(path0)), filename0.charAt(0) == 0)\n]\n\nsolver = Solver()\nfor constraint in constraints:\n  solver.add(constraint)\n\nmodels = list(all_smt(solver))\nfor model in models: print(model)",
          "symPyProgram": "from sympy import Symbol\nfrom sympy import simplify\nfrom sympy.core.relational import Eq, Ne, StrictGreaterThan, StrictLessThan, LessThan, GreaterThan\nfrom sympy.printing import ccode\n\nfilename = Symbol('filename')\npath = Symbol('path')\npath_length = Symbol('path_length')\nfilename_charAt = Symbol('filename_charAt')\nnull = Symbol('null')\npath_conjunction = (((~((Eq(filename, null)))) & (StrictLessThan(0, path_length))) & (Eq(filename_charAt, 0)))\nprint(ccode(simplify(path_conjunction)))",
          "soundSymbolic": true,
          "soundBackwards": false,
          "maybe": true,
          "line": 194,
          "throwingLine": 195,
          "isStatic": true,
          "targetOnlyArguments": false
        },
        {
          "qualifiedSignature": "org.apache.commons.io.FilenameUtils.normalize(java.lang.String, boolean)",
          "exception": "throw new IllegalArgumentException(\"Null byte present in file/path name. There are no \" + \"known legitimate use cases for such data, but several injection attacks may use it\")",
          "pathCojunction": "(unixSeparator) && (!(filename == null)) && (0 < path.length()) && (filename.charAt(0) == 0)",
          "symbolicPathConjunction": "(unixSeparator) && ((!(filename == null)) && (!(failIfNullBytePresent(filename))))",
          "backwardsPathConjunction": "(unixSeparator) && (!(filename == null)) && (0 < path.length()) && (filename.charAt(0) == 0)",
          "simplifiedPathConjunction": "unixSeparator && filename.charAt(0) == 0 && path.length() > 0 && filename != null",
          "z3Program": "from z3 import *\nfrom z3_all_models import *\n\nfilename0 = String('filename0')\nunixSeparator0 = Bool('unixSeparator0')\npath0 = String('path0')\nfilename0_isNull = Bool('filename0_isNull')\n\nconstraints = [\n  UNIX_SEPARATOR0 == '/',\n  separator0 == UNIX_SEPARATOR0,\n  And(And(And(unixSeparator0, Not(filename0_isNull)), 0 < Length(path0)), filename0.charAt(0) == 0)\n]\n\nsolver = Solver()\nfor constraint in constraints:\n  solver.add(constraint)\n\nmodels = list(all_smt(solver))\nfor model in models: print(model)",
          "symPyProgram": "from sympy import Symbol\nfrom sympy import simplify\nfrom sympy.core.relational import Eq, Ne, StrictGreaterThan, StrictLessThan, LessThan, GreaterThan\nfrom sympy.printing import ccode\n\nfilename = Symbol('filename')\nunixSeparator = Symbol('unixSeparator')\npath = Symbol('path')\npath_length = Symbol('path_length')\nfilename_charAt = Symbol('filename_charAt')\nnull = Symbol('null')\npath_conjunction = (((unixSeparator & (~((Eq(filename, null))))) & (StrictLessThan(0, path_length))) & (Eq(filename_charAt, 0)))\nprint(ccode(simplify(path_conjunction)))",
          "soundSymbolic": true,
          "soundBackwards": false,
          "maybe": true,
          "line": 241,
          "throwingLine": 243,
          "isStatic": true,
          "targetOnlyArguments": false
        },
        {
          "qualifiedSignature": "org.apache.commons.io.FilenameUtils.normalize(java.lang.String, boolean)",
          "exception": "throw new IllegalArgumentException(\"Null byte present in file/path name. There are no \" + \"known legitimate use cases for such data, but several injection attacks may use it\")",
          "pathCojunction": "(!(unixSeparator)) && (!(filename == null)) && (0 < path.length()) && (filename.charAt(0) == 0)",
          "symbolicPathConjunction": "(!(unixSeparator)) && ((!(filename == null)) && (!(failIfNullBytePresent(filename))))",
          "backwardsPathConjunction": "(!(unixSeparator)) && (!(filename == null)) && (0 < path.length()) && (filename.charAt(0) == 0)",
          "simplifiedPathConjunction": "filename.charAt(0) == 0 && !unixSeparator && path.length() > 0 && filename != null",
          "z3Program": "from z3 import *\nfrom z3_all_models import *\n\nfilename0 = String('filename0')\nunixSeparator0 = Bool('unixSeparator0')\npath0 = String('path0')\nfilename0_isNull = Bool('filename0_isNull')\n\nconstraints = [\n  WINDOWS_SEPARATOR0 == '\\\\',\n  separator0 == WINDOWS_SEPARATOR0,\n  And(And(And(Not(unixSeparator0), Not(filename0_isNull)), 0 < Length(path0)), filename0.charAt(0) == 0)\n]\n\nsolver = Solver()\nfor constraint in constraints:\n  solver.add(constraint)\n\nmodels = list(all_smt(solver))\nfor model in models: print(model)",
          "symPyProgram": "from sympy import Symbol\nfrom sympy import simplify\nfrom sympy.core.relational import Eq, Ne, StrictGreaterThan, StrictLessThan, LessThan, GreaterThan\nfrom sympy.printing import ccode\n\nfilename = Symbol('filename')\nunixSeparator = Symbol('unixSeparator')\npath = Symbol('path')\npath_length = Symbol('path_length')\nfilename_charAt = Symbol('filename_charAt')\nnull = Symbol('null')\npath_conjunction = ((((~(unixSeparator)) & (~((Eq(filename, null))))) & (StrictLessThan(0, path_length))) & (Eq(filename_charAt, 0)))\nprint(ccode(simplify(path_conjunction)))",
          "soundSymbolic": true,
          "soundBackwards": false,
          "maybe": true,
          "line": 241,
          "throwingLine": 243,
          "isStatic": true,
          "targetOnlyArguments": false
        },
        {
          "qualifiedSignature": "org.apache.commons.io.FilenameUtils.normalizeNoEndSeparator(java.lang.String)",
          "exception": "throw new IllegalArgumentException(\"Null byte present in file/path name. There are no \" + \"known legitimate use cases for such data, but several injection attacks may use it\")",
          "pathCojunction": "(!(filename == null)) && (0 < path.length()) && (filename.charAt(0) == 0)",
          "symbolicPathConjunction": "((!(filename == null)) && (!(failIfNullBytePresent(filename))))",
          "backwardsPathConjunction": "(!(filename == null)) && (0 < path.length()) && (filename.charAt(0) == 0)",
          "simplifiedPathConjunction": "filename.charAt(0) == 0 && path.length() > 0 && filename != null",
          "z3Program": "from z3 import *\nfrom z3_all_models import *\n\nfilename0 = String('filename0')\npath0 = String('path0')\nfilename0_isNull = Bool('filename0_isNull')\n\nconstraints = [\n  SYSTEM_SEPARATOR0 == File.separatorChar,\n  And(And(Not(filename0_isNull), 0 < Length(path0)), filename0.charAt(0) == 0)\n]\n\nsolver = Solver()\nfor constraint in constraints:\n  solver.add(constraint)\n\nmodels = list(all_smt(solver))\nfor model in models: print(model)",
          "symPyProgram": "from sympy import Symbol\nfrom sympy import simplify\nfrom sympy.core.relational import Eq, Ne, StrictGreaterThan, StrictLessThan, LessThan, GreaterThan\nfrom sympy.printing import ccode\n\nfilename = Symbol('filename')\npath = Symbol('path')\npath_length = Symbol('path_length')\nfilename_charAt = Symbol('filename_charAt')\nnull = Symbol('null')\npath_conjunction = (((~((Eq(filename, null)))) & (StrictLessThan(0, path_length))) & (Eq(filename_charAt, 0)))\nprint(ccode(simplify(path_conjunction)))",
          "soundSymbolic": true,
          "soundBackwards": false,
          "maybe": true,
          "line": 288,
          "throwingLine": 289,
          "isStatic": true,
          "targetOnlyArguments": false
        },
        {
          "qualifiedSignature": "org.apache.commons.io.FilenameUtils.concat(java.lang.String, java.lang.String)",
          "exception": "throw new IllegalArgumentException(\"Null byte present in file/path name. There are no \" + \"known legitimate use cases for such data, but several injection attacks may use it\")",
          "pathCojunction": "(!(fullFilenameToAdd == null)) && (!(filename.length() == 0)) && (!(filename.charAt(0) == ':')) && (filename.length() == 1) && (filename.charAt(0) == '~') && (!(prefix < 0)) && (prefix > 0) && (!(fullFilenameToAdd == null)) && (0 < path.length()) && (fullFilenameToAdd.charAt(0) == 0)",
          "symbolicPathConjunction": "(getPrefixLength(fullFilenameToAdd)) && (!(prefix < 0)) && (prefix > 0) && (normalize(fullFilenameToAdd))",
          "backwardsPathConjunction": "(!(fullFilenameToAdd == null)) && (!(filename.length() == 0)) && (!(filename.charAt(0) == ':')) && (filename.length() == 1) && (filename.charAt(0) == '~') && (!(2 < 0)) && (2 > 0) && (!(fullFilenameToAdd == null)) && (0 < path.length()) && (fullFilenameToAdd.charAt(0) == 0)",
          "simplifiedPathConjunction": "filename.charAt(0) == '~' && filename.length() == 1 && fullFilenameToAdd.charAt(0) == 0 && path.length() > 0 && filename.charAt(0) != ':' && fullFilenameToAdd != null",
          "z3Program": "from z3 import *\nfrom z3_all_models import *\n\nbasePath0 = String('basePath0')\nfullFilenameToAdd0 = String('fullFilenameToAdd0')\nfilename0 = String('filename0')\nprefix0 = Int('prefix0')\npath0 = String('path0')\nfullFilenameToAdd0_isNull = Bool('fullFilenameToAdd0_isNull')\n\nconstraints = [\n  prefix0 == 2,\n  And(And(And(And(And(And(And(And(And(Not(fullFilenameToAdd0_isNull), Not(Length(filename0) == 0)), Not(filename0.charAt(0) == ':')), Length(filename0) == 1), filename0.charAt(0) == '~'), Not(prefix0 < 0)), prefix0 > 0), Not(fullFilenameToAdd0_isNull)), 0 < Length(path0)), fullFilenameToAdd0.charAt(0) == 0)\n]\n\nsolver = Solver()\nfor constraint in constraints:\n  solver.add(constraint)\n\nmodels = list(all_smt(solver))\nfor model in models: print(model)",
          "symPyProgram": "from sympy import Symbol\nfrom sympy import simplify\nfrom sympy.core.relational import Eq, Ne, StrictGreaterThan, StrictLessThan, LessThan, GreaterThan\nfrom sympy.printing import ccode\n\nfullFilenameToAdd = Symbol('fullFilenameToAdd')\nfilename = Symbol('filename')\npath = Symbol('path')\nfilename_length = Symbol('filename_length')\nfilename_charAt = Symbol('filename_charAt')\npath_length = Symbol('path_length')\nfullFilenameToAdd_charAt = Symbol('fullFilenameToAdd_charAt')\nnull = Symbol('null')\nwit_str_0 = Symbol('wit_str_0') # ':'\nwit_str_1 = Symbol('wit_str_1') # '~'\npath_conjunction = ((((((((((~((Eq(fullFilenameToAdd, null)))) & (~((Eq(filename_length, 0))))) & (~((Eq(filename_charAt, wit_str_0))))) & (Eq(filename_length, 1))) & (Eq(filename_charAt, wit_str_1))) & (~((StrictLessThan(2, 0))))) & (StrictGreaterThan(2, 0))) & (~((Eq(fullFilenameToAdd, null))))) & (StrictLessThan(0, path_length))) & (Eq(fullFilenameToAdd_charAt, 0)))\nprint(ccode(simplify(path_conjunction)))",
          "soundSymbolic": true,
          "soundBackwards": false,
          "maybe": true,
          "line": 485,
          "throwingLine": 491,
          "isStatic": true,
          "targetOnlyArguments": false
        },
        {
          "qualifiedSignature": "org.apache.commons.io.FilenameUtils.directoryContains(java.lang.String, java.lang.String)",
          "exception": "throw new IllegalArgumentException(\"Directory must not be null\");",
          "pathCojunction": "(canonicalParent == null)",
          "symbolicPathConjunction": "(canonicalParent == null)",
          "backwardsPathConjunction": "(canonicalParent == null)",
          "simplifiedPathConjunction": "canonicalParent == null",
          "z3Inputs": "[canonicalParent0_isNull = True]\n",
          "z3Program": "from z3 import *\nfrom z3_all_models import *\n\ncanonicalParent0 = String('canonicalParent0')\ncanonicalChild0 = String('canonicalChild0')\ncanonicalParent0_isNull = Bool('canonicalParent0_isNull')\n\nconstraints = [\n  canonicalParent0_isNull\n]\n\nsolver = Solver()\nfor constraint in constraints:\n  solver.add(constraint)\n\nmodels = list(all_smt(solver))\nfor model in models: print(model)",
          "symPyProgram": "from sympy import Symbol\nfrom sympy import simplify\nfrom sympy.core.relational import Eq, Ne, StrictGreaterThan, StrictLessThan, LessThan, GreaterThan\nfrom sympy.printing import ccode\n\ncanonicalParent = Symbol('canonicalParent')\nnull = Symbol('null')\npath_conjunction = (Eq(canonicalParent, null))\nprint(ccode(simplify(path_conjunction)))",
          "soundSymbolic": true,
          "soundBackwards": true,
          "maybe": false,
          "line": 532,
          "throwingLine": 536,
          "isStatic": true,
          "targetOnlyArguments": true
        },
        {
          "qualifiedSignature": "org.apache.commons.io.FilenameUtils.getPrefix(java.lang.String)",
          "exception": "throw new IllegalArgumentException(\"Null byte present in file/path name. There are no \" + \"known legitimate use cases for such data, but several injection attacks may use it\")",
          "pathCojunction": "(!(filename == null)) && (!(filename == null)) && (!(filename.length() == 0)) && (!(filename.charAt(0) == ':')) && (!(filename.length() == 1)) && (!(filename.charAt(0) == '~')) && (!(filename.charAt(1) == ':')) && (!(filename.charAt(0) == '/' || filename.charAt(0) == '\\\\' && filename.charAt(1) == '/' || filename.charAt(1) == '\\\\')) && (!(filename.charAt(0) == '/' || filename.charAt(0) == '\\\\')) && (!(len < 0)) && (len > filename.length()) && (0 < path.length()) && (filename + UNIX_SEPARATOR.charAt(0) == 0)",
          "symbolicPathConjunction": "(!(filename == null)) && (getPrefixLength(filename)) && (!(len < 0)) && (len > filename.length()) && ((0 < path.length()) && (path.charAt(0) == 0))",
          "backwardsPathConjunction": "(!(filename == null)) && (!(filename == null)) && (!(filename.length() == 0)) && (!(filename.charAt(0) == ':')) && (!(filename.length() == 1)) && (!(filename.charAt(0) == '~')) && (!(filename.charAt(1) == ':')) && (!(filename.charAt(0) == '/' || filename.charAt(0) == '\\\\' && filename.charAt(1) == '/' || filename.charAt(1) == '\\\\')) && (!(filename.charAt(0) == '/' || filename.charAt(0) == '\\\\')) && (!(0 < 0)) && (0 > filename.length()) && (0 < path.length()) && (filename + UNIX_SEPARATOR.charAt(0) == 0)",
          "simplifiedPathConjunction": "UNIX_SEPARATOR.charAt(0) == -filename && (filename.charAt(1) != wit_str_4 || filename.charAt(1) != wit_str_5) && path.length() > 0 && filename.length() < 0 && filename != null && filename.charAt(1) != wit_str_0 && filename.charAt(1) != '~' && filename.charAt(1) != ':' && filename.charAt(1) != wit_str_3 && filename.charAt(1) != wit_str_6 && filename.charAt(1) != '/' && filename.charAt(1) != '\\\\' && filename.length() != 1",
          "z3Program": "from z3 import *\nfrom z3_all_models import *\n\nfilename0 = String('filename0')\nlen0 = Int('len0')\npath0 = String('path0')\nfilename0_isNull = Bool('filename0_isNull')\n\nconstraints = [\n  len0 == 0,\n  And(And(And(And(And(And(And(And(And(And(And(And(Not(filename0_isNull), Not(filename0_isNull)), Not(Length(filename0) == 0)), Not(filename0.charAt(0) == ':')), Not(Length(filename0) == 1)), Not(filename0.charAt(0) == '~')), Not(filename0.charAt(1) == ':')), Not(Or(Or(filename0.charAt(0) == '/', And(filename0.charAt(0) == '\\\\', filename0.charAt(1) == '/')), filename0.charAt(1) == '\\\\'))), Not(Or(filename0.charAt(0) == '/', filename0.charAt(0) == '\\\\'))), Not(len0 < 0)), len0 > Length(filename0)), 0 < Length(path0)), filename0 + UNIX_SEPARATOR.charAt(0) == 0)\n]\n\nsolver = Solver()\nfor constraint in constraints:\n  solver.add(constraint)\n\nmodels = list(all_smt(solver))\nfor model in models: print(model)",
          "symPyProgram": "from sympy import Symbol\nfrom sympy import simplify\nfrom sympy.core.relational import Eq, Ne, StrictGreaterThan, StrictLessThan, LessThan, GreaterThan\nfrom sympy.printing import ccode\n\nfilename = Symbol('filename')\npath = Symbol('path')\nfilename_length = Symbol('filename_length')\nfilename_charAt = Symbol('filename_charAt')\npath_length = Symbol('path_length')\nUNIX_SEPARATOR_charAt = Symbol('UNIX_SEPARATOR_charAt')\nnull = Symbol('null')\nwit_str_0 = Symbol('wit_str_0') # ':'\nwit_str_1 = Symbol('wit_str_1') # '~'\nwit_str_2 = Symbol('wit_str_2') # ':'\nwit_str_3 = Symbol('wit_str_3') # '/'\nwit_str_4 = Symbol('wit_str_4') # '\\\\'\nwit_str_5 = Symbol('wit_str_5') # '/'\nwit_str_6 = Symbol('wit_str_6') # '\\\\'\nwit_str_7 = Symbol('wit_str_7') # '/'\nwit_str_8 = Symbol('wit_str_8') # '\\\\'\npath_conjunction = (((((((((((((~((Eq(filename, null)))) & (~((Eq(filename, null))))) & (~((Eq(filename_length, 0))))) & (~((Eq(filename_charAt, wit_str_0))))) & (~((Eq(filename_length, 1))))) & (~((Eq(filename_charAt, wit_str_1))))) & (~((Eq(filename_charAt, wit_str_2))))) & (~((((Eq(filename_charAt, wit_str_3)) | ((Eq(filename_charAt, wit_str_4)) & (Eq(filename_charAt, wit_str_5)))) | (Eq(filename_charAt, wit_str_6)))))) & (~(((Eq(filename_charAt, wit_str_7)) | (Eq(filename_charAt, wit_str_8)))))) & (~((StrictLessThan(0, 0))))) & (StrictGreaterThan(0, filename_length))) & (StrictLessThan(0, path_length))) & (Eq((filename + UNIX_SEPARATOR_charAt), 0)))\nprint(ccode(simplify(path_conjunction)))",
          "soundSymbolic": false,
          "soundBackwards": false,
          "maybe": true,
          "line": 763,
          "throwingLine": 772,
          "isStatic": true,
          "targetOnlyArguments": false
        },
        {
          "qualifiedSignature": "org.apache.commons.io.FilenameUtils.getPrefix(java.lang.String)",
          "exception": "throw new IllegalArgumentException(\"Null byte present in file/path name. There are no \" + \"known legitimate use cases for such data, but several injection attacks may use it\")",
          "pathCojunction": "(!(filename == null)) && (!(filename == null)) && (!(filename.length() == 0)) && (!(filename.charAt(0) == ':')) && (!(filename.length() == 1)) && (!(filename.charAt(0) == '~')) && (!(filename.charAt(1) == ':')) && (filename.charAt(0) == '/' || filename.charAt(0) == '\\\\' && filename.charAt(1) == '/' || filename.charAt(1) == '\\\\') && (filename.indexOf(UNIX_SEPARATOR, 2) == -1 && filename.indexOf(WINDOWS_SEPARATOR, 2) == -1 || filename.indexOf(UNIX_SEPARATOR, 2) == 2 || filename.indexOf(WINDOWS_SEPARATOR, 2) == 2) && (!(len < 0)) && (len > filename.length()) && (0 < path.length()) && (filename + UNIX_SEPARATOR.charAt(0) == 0)",
          "symbolicPathConjunction": "(!(filename == null)) && (getPrefixLength(filename)) && (!(len < 0)) && (len > filename.length()) && ((0 < path.length()) && (path.charAt(0) == 0))",
          "backwardsPathConjunction": "(!(filename == null)) && (!(filename == null)) && (!(filename.length() == 0)) && (!(filename.charAt(0) == ':')) && (!(filename.length() == 1)) && (!(filename.charAt(0) == '~')) && (!(filename.charAt(1) == ':')) && (filename.charAt(0) == '/' || filename.charAt(0) == '\\\\' && filename.charAt(1) == '/' || filename.charAt(1) == '\\\\') && (filename.indexOf(UNIX_SEPARATOR, 2) == -1 && filename.indexOf(WINDOWS_SEPARATOR, 2) == -1 || filename.indexOf(UNIX_SEPARATOR, 2) == 2 || filename.indexOf(WINDOWS_SEPARATOR, 2) == 2) && (!(NOT_FOUND < 0)) && (NOT_FOUND > filename.length()) && (0 < path.length()) && (filename + UNIX_SEPARATOR.charAt(0) == 0)",
          "z3Program": "from z3 import *\nfrom z3_all_models import *\n\nfilename0 = String('filename0')\nNOT_FOUND0 = Int('NOT_FOUND0')\nlen0 = Int('len0')\npath0 = String('path0')\nfilename0_isNull = Bool('filename0_isNull')\n\nconstraints = [\n  WINDOWS_SEPARATOR0 == '\\\\',\n  NOT_FOUND0 == -1,\n  UNIX_SEPARATOR0 == '/',\n  len0 == NOT_FOUND0,\n  And(And(And(And(And(And(And(And(And(And(And(And(Not(filename0_isNull), Not(filename0_isNull)), Not(Length(filename0) == 0)), Not(filename0.charAt(0) == ':')), Not(Length(filename0) == 1)), Not(filename0.charAt(0) == '~')), Not(filename0.charAt(1) == ':')), Or(Or(filename0.charAt(0) == '/', And(filename0.charAt(0) == '\\\\', filename0.charAt(1) == '/')), filename0.charAt(1) == '\\\\')), Or(Or(And(filename0.indexOf(UNIX_SEPARATOR0, 2) == -1, filename0.indexOf(WINDOWS_SEPARATOR0, 2) == -1), filename0.indexOf(UNIX_SEPARATOR0, 2) == 2), filename0.indexOf(WINDOWS_SEPARATOR0, 2) == 2)), Not(len0 < 0)), len0 > Length(filename0)), 0 < Length(path0)), filename0 + UNIX_SEPARATOR0.charAt(0) == 0)\n]\n\nsolver = Solver()\nfor constraint in constraints:\n  solver.add(constraint)\n\nmodels = list(all_smt(solver))\nfor model in models: print(model)",
          "symPyProgram": "from sympy import Symbol\nfrom sympy import simplify\nfrom sympy.core.relational import Eq, Ne, StrictGreaterThan, StrictLessThan, LessThan, GreaterThan\nfrom sympy.printing import ccode\n\nfilename = Symbol('filename')\npath = Symbol('path')\nfilename_length = Symbol('filename_length')\nfilename_charAt = Symbol('filename_charAt')\nfilename_indexOf = Symbol('filename_indexOf')\npath_length = Symbol('path_length')\n'/'_charAt = Symbol(''/'_charAt')\nnull = Symbol('null')\nwit_str_0 = Symbol('wit_str_0') # ':'\nwit_str_1 = Symbol('wit_str_1') # '~'\nwit_str_2 = Symbol('wit_str_2') # ':'\nwit_str_3 = Symbol('wit_str_3') # '/'\nwit_str_4 = Symbol('wit_str_4') # '\\\\'\nwit_str_5 = Symbol('wit_str_5') # '/'\nwit_str_6 = Symbol('wit_str_6') # '\\\\'\npath_conjunction = (((((((((((((~((Eq(filename, null)))) & (~((Eq(filename, null))))) & (~((Eq(filename_length, 0))))) & (~((Eq(filename_charAt, wit_str_0))))) & (~((Eq(filename_length, 1))))) & (~((Eq(filename_charAt, wit_str_1))))) & (~((Eq(filename_charAt, wit_str_2))))) & (((Eq(filename_charAt, wit_str_3)) | ((Eq(filename_charAt, wit_str_4)) & (Eq(filename_charAt, wit_str_5)))) | (Eq(filename_charAt, wit_str_6)))) & ((((Eq(filename_indexOf, -1)) & (Eq(filename_indexOf, -1))) | (Eq(filename_indexOf, 2))) | (Eq(filename_indexOf, 2)))) & (~((StrictLessThan(NOT_FOUND, 0))))) & (StrictGreaterThan(NOT_FOUND, filename_length))) & (StrictLessThan(0, path_length))) & (Eq((filename + '/'_charAt), 0)))\nprint(ccode(simplify(path_conjunction)))",
          "soundSymbolic": false,
          "soundBackwards": false,
          "maybe": true,
          "line": 763,
          "throwingLine": 772,
          "isStatic": true,
          "targetOnlyArguments": false
        },
        {
          "qualifiedSignature": "org.apache.commons.io.FilenameUtils.getPrefix(java.lang.String)",
          "exception": "throw new IllegalArgumentException(\"Null byte present in file/path name. There are no \" + \"known legitimate use cases for such data, but several injection attacks may use it\");",
          "pathCojunction": "(!(filename == null)) && (!(filename == null)) && (!(filename.length() == 0)) && (!(Character.toUpperCase(ch0) == ':')) && (!(filename.length() == 1)) && (!(Character.toUpperCase(ch0) == '~')) && (filename.charAt(1) == ':') && (!(Character.toUpperCase(ch0) >= 'A' && Character.toUpperCase(ch0) <= 'Z')) && (!(Character.toUpperCase(ch0) == '/')) && (!(len < 0)) && (!(len > filename.length())) && (0 < path.length()) && (path.charAt(0) == 0)",
          "symbolicPathConjunction": "(!(filename == null)) && (getPrefixLength(filename)) && (!(len < 0)) && (!(len > filename.length())) && ((0 < path.length()) && (path.charAt(0) == 0))",
          "backwardsPathConjunction": "(!(filename == null)) && (!(filename == null)) && (!(filename.length() == 0)) && (!(Character.toUpperCase(Character.toUpperCase(Character.toUpperCase(ch0))) == ':')) && (!(filename.length() == 1)) && (!(Character.toUpperCase(Character.toUpperCase(Character.toUpperCase(ch0))) == '~')) && (filename.charAt(1) == ':') && (!(Character.toUpperCase(Character.toUpperCase(Character.toUpperCase(ch0))) >= 'A' && Character.toUpperCase(Character.toUpperCase(Character.toUpperCase(ch0))) <= 'Z')) && (!(Character.toUpperCase(Character.toUpperCase(Character.toUpperCase(ch0))) == '/')) && (!(NOT_FOUND < 0)) && (!(NOT_FOUND > filename.length())) && (0 < filename.substring(0, NOT_FOUND).length()) && (filename.substring(0, NOT_FOUND).charAt(0) == 0)",
          "z3Program": "from z3 import *\nfrom z3_all_models import *\n\nfilename0 = String('filename0')\nNOT_FOUND0 = Int('NOT_FOUND0')\nlen0 = Int('len0')\npath0 = String('path0')\nfilename0_isNull = Bool('filename0_isNull')\n\nconstraints = [\n  NOT_FOUND0 == -1,\n  ch00 == Character.toUpperCase(ch0),\n  len0 == NOT_FOUND0,\n  path0 == filename0.substring(0, len0),\n  And(And(And(And(And(And(And(And(And(And(And(And(Not(filename0_isNull), Not(filename0_isNull)), Not(Length(filename0) == 0)), Not(Character.toUpperCase(ch00) == ':')), Not(Length(filename0) == 1)), Not(Character.toUpperCase(ch00) == '~')), filename0.charAt(1) == ':'), Not(And(Character.toUpperCase(ch00) >= 'A', Character.toUpperCase(ch00) <= 'Z'))), Not(Character.toUpperCase(ch00) == '/')), Not(len0 < 0)), Not(len0 > Length(filename0))), 0 < Length(path0)), path0.charAt(0) == 0)\n]\n\nsolver = Solver()\nfor constraint in constraints:\n  solver.add(constraint)\n\nmodels = list(all_smt(solver))\nfor model in models: print(model)",
          "symPyProgram": "from sympy import Symbol\nfrom sympy import simplify\nfrom sympy.core.relational import Eq, Ne, StrictGreaterThan, StrictLessThan, LessThan, GreaterThan\nfrom sympy.printing import ccode\n\nfilename = Symbol('filename')\nfilename_length = Symbol('filename_length')\nCharacter_toUpperCase = Symbol('Character_toUpperCase')\nfilename_charAt = Symbol('filename_charAt')\nfilename_substring_length = Symbol('filename_substring_length')\nfilename_substring = Symbol('filename_substring')\nfilename_substring_charAt = Symbol('filename_substring_charAt')\nnull = Symbol('null')\nwit_str_0 = Symbol('wit_str_0') # ':'\nwit_str_1 = Symbol('wit_str_1') # '~'\nwit_str_2 = Symbol('wit_str_2') # ':'\nwit_str_3 = Symbol('wit_str_3') # 'A'\nwit_str_4 = Symbol('wit_str_4') # 'Z'\nwit_str_5 = Symbol('wit_str_5') # '/'\npath_conjunction = (((((((((((((~((Eq(filename, null)))) & (~((Eq(filename, null))))) & (~((Eq(filename_length, 0))))) & (~((Eq(Character_toUpperCase, wit_str_0))))) & (~((Eq(filename_length, 1))))) & (~((Eq(Character_toUpperCase, wit_str_1))))) & (Eq(filename_charAt, wit_str_2))) & (~(((GreaterThan(Character_toUpperCase, wit_str_3)) & (LessThan(Character_toUpperCase, wit_str_4)))))) & (~((Eq(Character_toUpperCase, wit_str_5))))) & (~((StrictLessThan(NOT_FOUND, 0))))) & (~((StrictGreaterThan(NOT_FOUND, filename_length))))) & (StrictLessThan(0, filename_substring_length))) & (Eq(filename_substring_charAt, 0)))\nprint(ccode(simplify(path_conjunction)))",
          "soundSymbolic": false,
          "soundBackwards": false,
          "maybe": true,
          "line": 763,
          "throwingLine": 776,
          "isStatic": true,
          "targetOnlyArguments": false
        },
        {
          "qualifiedSignature": "org.apache.commons.io.FilenameUtils.getPrefix(java.lang.String)",
          "exception": "throw new IllegalArgumentException(\"Null byte present in file/path name. There are no \" + \"known legitimate use cases for such data, but several injection attacks may use it\")",
          "pathCojunction": "(!(filename == null)) && (!(filename == null)) && (!(filename.length() == 0)) && (!(Character.toUpperCase(ch0) == ':')) && (!(filename.length() == 1)) && (!(Character.toUpperCase(ch0) == '~')) && (filename.charAt(1) == ':') && (!(Character.toUpperCase(ch0) >= 'A' && Character.toUpperCase(ch0) <= 'Z')) && (!(Character.toUpperCase(ch0) == '/')) && (!(len < 0)) && (len > filename.length()) && (0 < path.length()) && (filename + UNIX_SEPARATOR.charAt(0) == 0)",
          "symbolicPathConjunction": "(!(filename == null)) && (getPrefixLength(filename)) && (!(len < 0)) && (len > filename.length()) && ((0 < path.length()) && (path.charAt(0) == 0))",
          "backwardsPathConjunction": "(!(filename == null)) && (!(filename == null)) && (!(filename.length() == 0)) && (!(Character.toUpperCase(Character.toUpperCase(Character.toUpperCase(ch0))) == ':')) && (!(filename.length() == 1)) && (!(Character.toUpperCase(Character.toUpperCase(Character.toUpperCase(ch0))) == '~')) && (filename.charAt(1) == ':') && (!(Character.toUpperCase(Character.toUpperCase(Character.toUpperCase(ch0))) >= 'A' && Character.toUpperCase(Character.toUpperCase(Character.toUpperCase(ch0))) <= 'Z')) && (!(Character.toUpperCase(Character.toUpperCase(Character.toUpperCase(ch0))) == '/')) && (!(NOT_FOUND < 0)) && (NOT_FOUND > filename.length()) && (0 < path.length()) && (filename + UNIX_SEPARATOR.charAt(0) == 0)",
          "z3Program": "from z3 import *\nfrom z3_all_models import *\n\nfilename0 = String('filename0')\nNOT_FOUND0 = Int('NOT_FOUND0')\nlen0 = Int('len0')\npath0 = String('path0')\nfilename0_isNull = Bool('filename0_isNull')\n\nconstraints = [\n  NOT_FOUND0 == -1,\n  ch00 == Character.toUpperCase(ch0),\n  len0 == NOT_FOUND0,\n  And(And(And(And(And(And(And(And(And(And(And(And(Not(filename0_isNull), Not(filename0_isNull)), Not(Length(filename0) == 0)), Not(Character.toUpperCase(ch00) == ':')), Not(Length(filename0) == 1)), Not(Character.toUpperCase(ch00) == '~')), filename0.charAt(1) == ':'), Not(And(Character.toUpperCase(ch00) >= 'A', Character.toUpperCase(ch00) <= 'Z'))), Not(Character.toUpperCase(ch00) == '/')), Not(len0 < 0)), len0 > Length(filename0)), 0 < Length(path0)), filename0 + UNIX_SEPARATOR.charAt(0) == 0)\n]\n\nsolver = Solver()\nfor constraint in constraints:\n  solver.add(constraint)\n\nmodels = list(all_smt(solver))\nfor model in models: print(model)",
          "symPyProgram": "from sympy import Symbol\nfrom sympy import simplify\nfrom sympy.core.relational import Eq, Ne, StrictGreaterThan, StrictLessThan, LessThan, GreaterThan\nfrom sympy.printing import ccode\n\nfilename = Symbol('filename')\npath = Symbol('path')\nfilename_length = Symbol('filename_length')\nCharacter_toUpperCase = Symbol('Character_toUpperCase')\nfilename_charAt = Symbol('filename_charAt')\npath_length = Symbol('path_length')\nUNIX_SEPARATOR_charAt = Symbol('UNIX_SEPARATOR_charAt')\nnull = Symbol('null')\nwit_str_0 = Symbol('wit_str_0') # ':'\nwit_str_1 = Symbol('wit_str_1') # '~'\nwit_str_2 = Symbol('wit_str_2') # ':'\nwit_str_3 = Symbol('wit_str_3') # 'A'\nwit_str_4 = Symbol('wit_str_4') # 'Z'\nwit_str_5 = Symbol('wit_str_5') # '/'\npath_conjunction = (((((((((((((~((Eq(filename, null)))) & (~((Eq(filename, null))))) & (~((Eq(filename_length, 0))))) & (~((Eq(Character_toUpperCase, wit_str_0))))) & (~((Eq(filename_length, 1))))) & (~((Eq(Character_toUpperCase, wit_str_1))))) & (Eq(filename_charAt, wit_str_2))) & (~(((GreaterThan(Character_toUpperCase, wit_str_3)) & (LessThan(Character_toUpperCase, wit_str_4)))))) & (~((Eq(Character_toUpperCase, wit_str_5))))) & (~((StrictLessThan(NOT_FOUND, 0))))) & (StrictGreaterThan(NOT_FOUND, filename_length))) & (StrictLessThan(0, path_length))) & (Eq((filename + UNIX_SEPARATOR_charAt), 0)))\nprint(ccode(simplify(path_conjunction)))",
          "soundSymbolic": false,
          "soundBackwards": false,
          "maybe": true,
          "line": 763,
          "throwingLine": 772,
          "isStatic": true,
          "targetOnlyArguments": false
        },
        {
          "qualifiedSignature": "org.apache.commons.io.FilenameUtils.getPrefix(java.lang.String)",
          "exception": "throw new IllegalArgumentException(\"Null byte present in file/path name. There are no \" + \"known legitimate use cases for such data, but several injection attacks may use it\")",
          "pathCojunction": "(!(filename == null)) && (!(filename == null)) && (!(filename.length() == 0)) && (!(filename.charAt(0) == ':')) && (!(filename.length() == 1)) && (filename.charAt(0) == '~') && (filename.indexOf(UNIX_SEPARATOR, 1) == -1 && filename.indexOf(WINDOWS_SEPARATOR, 1) == -1) && (!(len < 0)) && (len > filename.length()) && (0 < path.length()) && (filename + UNIX_SEPARATOR.charAt(0) == 0)",
          "symbolicPathConjunction": "(!(filename == null)) && (getPrefixLength(filename)) && (!(len < 0)) && (len > filename.length()) && ((0 < path.length()) && (path.charAt(0) == 0))",
          "backwardsPathConjunction": "(!(filename == null)) && (!(filename == null)) && (!(filename.length() == 0)) && (!(filename.charAt(0) == ':')) && (!(filename.length() == 1)) && (filename.charAt(0) == '~') && (filename.indexOf(UNIX_SEPARATOR, 1) == -1 && filename.indexOf(WINDOWS_SEPARATOR, 1) == -1) && (!(filename.length() + 1 < 0)) && (filename.length() + 1 > filename.length()) && (0 < path.length()) && (filename + UNIX_SEPARATOR.charAt(0) == 0)",
          "z3Program": "from z3 import *\nfrom z3_all_models import *\n\nfilename0 = String('filename0')\nlen0 = Int('len0')\npath0 = String('path0')\nfilename0_isNull = Bool('filename0_isNull')\n\nconstraints = [\n  WINDOWS_SEPARATOR0 == '\\\\',\n  UNIX_SEPARATOR0 == '/',\n  len0 == Length(filename0) + 1,\n  And(And(And(And(And(And(And(And(And(And(Not(filename0_isNull), Not(filename0_isNull)), Not(Length(filename0) == 0)), Not(filename0.charAt(0) == ':')), Not(Length(filename0) == 1)), filename0.charAt(0) == '~'), And(filename0.indexOf(UNIX_SEPARATOR0, 1) == -1, filename0.indexOf(WINDOWS_SEPARATOR0, 1) == -1)), Not(len0 < 0)), len0 > Length(filename0)), 0 < Length(path0)), filename0 + UNIX_SEPARATOR0.charAt(0) == 0)\n]\n\nsolver = Solver()\nfor constraint in constraints:\n  solver.add(constraint)\n\nmodels = list(all_smt(solver))\nfor model in models: print(model)",
          "symPyProgram": "from sympy import Symbol\nfrom sympy import simplify\nfrom sympy.core.relational import Eq, Ne, StrictGreaterThan, StrictLessThan, LessThan, GreaterThan\nfrom sympy.printing import ccode\n\nfilename = Symbol('filename')\npath = Symbol('path')\nfilename_length = Symbol('filename_length')\nfilename_charAt = Symbol('filename_charAt')\nfilename_indexOf = Symbol('filename_indexOf')\npath_length = Symbol('path_length')\n'/'_charAt = Symbol(''/'_charAt')\nnull = Symbol('null')\nwit_str_0 = Symbol('wit_str_0') # ':'\nwit_str_1 = Symbol('wit_str_1') # '~'\npath_conjunction = (((((((((((~((Eq(filename, null)))) & (~((Eq(filename, null))))) & (~((Eq(filename_length, 0))))) & (~((Eq(filename_charAt, wit_str_0))))) & (~((Eq(filename_length, 1))))) & (Eq(filename_charAt, wit_str_1))) & ((Eq(filename_indexOf, -1)) & (Eq(filename_indexOf, -1)))) & (~((StrictLessThan((filename_length + 1), 0))))) & (StrictGreaterThan((filename_length + 1), filename_length))) & (StrictLessThan(0, path_length))) & (Eq((filename + '/'_charAt), 0)))\nprint(ccode(simplify(path_conjunction)))",
          "soundSymbolic": false,
          "soundBackwards": false,
          "maybe": true,
          "line": 763,
          "throwingLine": 772,
          "isStatic": true,
          "targetOnlyArguments": false
        },
        {
          "qualifiedSignature": "org.apache.commons.io.FilenameUtils.getPrefix(java.lang.String)",
          "exception": "throw new IllegalArgumentException(\"Null byte present in file/path name. There are no \" + \"known legitimate use cases for such data, but several injection attacks may use it\");",
          "pathCojunction": "(!(filename == null)) && (!(filename == null)) && (!(filename.length() == 0)) && (!(Character.toUpperCase(ch0) == ':')) && (!(filename.length() == 1)) && (!(Character.toUpperCase(ch0) == '~')) && (filename.charAt(1) == ':') && (Character.toUpperCase(ch0) >= 'A' && Character.toUpperCase(ch0) <= 'Z') && (filename.length() == 2 || filename.charAt(2) == '/' || filename.charAt(2) == '\\\\' == false) && (!(len < 0)) && (!(len > filename.length())) && (0 < path.length()) && (path.charAt(0) == 0)",
          "symbolicPathConjunction": "(!(filename == null)) && (getPrefixLength(filename)) && (!(len < 0)) && (!(len > filename.length())) && ((0 < path.length()) && (path.charAt(0) == 0))",
          "backwardsPathConjunction": "(!(filename == null)) && (!(filename == null)) && (!(filename.length() == 0)) && (!(Character.toUpperCase(Character.toUpperCase(Character.toUpperCase(ch0))) == ':')) && (!(filename.length() == 1)) && (!(Character.toUpperCase(Character.toUpperCase(Character.toUpperCase(ch0))) == '~')) && (filename.charAt(1) == ':') && (Character.toUpperCase(Character.toUpperCase(Character.toUpperCase(ch0))) >= 'A' && Character.toUpperCase(Character.toUpperCase(Character.toUpperCase(ch0))) <= 'Z') && (filename.length() == 2 || filename.charAt(2) == '/' || filename.charAt(2) == '\\\\' == false) && (!(2 < 0)) && (!(2 > filename.length())) && (0 < filename.substring(0, 2).length()) && (filename.substring(0, 2).charAt(0) == 0)",
          "simplifiedPathConjunction": "filename.charAt(2) == ':' && filename.substring(0, 2).charAt(0) == 0 && Character.toUpperCase(Character.toUpperCase(Character.toUpperCase(ch0))) >= 'A' && filename.length() >= 2 && Character.toUpperCase(Character.toUpperCase(Character.toUpperCase(ch0))) <= 'Z' && (filename.charAt(2) == '/' || filename.length() == 2 || filename.charAt(2) != '\\\\') && filename.substring(0, 2)_length > 0 && Character.toUpperCase(Character.toUpperCase(Character.toUpperCase(ch0))) != wit_str_0 && Character.toUpperCase(Character.toUpperCase(Character.toUpperCase(ch0))) != '~' && filename != null && filename.length() != 0 && filename.length() != 1",
          "z3Program": "from z3 import *\nfrom z3_all_models import *\n\nfilename0 = String('filename0')\nlen0 = Int('len0')\npath0 = String('path0')\nfilename0_isNull = Bool('filename0_isNull')\n\nconstraints = [\n  ch00 == Character.toUpperCase(ch0),\n  len0 == 2,\n  path0 == filename0.substring(0, len0),\n  And(And(And(And(And(And(And(And(And(And(And(And(Not(filename0_isNull), Not(filename0_isNull)), Not(Length(filename0) == 0)), Not(Character.toUpperCase(ch00) == ':')), Not(Length(filename0) == 1)), Not(Character.toUpperCase(ch00) == '~')), filename0.charAt(1) == ':'), And(Character.toUpperCase(ch00) >= 'A', Character.toUpperCase(ch00) <= 'Z')), Or(Or(Length(filename0) == 2, filename0.charAt(2) == '/'), filename0.charAt(2) == '\\\\' == False)), Not(len0 < 0)), Not(len0 > Length(filename0))), 0 < Length(path0)), path0.charAt(0) == 0)\n]\n\nsolver = Solver()\nfor constraint in constraints:\n  solver.add(constraint)\n\nmodels = list(all_smt(solver))\nfor model in models: print(model)",
          "symPyProgram": "from sympy import Symbol\nfrom sympy import simplify\nfrom sympy.core.relational import Eq, Ne, StrictGreaterThan, StrictLessThan, LessThan, GreaterThan\nfrom sympy.printing import ccode\n\nfilename = Symbol('filename')\nfilename_length = Symbol('filename_length')\nCharacter_toUpperCase = Symbol('Character_toUpperCase')\nfilename_charAt = Symbol('filename_charAt')\nfilename_substring_length = Symbol('filename_substring_length')\nfilename_substring = Symbol('filename_substring')\nfilename_substring_charAt = Symbol('filename_substring_charAt')\nnull = Symbol('null')\nwit_str_0 = Symbol('wit_str_0') # ':'\nwit_str_1 = Symbol('wit_str_1') # '~'\nwit_str_2 = Symbol('wit_str_2') # ':'\nwit_str_3 = Symbol('wit_str_3') # 'A'\nwit_str_4 = Symbol('wit_str_4') # 'Z'\nwit_str_5 = Symbol('wit_str_5') # '/'\nwit_str_6 = Symbol('wit_str_6') # '\\\\'\npath_conjunction = (((((((((((((~((Eq(filename, null)))) & (~((Eq(filename, null))))) & (~((Eq(filename_length, 0))))) & (~((Eq(Character_toUpperCase, wit_str_0))))) & (~((Eq(filename_length, 1))))) & (~((Eq(Character_toUpperCase, wit_str_1))))) & (Eq(filename_charAt, wit_str_2))) & ((GreaterThan(Character_toUpperCase, wit_str_3)) & (LessThan(Character_toUpperCase, wit_str_4)))) & (((Eq(filename_length, 2)) | (Eq(filename_charAt, wit_str_5))) | (~((Eq(filename_charAt, wit_str_6)))))) & (~((StrictLessThan(2, 0))))) & (~((StrictGreaterThan(2, filename_length))))) & (StrictLessThan(0, filename_substring_length))) & (Eq(filename_substring_charAt, 0)))\nprint(ccode(simplify(path_conjunction)))",
          "soundSymbolic": false,
          "soundBackwards": false,
          "maybe": true,
          "line": 763,
          "throwingLine": 776,
          "isStatic": true,
          "targetOnlyArguments": false
        },
        {
          "qualifiedSignature": "org.apache.commons.io.FilenameUtils.getPrefix(java.lang.String)",
          "exception": "throw new IllegalArgumentException(\"Null byte present in file/path name. There are no \" + \"known legitimate use cases for such data, but several injection attacks may use it\")",
          "pathCojunction": "(!(filename == null)) && (!(filename == null)) && (!(filename.length() == 0)) && (!(Character.toUpperCase(ch0) == ':')) && (!(filename.length() == 1)) && (!(Character.toUpperCase(ch0) == '~')) && (filename.charAt(1) == ':') && (Character.toUpperCase(ch0) >= 'A' && Character.toUpperCase(ch0) <= 'Z') && (!(filename.length() == 2 || filename.charAt(2) == '/' || filename.charAt(2) == '\\\\' == false)) && (!(len < 0)) && (len > filename.length()) && (0 < path.length()) && (filename + UNIX_SEPARATOR.charAt(0) == 0)",
          "symbolicPathConjunction": "(!(filename == null)) && (getPrefixLength(filename)) && (!(len < 0)) && (len > filename.length()) && ((0 < path.length()) && (path.charAt(0) == 0))",
          "backwardsPathConjunction": "(!(filename == null)) && (!(filename == null)) && (!(filename.length() == 0)) && (!(Character.toUpperCase(Character.toUpperCase(Character.toUpperCase(ch0))) == ':')) && (!(filename.length() == 1)) && (!(Character.toUpperCase(Character.toUpperCase(Character.toUpperCase(ch0))) == '~')) && (filename.charAt(1) == ':') && (Character.toUpperCase(Character.toUpperCase(Character.toUpperCase(ch0))) >= 'A' && Character.toUpperCase(Character.toUpperCase(Character.toUpperCase(ch0))) <= 'Z') && (!(filename.length() == 2 || filename.charAt(2) == '/' || filename.charAt(2) == '\\\\' == false)) && (!(3 < 0)) && (3 > filename.length()) && (0 < path.length()) && (filename + UNIX_SEPARATOR.charAt(0) == 0)",
          "simplifiedPathConjunction": "UNIX_SEPARATOR.charAt(0) == -filename && filename.charAt(2) == ':' && filename.charAt(2) == '\\\\' && Character.toUpperCase(Character.toUpperCase(Character.toUpperCase(ch0))) >= 'A' && Character.toUpperCase(Character.toUpperCase(Character.toUpperCase(ch0))) <= 'Z' && path.length() > 0 && filename.length() < 3 && Character.toUpperCase(Character.toUpperCase(Character.toUpperCase(ch0))) != wit_str_0 && Character.toUpperCase(Character.toUpperCase(Character.toUpperCase(ch0))) != '~' && filename != null && filename.charAt(2) != '/' && filename.length() != 0 && filename.length() != 1 && filename.length() != 2",
          "z3Program": "from z3 import *\nfrom z3_all_models import *\n\nfilename0 = String('filename0')\nlen0 = Int('len0')\npath0 = String('path0')\nfilename0_isNull = Bool('filename0_isNull')\n\nconstraints = [\n  ch00 == Character.toUpperCase(ch0),\n  len0 == 3,\n  And(And(And(And(And(And(And(And(And(And(And(And(Not(filename0_isNull), Not(filename0_isNull)), Not(Length(filename0) == 0)), Not(Character.toUpperCase(ch00) == ':')), Not(Length(filename0) == 1)), Not(Character.toUpperCase(ch00) == '~')), filename0.charAt(1) == ':'), And(Character.toUpperCase(ch00) >= 'A', Character.toUpperCase(ch00) <= 'Z')), Not(Or(Or(Length(filename0) == 2, filename0.charAt(2) == '/'), filename0.charAt(2) == '\\\\' == False))), Not(len0 < 0)), len0 > Length(filename0)), 0 < Length(path0)), filename0 + UNIX_SEPARATOR.charAt(0) == 0)\n]\n\nsolver = Solver()\nfor constraint in constraints:\n  solver.add(constraint)\n\nmodels = list(all_smt(solver))\nfor model in models: print(model)",
          "symPyProgram": "from sympy import Symbol\nfrom sympy import simplify\nfrom sympy.core.relational import Eq, Ne, StrictGreaterThan, StrictLessThan, LessThan, GreaterThan\nfrom sympy.printing import ccode\n\nfilename = Symbol('filename')\npath = Symbol('path')\nfilename_length = Symbol('filename_length')\nCharacter_toUpperCase = Symbol('Character_toUpperCase')\nfilename_charAt = Symbol('filename_charAt')\npath_length = Symbol('path_length')\nUNIX_SEPARATOR_charAt = Symbol('UNIX_SEPARATOR_charAt')\nnull = Symbol('null')\nwit_str_0 = Symbol('wit_str_0') # ':'\nwit_str_1 = Symbol('wit_str_1') # '~'\nwit_str_2 = Symbol('wit_str_2') # ':'\nwit_str_3 = Symbol('wit_str_3') # 'A'\nwit_str_4 = Symbol('wit_str_4') # 'Z'\nwit_str_5 = Symbol('wit_str_5') # '/'\nwit_str_6 = Symbol('wit_str_6') # '\\\\'\npath_conjunction = (((((((((((((~((Eq(filename, null)))) & (~((Eq(filename, null))))) & (~((Eq(filename_length, 0))))) & (~((Eq(Character_toUpperCase, wit_str_0))))) & (~((Eq(filename_length, 1))))) & (~((Eq(Character_toUpperCase, wit_str_1))))) & (Eq(filename_charAt, wit_str_2))) & ((GreaterThan(Character_toUpperCase, wit_str_3)) & (LessThan(Character_toUpperCase, wit_str_4)))) & (~((((Eq(filename_length, 2)) | (Eq(filename_charAt, wit_str_5))) | (~((Eq(filename_charAt, wit_str_6)))))))) & (~((StrictLessThan(3, 0))))) & (StrictGreaterThan(3, filename_length))) & (StrictLessThan(0, path_length))) & (Eq((filename + UNIX_SEPARATOR_charAt), 0)))\nprint(ccode(simplify(path_conjunction)))",
          "soundSymbolic": false,
          "soundBackwards": false,
          "maybe": true,
          "line": 763,
          "throwingLine": 772,
          "isStatic": true,
          "targetOnlyArguments": false
        },
        {
          "qualifiedSignature": "org.apache.commons.io.FilenameUtils.getPrefix(java.lang.String)",
          "exception": "throw new IllegalArgumentException(\"Null byte present in file/path name. There are no \" + \"known legitimate use cases for such data, but several injection attacks may use it\");",
          "pathCojunction": "(!(filename == null)) && (!(filename == null)) && (!(filename.length() == 0)) && (!(filename.charAt(0) == ':')) && (!(filename.length() == 1)) && (!(filename.charAt(0) == '~')) && (!(filename.charAt(1) == ':')) && (!(filename.charAt(0) == '/' || filename.charAt(0) == '\\\\' && filename.charAt(1) == '/' || filename.charAt(1) == '\\\\')) && (filename.charAt(0) == '/' || filename.charAt(0) == '\\\\') && (!(len < 0)) && (!(len > filename.length())) && (0 < path.length()) && (path.charAt(0) == 0)",
          "symbolicPathConjunction": "(!(filename == null)) && (getPrefixLength(filename)) && (!(len < 0)) && (!(len > filename.length())) && ((0 < path.length()) && (path.charAt(0) == 0))",
          "backwardsPathConjunction": "(!(filename == null)) && (!(filename == null)) && (!(filename.length() == 0)) && (!(filename.charAt(0) == ':')) && (!(filename.length() == 1)) && (!(filename.charAt(0) == '~')) && (!(filename.charAt(1) == ':')) && (!(filename.charAt(0) == '/' || filename.charAt(0) == '\\\\' && filename.charAt(1) == '/' || filename.charAt(1) == '\\\\')) && (filename.charAt(0) == '/' || filename.charAt(0) == '\\\\') && (!(1 < 0)) && (!(1 > filename.length())) && (0 < filename.substring(0, 1).length()) && (filename.substring(0, 1).charAt(0) == 0)",
          "simplifiedPathConjunction": "filename.substring(0, 1).charAt(0) == 0 && (filename.charAt(1) == '/' || filename.charAt(1) == '\\\\') && (filename.charAt(1) != wit_str_4 || filename.charAt(1) != wit_str_5) && filename.length() > 1 && filename.substring(0, 1).length() > 0 && filename != null && filename.charAt(1) != wit_str_0 && filename.charAt(1) != '~' && filename.charAt(1) != ':' && filename.charAt(1) != wit_str_3 && filename.charAt(1) != wit_str_6 && filename.length() != 0",
          "z3Program": "from z3 import *\nfrom z3_all_models import *\n\nfilename0 = String('filename0')\nlen0 = Int('len0')\npath0 = String('path0')\nfilename0_isNull = Bool('filename0_isNull')\n\nconstraints = [\n  len0 == 1,\n  path0 == filename0.substring(0, len0),\n  And(And(And(And(And(And(And(And(And(And(And(And(Not(filename0_isNull), Not(filename0_isNull)), Not(Length(filename0) == 0)), Not(filename0.charAt(0) == ':')), Not(Length(filename0) == 1)), Not(filename0.charAt(0) == '~')), Not(filename0.charAt(1) == ':')), Not(Or(Or(filename0.charAt(0) == '/', And(filename0.charAt(0) == '\\\\', filename0.charAt(1) == '/')), filename0.charAt(1) == '\\\\'))), Or(filename0.charAt(0) == '/', filename0.charAt(0) == '\\\\')), Not(len0 < 0)), Not(len0 > Length(filename0))), 0 < Length(path0)), path0.charAt(0) == 0)\n]\n\nsolver = Solver()\nfor constraint in constraints:\n  solver.add(constraint)\n\nmodels = list(all_smt(solver))\nfor model in models: print(model)",
          "symPyProgram": "from sympy import Symbol\nfrom sympy import simplify\nfrom sympy.core.relational import Eq, Ne, StrictGreaterThan, StrictLessThan, LessThan, GreaterThan\nfrom sympy.printing import ccode\n\nfilename = Symbol('filename')\nfilename_length = Symbol('filename_length')\nfilename_charAt = Symbol('filename_charAt')\nfilename_substring_length = Symbol('filename_substring_length')\nfilename_substring = Symbol('filename_substring')\nfilename_substring_charAt = Symbol('filename_substring_charAt')\nnull = Symbol('null')\nwit_str_0 = Symbol('wit_str_0') # ':'\nwit_str_1 = Symbol('wit_str_1') # '~'\nwit_str_2 = Symbol('wit_str_2') # ':'\nwit_str_3 = Symbol('wit_str_3') # '/'\nwit_str_4 = Symbol('wit_str_4') # '\\\\'\nwit_str_5 = Symbol('wit_str_5') # '/'\nwit_str_6 = Symbol('wit_str_6') # '\\\\'\nwit_str_7 = Symbol('wit_str_7') # '/'\nwit_str_8 = Symbol('wit_str_8') # '\\\\'\npath_conjunction = (((((((((((((~((Eq(filename, null)))) & (~((Eq(filename, null))))) & (~((Eq(filename_length, 0))))) & (~((Eq(filename_charAt, wit_str_0))))) & (~((Eq(filename_length, 1))))) & (~((Eq(filename_charAt, wit_str_1))))) & (~((Eq(filename_charAt, wit_str_2))))) & (~((((Eq(filename_charAt, wit_str_3)) | ((Eq(filename_charAt, wit_str_4)) & (Eq(filename_charAt, wit_str_5)))) | (Eq(filename_charAt, wit_str_6)))))) & ((Eq(filename_charAt, wit_str_7)) | (Eq(filename_charAt, wit_str_8)))) & (~((StrictLessThan(1, 0))))) & (~((StrictGreaterThan(1, filename_length))))) & (StrictLessThan(0, filename_substring_length))) & (Eq(filename_substring_charAt, 0)))\nprint(ccode(simplify(path_conjunction)))",
          "soundSymbolic": false,
          "soundBackwards": true,
          "maybe": true,
          "line": 763,
          "throwingLine": 776,
          "isStatic": true,
          "targetOnlyArguments": false
        },
        {
          "qualifiedSignature": "org.apache.commons.io.FilenameUtils.getPrefix(java.lang.String)",
          "exception": "throw new IllegalArgumentException(\"Null byte present in file/path name. There are no \" + \"known legitimate use cases for such data, but several injection attacks may use it\")",
          "pathCojunction": "(!(filename == null)) && (filename == null) && (!(len < 0)) && (len > filename.length()) && (0 < path.length()) && (filename + UNIX_SEPARATOR.charAt(0) == 0)",
          "symbolicPathConjunction": "(!(filename == null)) && (getPrefixLength(filename)) && (!(len < 0)) && (len > filename.length()) && ((0 < path.length()) && (path.charAt(0) == 0))",
          "backwardsPathConjunction": "(!(filename == null)) && (filename == null) && (!(NOT_FOUND < 0)) && (NOT_FOUND > filename.length()) && (0 < path.length()) && (filename + UNIX_SEPARATOR.charAt(0) == 0)",
          "z3Program": "from z3 import *\nfrom z3_all_models import *\n\nfilename0 = String('filename0')\nNOT_FOUND0 = Int('NOT_FOUND0')\nlen0 = Int('len0')\npath0 = String('path0')\nfilename0_isNull = Bool('filename0_isNull')\n\nconstraints = [\n  NOT_FOUND0 == -1,\n  len0 == NOT_FOUND0,\n  And(And(And(And(And(Not(filename0_isNull), filename0_isNull), Not(len0 < 0)), len0 > Length(filename0)), 0 < Length(path0)), filename0 + UNIX_SEPARATOR.charAt(0) == 0)\n]\n\nsolver = Solver()\nfor constraint in constraints:\n  solver.add(constraint)\n\nmodels = list(all_smt(solver))\nfor model in models: print(model)",
          "symPyProgram": "from sympy import Symbol\nfrom sympy import simplify\nfrom sympy.core.relational import Eq, Ne, StrictGreaterThan, StrictLessThan, LessThan, GreaterThan\nfrom sympy.printing import ccode\n\nfilename = Symbol('filename')\npath = Symbol('path')\nfilename_length = Symbol('filename_length')\npath_length = Symbol('path_length')\nUNIX_SEPARATOR_charAt = Symbol('UNIX_SEPARATOR_charAt')\nnull = Symbol('null')\npath_conjunction = ((((((~((Eq(filename, null)))) & (Eq(filename, null))) & (~((StrictLessThan(NOT_FOUND, 0))))) & (StrictGreaterThan(NOT_FOUND, filename_length))) & (StrictLessThan(0, path_length))) & (Eq((filename + UNIX_SEPARATOR_charAt), 0)))\nprint(ccode(simplify(path_conjunction)))",
          "soundSymbolic": false,
          "soundBackwards": false,
          "maybe": true,
          "line": 763,
          "throwingLine": 772,
          "isStatic": true,
          "targetOnlyArguments": false
        },
        {
          "qualifiedSignature": "org.apache.commons.io.FilenameUtils.getPrefix(java.lang.String)",
          "exception": "throw new IllegalArgumentException(\"Null byte present in file/path name. There are no \" + \"known legitimate use cases for such data, but several injection attacks may use it\")",
          "pathCojunction": "(!(filename == null)) && (!(filename == null)) && (!(filename.length() == 0)) && (!(Character.toUpperCase(ch0) == ':')) && (!(filename.length() == 1)) && (!(Character.toUpperCase(ch0) == '~')) && (filename.charAt(1) == ':') && (!(Character.toUpperCase(ch0) >= 'A' && Character.toUpperCase(ch0) <= 'Z')) && (Character.toUpperCase(ch0) == '/') && (!(len < 0)) && (len > filename.length()) && (0 < path.length()) && (filename + UNIX_SEPARATOR.charAt(0) == 0)",
          "symbolicPathConjunction": "(!(filename == null)) && (getPrefixLength(filename)) && (!(len < 0)) && (len > filename.length()) && ((0 < path.length()) && (path.charAt(0) == 0))",
          "backwardsPathConjunction": "(!(filename == null)) && (!(filename == null)) && (!(filename.length() == 0)) && (!(Character.toUpperCase(Character.toUpperCase(Character.toUpperCase(ch0))) == ':')) && (!(filename.length() == 1)) && (!(Character.toUpperCase(Character.toUpperCase(Character.toUpperCase(ch0))) == '~')) && (filename.charAt(1) == ':') && (!(Character.toUpperCase(Character.toUpperCase(Character.toUpperCase(ch0))) >= 'A' && Character.toUpperCase(Character.toUpperCase(Character.toUpperCase(ch0))) <= 'Z')) && (Character.toUpperCase(Character.toUpperCase(Character.toUpperCase(ch0))) == '/') && (!(1 < 0)) && (1 > filename.length()) && (0 < path.length()) && (filename + UNIX_SEPARATOR.charAt(0) == 0)",
          "simplifiedPathConjunction": "Character.toUpperCase(Character.toUpperCase(Character.toUpperCase(ch0))) == '/' && UNIX_SEPARATOR.charAt(0) == -filename && filename.charAt(1) == ':' && (Character.toUpperCase(Character.toUpperCase(Character.toUpperCase(ch0))) > 'Z' || Character.toUpperCase(Character.toUpperCase(Character.toUpperCase(ch0))) < 'A') && path.length() > 0 && filename.length() < 1 && Character.toUpperCase(Character.toUpperCase(Character.toUpperCase(ch0))) != wit_str_0 && Character.toUpperCase(Character.toUpperCase(Character.toUpperCase(ch0))) != '~' && filename != null && filename.length() != 0",
          "z3Program": "from z3 import *\nfrom z3_all_models import *\n\nfilename0 = String('filename0')\nlen0 = Int('len0')\npath0 = String('path0')\nfilename0_isNull = Bool('filename0_isNull')\n\nconstraints = [\n  ch00 == Character.toUpperCase(ch0),\n  len0 == 1,\n  And(And(And(And(And(And(And(And(And(And(And(And(Not(filename0_isNull), Not(filename0_isNull)), Not(Length(filename0) == 0)), Not(Character.toUpperCase(ch00) == ':')), Not(Length(filename0) == 1)), Not(Character.toUpperCase(ch00) == '~')), filename0.charAt(1) == ':'), Not(And(Character.toUpperCase(ch00) >= 'A', Character.toUpperCase(ch00) <= 'Z'))), Character.toUpperCase(ch00) == '/'), Not(len0 < 0)), len0 > Length(filename0)), 0 < Length(path0)), filename0 + UNIX_SEPARATOR.charAt(0) == 0)\n]\n\nsolver = Solver()\nfor constraint in constraints:\n  solver.add(constraint)\n\nmodels = list(all_smt(solver))\nfor model in models: print(model)",
          "symPyProgram": "from sympy import Symbol\nfrom sympy import simplify\nfrom sympy.core.relational import Eq, Ne, StrictGreaterThan, StrictLessThan, LessThan, GreaterThan\nfrom sympy.printing import ccode\n\nfilename = Symbol('filename')\npath = Symbol('path')\nfilename_length = Symbol('filename_length')\nCharacter_toUpperCase = Symbol('Character_toUpperCase')\nfilename_charAt = Symbol('filename_charAt')\npath_length = Symbol('path_length')\nUNIX_SEPARATOR_charAt = Symbol('UNIX_SEPARATOR_charAt')\nnull = Symbol('null')\nwit_str_0 = Symbol('wit_str_0') # ':'\nwit_str_1 = Symbol('wit_str_1') # '~'\nwit_str_2 = Symbol('wit_str_2') # ':'\nwit_str_3 = Symbol('wit_str_3') # 'A'\nwit_str_4 = Symbol('wit_str_4') # 'Z'\nwit_str_5 = Symbol('wit_str_5') # '/'\npath_conjunction = (((((((((((((~((Eq(filename, null)))) & (~((Eq(filename, null))))) & (~((Eq(filename_length, 0))))) & (~((Eq(Character_toUpperCase, wit_str_0))))) & (~((Eq(filename_length, 1))))) & (~((Eq(Character_toUpperCase, wit_str_1))))) & (Eq(filename_charAt, wit_str_2))) & (~(((GreaterThan(Character_toUpperCase, wit_str_3)) & (LessThan(Character_toUpperCase, wit_str_4)))))) & (Eq(Character_toUpperCase, wit_str_5))) & (~((StrictLessThan(1, 0))))) & (StrictGreaterThan(1, filename_length))) & (StrictLessThan(0, path_length))) & (Eq((filename + UNIX_SEPARATOR_charAt), 0)))\nprint(ccode(simplify(path_conjunction)))",
          "soundSymbolic": false,
          "soundBackwards": false,
          "maybe": true,
          "line": 763,
          "throwingLine": 772,
          "isStatic": true,
          "targetOnlyArguments": false
        },
        {
          "qualifiedSignature": "org.apache.commons.io.FilenameUtils.getPrefix(java.lang.String)",
          "exception": "throw new IllegalArgumentException(\"Null byte present in file/path name. There are no \" + \"known legitimate use cases for such data, but several injection attacks may use it\");",
          "pathCojunction": "(!(filename == null)) && (!(filename == null)) && (!(filename.length() == 0)) && (!(filename.charAt(0) == ':')) && (!(filename.length() == 1)) && (!(filename.charAt(0) == '~')) && (!(filename.charAt(1) == ':')) && (filename.charAt(0) == '/' || filename.charAt(0) == '\\\\' && filename.charAt(1) == '/' || filename.charAt(1) == '\\\\') && (filename.indexOf(UNIX_SEPARATOR, 2) == -1 && filename.indexOf(WINDOWS_SEPARATOR, 2) == -1 || filename.indexOf(UNIX_SEPARATOR, 2) == 2 || filename.indexOf(WINDOWS_SEPARATOR, 2) == 2) && (!(len < 0)) && (!(len > filename.length())) && (0 < path.length()) && (path.charAt(0) == 0)",
          "symbolicPathConjunction": "(!(filename == null)) && (getPrefixLength(filename)) && (!(len < 0)) && (!(len > filename.length())) && ((0 < path.length()) && (path.charAt(0) == 0))",
          "backwardsPathConjunction": "(!(filename == null)) && (!(filename == null)) && (!(filename.length() == 0)) && (!(filename.charAt(0) == ':')) && (!(filename.length() == 1)) && (!(filename.charAt(0) == '~')) && (!(filename.charAt(1) == ':')) && (filename.charAt(0) == '/' || filename.charAt(0) == '\\\\' && filename.charAt(1) == '/' || filename.charAt(1) == '\\\\') && (filename.indexOf(UNIX_SEPARATOR, 2) == -1 && filename.indexOf(WINDOWS_SEPARATOR, 2) == -1 || filename.indexOf(UNIX_SEPARATOR, 2) == 2 || filename.indexOf(WINDOWS_SEPARATOR, 2) == 2) && (!(NOT_FOUND < 0)) && (!(NOT_FOUND > filename.length())) && (0 < filename.substring(0, NOT_FOUND).length()) && (filename.substring(0, NOT_FOUND).charAt(0) == 0)",
          "z3Program": "from z3 import *\nfrom z3_all_models import *\n\nfilename0 = String('filename0')\nNOT_FOUND0 = Int('NOT_FOUND0')\nlen0 = Int('len0')\npath0 = String('path0')\nfilename0_isNull = Bool('filename0_isNull')\n\nconstraints = [\n  WINDOWS_SEPARATOR0 == '\\\\',\n  NOT_FOUND0 == -1,\n  UNIX_SEPARATOR0 == '/',\n  len0 == NOT_FOUND0,\n  path0 == filename0.substring(0, len0),\n  And(And(And(And(And(And(And(And(And(And(And(And(Not(filename0_isNull), Not(filename0_isNull)), Not(Length(filename0) == 0)), Not(filename0.charAt(0) == ':')), Not(Length(filename0) == 1)), Not(filename0.charAt(0) == '~')), Not(filename0.charAt(1) == ':')), Or(Or(filename0.charAt(0) == '/', And(filename0.charAt(0) == '\\\\', filename0.charAt(1) == '/')), filename0.charAt(1) == '\\\\')), Or(Or(And(filename0.indexOf(UNIX_SEPARATOR0, 2) == -1, filename0.indexOf(WINDOWS_SEPARATOR0, 2) == -1), filename0.indexOf(UNIX_SEPARATOR0, 2) == 2), filename0.indexOf(WINDOWS_SEPARATOR0, 2) == 2)), Not(len0 < 0)), Not(len0 > Length(filename0))), 0 < Length(path0)), path0.charAt(0) == 0)\n]\n\nsolver = Solver()\nfor constraint in constraints:\n  solver.add(constraint)\n\nmodels = list(all_smt(solver))\nfor model in models: print(model)",
          "symPyProgram": "from sympy import Symbol\nfrom sympy import simplify\nfrom sympy.core.relational import Eq, Ne, StrictGreaterThan, StrictLessThan, LessThan, GreaterThan\nfrom sympy.printing import ccode\n\nfilename = Symbol('filename')\nfilename_length = Symbol('filename_length')\nfilename_charAt = Symbol('filename_charAt')\nfilename_indexOf = Symbol('filename_indexOf')\nfilename_substring_length = Symbol('filename_substring_length')\nfilename_substring = Symbol('filename_substring')\nfilename_substring_charAt = Symbol('filename_substring_charAt')\nnull = Symbol('null')\nwit_str_0 = Symbol('wit_str_0') # ':'\nwit_str_1 = Symbol('wit_str_1') # '~'\nwit_str_2 = Symbol('wit_str_2') # ':'\nwit_str_3 = Symbol('wit_str_3') # '/'\nwit_str_4 = Symbol('wit_str_4') # '\\\\'\nwit_str_5 = Symbol('wit_str_5') # '/'\nwit_str_6 = Symbol('wit_str_6') # '\\\\'\npath_conjunction = (((((((((((((~((Eq(filename, null)))) & (~((Eq(filename, null))))) & (~((Eq(filename_length, 0))))) & (~((Eq(filename_charAt, wit_str_0))))) & (~((Eq(filename_length, 1))))) & (~((Eq(filename_charAt, wit_str_1))))) & (~((Eq(filename_charAt, wit_str_2))))) & (((Eq(filename_charAt, wit_str_3)) | ((Eq(filename_charAt, wit_str_4)) & (Eq(filename_charAt, wit_str_5)))) | (Eq(filename_charAt, wit_str_6)))) & ((((Eq(filename_indexOf, -1)) & (Eq(filename_indexOf, -1))) | (Eq(filename_indexOf, 2))) | (Eq(filename_indexOf, 2)))) & (~((StrictLessThan(NOT_FOUND, 0))))) & (~((StrictGreaterThan(NOT_FOUND, filename_length))))) & (StrictLessThan(0, filename_substring_length))) & (Eq(filename_substring_charAt, 0)))\nprint(ccode(simplify(path_conjunction)))",
          "soundSymbolic": false,
          "soundBackwards": true,
          "maybe": true,
          "line": 763,
          "throwingLine": 776,
          "isStatic": true,
          "targetOnlyArguments": false
        },
        {
          "qualifiedSignature": "org.apache.commons.io.FilenameUtils.getPrefix(java.lang.String)",
          "exception": "throw new IllegalArgumentException(\"Null byte present in file/path name. There are no \" + \"known legitimate use cases for such data, but several injection attacks may use it\")",
          "pathCojunction": "(!(filename == null)) && (!(filename == null)) && (!(filename.length() == 0)) && (!(filename.charAt(0) == ':')) && (!(filename.length() == 1)) && (!(filename.charAt(0) == '~')) && (!(filename.charAt(1) == ':')) && (!(filename.charAt(0) == '/' || filename.charAt(0) == '\\\\' && filename.charAt(1) == '/' || filename.charAt(1) == '\\\\')) && (filename.charAt(0) == '/' || filename.charAt(0) == '\\\\') && (!(len < 0)) && (len > filename.length()) && (0 < path.length()) && (filename + UNIX_SEPARATOR.charAt(0) == 0)",
          "symbolicPathConjunction": "(!(filename == null)) && (getPrefixLength(filename)) && (!(len < 0)) && (len > filename.length()) && ((0 < path.length()) && (path.charAt(0) == 0))",
          "backwardsPathConjunction": "(!(filename == null)) && (!(filename == null)) && (!(filename.length() == 0)) && (!(filename.charAt(0) == ':')) && (!(filename.length() == 1)) && (!(filename.charAt(0) == '~')) && (!(filename.charAt(1) == ':')) && (!(filename.charAt(0) == '/' || filename.charAt(0) == '\\\\' && filename.charAt(1) == '/' || filename.charAt(1) == '\\\\')) && (filename.charAt(0) == '/' || filename.charAt(0) == '\\\\') && (!(1 < 0)) && (1 > filename.length()) && (0 < path.length()) && (filename + UNIX_SEPARATOR.charAt(0) == 0)",
          "simplifiedPathConjunction": "UNIX_SEPARATOR.charAt(0) == -filename && (filename.charAt(1) == '/' || filename.charAt(1) == '\\\\') && (filename.charAt(1) != wit_str_4 || filename.charAt(1) != wit_str_5) && path.length() > 0 && filename.length() < 1 && filename != null && filename.charAt(1) != wit_str_0 && filename.charAt(1) != '~' && filename.charAt(1) != ':' && filename.charAt(1) != wit_str_3 && filename.charAt(1) != wit_str_6 && filename.length() != 0",
          "z3Program": "from z3 import *\nfrom z3_all_models import *\n\nfilename0 = String('filename0')\nlen0 = Int('len0')\npath0 = String('path0')\nfilename0_isNull = Bool('filename0_isNull')\n\nconstraints = [\n  len0 == 1,\n  And(And(And(And(And(And(And(And(And(And(And(And(Not(filename0_isNull), Not(filename0_isNull)), Not(Length(filename0) == 0)), Not(filename0.charAt(0) == ':')), Not(Length(filename0) == 1)), Not(filename0.charAt(0) == '~')), Not(filename0.charAt(1) == ':')), Not(Or(Or(filename0.charAt(0) == '/', And(filename0.charAt(0) == '\\\\', filename0.charAt(1) == '/')), filename0.charAt(1) == '\\\\'))), Or(filename0.charAt(0) == '/', filename0.charAt(0) == '\\\\')), Not(len0 < 0)), len0 > Length(filename0)), 0 < Length(path0)), filename0 + UNIX_SEPARATOR.charAt(0) == 0)\n]\n\nsolver = Solver()\nfor constraint in constraints:\n  solver.add(constraint)\n\nmodels = list(all_smt(solver))\nfor model in models: print(model)",
          "symPyProgram": "from sympy import Symbol\nfrom sympy import simplify\nfrom sympy.core.relational import Eq, Ne, StrictGreaterThan, StrictLessThan, LessThan, GreaterThan\nfrom sympy.printing import ccode\n\nfilename = Symbol('filename')\npath = Symbol('path')\nfilename_length = Symbol('filename_length')\nfilename_charAt = Symbol('filename_charAt')\npath_length = Symbol('path_length')\nUNIX_SEPARATOR_charAt = Symbol('UNIX_SEPARATOR_charAt')\nnull = Symbol('null')\nwit_str_0 = Symbol('wit_str_0') # ':'\nwit_str_1 = Symbol('wit_str_1') # '~'\nwit_str_2 = Symbol('wit_str_2') # ':'\nwit_str_3 = Symbol('wit_str_3') # '/'\nwit_str_4 = Symbol('wit_str_4') # '\\\\'\nwit_str_5 = Symbol('wit_str_5') # '/'\nwit_str_6 = Symbol('wit_str_6') # '\\\\'\nwit_str_7 = Symbol('wit_str_7') # '/'\nwit_str_8 = Symbol('wit_str_8') # '\\\\'\npath_conjunction = (((((((((((((~((Eq(filename, null)))) & (~((Eq(filename, null))))) & (~((Eq(filename_length, 0))))) & (~((Eq(filename_charAt, wit_str_0))))) & (~((Eq(filename_length, 1))))) & (~((Eq(filename_charAt, wit_str_1))))) & (~((Eq(filename_charAt, wit_str_2))))) & (~((((Eq(filename_charAt, wit_str_3)) | ((Eq(filename_charAt, wit_str_4)) & (Eq(filename_charAt, wit_str_5)))) | (Eq(filename_charAt, wit_str_6)))))) & ((Eq(filename_charAt, wit_str_7)) | (Eq(filename_charAt, wit_str_8)))) & (~((StrictLessThan(1, 0))))) & (StrictGreaterThan(1, filename_length))) & (StrictLessThan(0, path_length))) & (Eq((filename + UNIX_SEPARATOR_charAt), 0)))\nprint(ccode(simplify(path_conjunction)))",
          "soundSymbolic": false,
          "soundBackwards": false,
          "maybe": true,
          "line": 763,
          "throwingLine": 772,
          "isStatic": true,
          "targetOnlyArguments": false
        },
        {
          "qualifiedSignature": "org.apache.commons.io.FilenameUtils.getPrefix(java.lang.String)",
          "exception": "throw new IllegalArgumentException(\"Null byte present in file/path name. There are no \" + \"known legitimate use cases for such data, but several injection attacks may use it\");",
          "pathCojunction": "(!(filename == null)) && (!(filename == null)) && (!(filename.length() == 0)) && (!(Character.toUpperCase(ch0) == ':')) && (!(filename.length() == 1)) && (!(Character.toUpperCase(ch0) == '~')) && (filename.charAt(1) == ':') && (!(Character.toUpperCase(ch0) >= 'A' && Character.toUpperCase(ch0) <= 'Z')) && (Character.toUpperCase(ch0) == '/') && (!(len < 0)) && (!(len > filename.length())) && (0 < path.length()) && (path.charAt(0) == 0)",
          "symbolicPathConjunction": "(!(filename == null)) && (getPrefixLength(filename)) && (!(len < 0)) && (!(len > filename.length())) && ((0 < path.length()) && (path.charAt(0) == 0))",
          "backwardsPathConjunction": "(!(filename == null)) && (!(filename == null)) && (!(filename.length() == 0)) && (!(Character.toUpperCase(Character.toUpperCase(Character.toUpperCase(ch0))) == ':')) && (!(filename.length() == 1)) && (!(Character.toUpperCase(Character.toUpperCase(Character.toUpperCase(ch0))) == '~')) && (filename.charAt(1) == ':') && (!(Character.toUpperCase(Character.toUpperCase(Character.toUpperCase(ch0))) >= 'A' && Character.toUpperCase(Character.toUpperCase(Character.toUpperCase(ch0))) <= 'Z')) && (Character.toUpperCase(Character.toUpperCase(Character.toUpperCase(ch0))) == '/') && (!(1 < 0)) && (!(1 > filename.length())) && (0 < filename.substring(0, 1).length()) && (filename.substring(0, 1).charAt(0) == 0)",
          "simplifiedPathConjunction": "Character.toUpperCase(Character.toUpperCase(Character.toUpperCase(ch0))) == '/' && filename.charAt(1) == ':' && filename.substring(0, 1)_charAt == 0 && (Character.toUpperCase(Character.toUpperCase(Character.toUpperCase(ch0))) > 'Z' || Character.toUpperCase(Character.toUpperCase(Character.toUpperCase(ch0))) < 'A') && filename.length() > 1 && filename.substring(0, 1)_length > 0 && Character.toUpperCase(Character.toUpperCase(Character.toUpperCase(ch0))) != wit_str_0 && Character.toUpperCase(Character.toUpperCase(Character.toUpperCase(ch0))) != '~' && filename != null && filename.length() != 0",
          "z3Program": "from z3 import *\nfrom z3_all_models import *\n\nfilename0 = String('filename0')\nlen0 = Int('len0')\npath0 = String('path0')\nfilename0_isNull = Bool('filename0_isNull')\n\nconstraints = [\n  ch00 == Character.toUpperCase(ch0),\n  len0 == 1,\n  path0 == filename0.substring(0, len0),\n  And(And(And(And(And(And(And(And(And(And(And(And(Not(filename0_isNull), Not(filename0_isNull)), Not(Length(filename0) == 0)), Not(Character.toUpperCase(ch00) == ':')), Not(Length(filename0) == 1)), Not(Character.toUpperCase(ch00) == '~')), filename0.charAt(1) == ':'), Not(And(Character.toUpperCase(ch00) >= 'A', Character.toUpperCase(ch00) <= 'Z'))), Character.toUpperCase(ch00) == '/'), Not(len0 < 0)), Not(len0 > Length(filename0))), 0 < Length(path0)), path0.charAt(0) == 0)\n]\n\nsolver = Solver()\nfor constraint in constraints:\n  solver.add(constraint)\n\nmodels = list(all_smt(solver))\nfor model in models: print(model)",
          "symPyProgram": "from sympy import Symbol\nfrom sympy import simplify\nfrom sympy.core.relational import Eq, Ne, StrictGreaterThan, StrictLessThan, LessThan, GreaterThan\nfrom sympy.printing import ccode\n\nfilename = Symbol('filename')\nfilename_length = Symbol('filename_length')\nCharacter_toUpperCase = Symbol('Character_toUpperCase')\nfilename_charAt = Symbol('filename_charAt')\nfilename_substring_length = Symbol('filename_substring_length')\nfilename_substring = Symbol('filename_substring')\nfilename_substring_charAt = Symbol('filename_substring_charAt')\nnull = Symbol('null')\nwit_str_0 = Symbol('wit_str_0') # ':'\nwit_str_1 = Symbol('wit_str_1') # '~'\nwit_str_2 = Symbol('wit_str_2') # ':'\nwit_str_3 = Symbol('wit_str_3') # 'A'\nwit_str_4 = Symbol('wit_str_4') # 'Z'\nwit_str_5 = Symbol('wit_str_5') # '/'\npath_conjunction = (((((((((((((~((Eq(filename, null)))) & (~((Eq(filename, null))))) & (~((Eq(filename_length, 0))))) & (~((Eq(Character_toUpperCase, wit_str_0))))) & (~((Eq(filename_length, 1))))) & (~((Eq(Character_toUpperCase, wit_str_1))))) & (Eq(filename_charAt, wit_str_2))) & (~(((GreaterThan(Character_toUpperCase, wit_str_3)) & (LessThan(Character_toUpperCase, wit_str_4)))))) & (Eq(Character_toUpperCase, wit_str_5))) & (~((StrictLessThan(1, 0))))) & (~((StrictGreaterThan(1, filename_length))))) & (StrictLessThan(0, filename_substring_length))) & (Eq(filename_substring_charAt, 0)))\nprint(ccode(simplify(path_conjunction)))",
          "soundSymbolic": false,
          "soundBackwards": false,
          "maybe": true,
          "line": 763,
          "throwingLine": 776,
          "isStatic": true,
          "targetOnlyArguments": false
        },
        {
          "qualifiedSignature": "org.apache.commons.io.FilenameUtils.getPrefix(java.lang.String)",
          "exception": "throw new IllegalArgumentException(\"Null byte present in file/path name. There are no \" + \"known legitimate use cases for such data, but several injection attacks may use it\");",
          "pathCojunction": "(!(filename == null)) && (!(filename == null)) && (!(filename.length() == 0)) && (filename.charAt(0) == ':') && (!(len < 0)) && (!(len > filename.length())) && (0 < path.length()) && (path.charAt(0) == 0)",
          "symbolicPathConjunction": "(!(filename == null)) && (getPrefixLength(filename)) && (!(len < 0)) && (!(len > filename.length())) && ((0 < path.length()) && (path.charAt(0) == 0))",
          "backwardsPathConjunction": "(!(filename == null)) && (!(filename == null)) && (!(filename.length() == 0)) && (filename.charAt(0) == ':') && (!(NOT_FOUND < 0)) && (!(NOT_FOUND > filename.length())) && (0 < filename.substring(0, NOT_FOUND).length()) && (filename.substring(0, NOT_FOUND).charAt(0) == 0)",
          "z3Program": "from z3 import *\nfrom z3_all_models import *\n\nfilename0 = String('filename0')\nNOT_FOUND0 = Int('NOT_FOUND0')\nlen0 = Int('len0')\npath0 = String('path0')\nfilename0_isNull = Bool('filename0_isNull')\n\nconstraints = [\n  NOT_FOUND0 == -1,\n  len0 == NOT_FOUND0,\n  path0 == filename0.substring(0, len0),\n  And(And(And(And(And(And(And(Not(filename0_isNull), Not(filename0_isNull)), Not(Length(filename0) == 0)), filename0.charAt(0) == ':'), Not(len0 < 0)), Not(len0 > Length(filename0))), 0 < Length(path0)), path0.charAt(0) == 0)\n]\n\nsolver = Solver()\nfor constraint in constraints:\n  solver.add(constraint)\n\nmodels = list(all_smt(solver))\nfor model in models: print(model)",
          "symPyProgram": "from sympy import Symbol\nfrom sympy import simplify\nfrom sympy.core.relational import Eq, Ne, StrictGreaterThan, StrictLessThan, LessThan, GreaterThan\nfrom sympy.printing import ccode\n\nfilename = Symbol('filename')\nfilename_length = Symbol('filename_length')\nfilename_charAt = Symbol('filename_charAt')\nfilename_substring_length = Symbol('filename_substring_length')\nfilename_substring = Symbol('filename_substring')\nfilename_substring_charAt = Symbol('filename_substring_charAt')\nnull = Symbol('null')\nwit_str_0 = Symbol('wit_str_0') # ':'\npath_conjunction = ((((((((~((Eq(filename, null)))) & (~((Eq(filename, null))))) & (~((Eq(filename_length, 0))))) & (Eq(filename_charAt, wit_str_0))) & (~((StrictLessThan(NOT_FOUND, 0))))) & (~((StrictGreaterThan(NOT_FOUND, filename_length))))) & (StrictLessThan(0, filename_substring_length))) & (Eq(filename_substring_charAt, 0)))\nprint(ccode(simplify(path_conjunction)))",
          "soundSymbolic": false,
          "soundBackwards": true,
          "maybe": true,
          "line": 763,
          "throwingLine": 776,
          "isStatic": true,
          "targetOnlyArguments": false
        },
        {
          "qualifiedSignature": "org.apache.commons.io.FilenameUtils.getPrefix(java.lang.String)",
          "exception": "throw new IllegalArgumentException(\"Null byte present in file/path name. There are no \" + \"known legitimate use cases for such data, but several injection attacks may use it\")",
          "pathCojunction": "(!(filename == null)) && (!(filename == null)) && (!(filename.length() == 0)) && (filename.charAt(0) == ':') && (!(len < 0)) && (len > filename.length()) && (0 < path.length()) && (filename + UNIX_SEPARATOR.charAt(0) == 0)",
          "symbolicPathConjunction": "(!(filename == null)) && (getPrefixLength(filename)) && (!(len < 0)) && (len > filename.length()) && ((0 < path.length()) && (path.charAt(0) == 0))",
          "backwardsPathConjunction": "(!(filename == null)) && (!(filename == null)) && (!(filename.length() == 0)) && (filename.charAt(0) == ':') && (!(NOT_FOUND < 0)) && (NOT_FOUND > filename.length()) && (0 < path.length()) && (filename + UNIX_SEPARATOR.charAt(0) == 0)",
          "z3Program": "from z3 import *\nfrom z3_all_models import *\n\nfilename0 = String('filename0')\nNOT_FOUND0 = Int('NOT_FOUND0')\nlen0 = Int('len0')\npath0 = String('path0')\nfilename0_isNull = Bool('filename0_isNull')\n\nconstraints = [\n  NOT_FOUND0 == -1,\n  len0 == NOT_FOUND0,\n  And(And(And(And(And(And(And(Not(filename0_isNull), Not(filename0_isNull)), Not(Length(filename0) == 0)), filename0.charAt(0) == ':'), Not(len0 < 0)), len0 > Length(filename0)), 0 < Length(path0)), filename0 + UNIX_SEPARATOR.charAt(0) == 0)\n]\n\nsolver = Solver()\nfor constraint in constraints:\n  solver.add(constraint)\n\nmodels = list(all_smt(solver))\nfor model in models: print(model)",
          "symPyProgram": "from sympy import Symbol\nfrom sympy import simplify\nfrom sympy.core.relational import Eq, Ne, StrictGreaterThan, StrictLessThan, LessThan, GreaterThan\nfrom sympy.printing import ccode\n\nfilename = Symbol('filename')\npath = Symbol('path')\nfilename_length = Symbol('filename_length')\nfilename_charAt = Symbol('filename_charAt')\npath_length = Symbol('path_length')\nUNIX_SEPARATOR_charAt = Symbol('UNIX_SEPARATOR_charAt')\nnull = Symbol('null')\nwit_str_0 = Symbol('wit_str_0') # ':'\npath_conjunction = ((((((((~((Eq(filename, null)))) & (~((Eq(filename, null))))) & (~((Eq(filename_length, 0))))) & (Eq(filename_charAt, wit_str_0))) & (~((StrictLessThan(NOT_FOUND, 0))))) & (StrictGreaterThan(NOT_FOUND, filename_length))) & (StrictLessThan(0, path_length))) & (Eq((filename + UNIX_SEPARATOR_charAt), 0)))\nprint(ccode(simplify(path_conjunction)))",
          "soundSymbolic": false,
          "soundBackwards": false,
          "maybe": true,
          "line": 763,
          "throwingLine": 772,
          "isStatic": true,
          "targetOnlyArguments": false
        },
        {
          "qualifiedSignature": "org.apache.commons.io.FilenameUtils.getPrefix(java.lang.String)",
          "exception": "throw new IllegalArgumentException(\"Null byte present in file/path name. There are no \" + \"known legitimate use cases for such data, but several injection attacks may use it\");",
          "pathCojunction": "(!(filename == null)) && (!(filename == null)) && (!(filename.length() == 0)) && (!(filename.charAt(0) == ':')) && (filename.length() == 1) && (!(filename.charAt(0) == '~')) && (filename.charAt(0) == '/' || filename.charAt(0) == '\\\\') && (!(len < 0)) && (!(len > filename.length())) && (0 < path.length()) && (path.charAt(0) == 0)",
          "symbolicPathConjunction": "(!(filename == null)) && (getPrefixLength(filename)) && (!(len < 0)) && (!(len > filename.length())) && ((0 < path.length()) && (path.charAt(0) == 0))",
          "backwardsPathConjunction": "(!(filename == null)) && (!(filename == null)) && (!(filename.length() == 0)) && (!(filename.charAt(0) == ':')) && (filename.length() == 1) && (!(filename.charAt(0) == '~')) && (filename.charAt(0) == '/' || filename.charAt(0) == '\\\\') && (!(1 < 0)) && (!(1 > filename.length())) && (0 < filename.substring(0, 1).length()) && (filename.substring(0, 1).charAt(0) == 0)",
          "simplifiedPathConjunction": "filename.length() == 1 && filename.substring(0, 1).charAt(0) == 0 && (filename.charAt(0) == '/' || filename.charAt(0) == '\\\\') && filename.substring(0, 1).length() > 0 && filename != null && filename.charAt(0) != ':' && filename.charAt(0) != '~'",
          "z3Program": "from z3 import *\nfrom z3_all_models import *\n\nfilename0 = String('filename0')\nlen0 = Int('len0')\npath0 = String('path0')\nfilename0_isNull = Bool('filename0_isNull')\n\nconstraints = [\n  len0 == 1,\n  path0 == filename0.substring(0, len0),\n  And(And(And(And(And(And(And(And(And(And(Not(filename0_isNull), Not(filename0_isNull)), Not(Length(filename0) == 0)), Not(filename0.charAt(0) == ':')), Length(filename0) == 1), Not(filename0.charAt(0) == '~')), Or(filename0.charAt(0) == '/', filename0.charAt(0) == '\\\\')), Not(len0 < 0)), Not(len0 > Length(filename0))), 0 < Length(path0)), path0.charAt(0) == 0)\n]\n\nsolver = Solver()\nfor constraint in constraints:\n  solver.add(constraint)\n\nmodels = list(all_smt(solver))\nfor model in models: print(model)",
          "symPyProgram": "from sympy import Symbol\nfrom sympy import simplify\nfrom sympy.core.relational import Eq, Ne, StrictGreaterThan, StrictLessThan, LessThan, GreaterThan\nfrom sympy.printing import ccode\n\nfilename = Symbol('filename')\nfilename_length = Symbol('filename_length')\nfilename_charAt = Symbol('filename_charAt')\nfilename_substring_length = Symbol('filename_substring_length')\nfilename_substring = Symbol('filename_substring')\nfilename_substring_charAt = Symbol('filename_substring_charAt')\nnull = Symbol('null')\nwit_str_0 = Symbol('wit_str_0') # ':'\nwit_str_1 = Symbol('wit_str_1') # '~'\nwit_str_2 = Symbol('wit_str_2') # '/'\nwit_str_3 = Symbol('wit_str_3') # '\\\\'\npath_conjunction = (((((((((((~((Eq(filename, null)))) & (~((Eq(filename, null))))) & (~((Eq(filename_length, 0))))) & (~((Eq(filename_charAt, wit_str_0))))) & (Eq(filename_length, 1))) & (~((Eq(filename_charAt, wit_str_1))))) & ((Eq(filename_charAt, wit_str_2)) | (Eq(filename_charAt, wit_str_3)))) & (~((StrictLessThan(1, 0))))) & (~((StrictGreaterThan(1, filename_length))))) & (StrictLessThan(0, filename_substring_length))) & (Eq(filename_substring_charAt, 0)))\nprint(ccode(simplify(path_conjunction)))",
          "soundSymbolic": false,
          "soundBackwards": true,
          "maybe": true,
          "line": 763,
          "throwingLine": 776,
          "isStatic": true,
          "targetOnlyArguments": false
        },
        {
          "qualifiedSignature": "org.apache.commons.io.FilenameUtils.getPrefix(java.lang.String)",
          "exception": "throw new IllegalArgumentException(\"Null byte present in file/path name. There are no \" + \"known legitimate use cases for such data, but several injection attacks may use it\");",
          "pathCojunction": "(!(filename == null)) && (!(filename == null)) && (!(filename.length() == 0)) && (!(Character.toUpperCase(ch0) == ':')) && (!(filename.length() == 1)) && (!(Character.toUpperCase(ch0) == '~')) && (filename.charAt(1) == ':') && (Character.toUpperCase(ch0) >= 'A' && Character.toUpperCase(ch0) <= 'Z') && (!(filename.length() == 2 || filename.charAt(2) == '/' || filename.charAt(2) == '\\\\' == false)) && (!(len < 0)) && (!(len > filename.length())) && (0 < path.length()) && (path.charAt(0) == 0)",
          "symbolicPathConjunction": "(!(filename == null)) && (getPrefixLength(filename)) && (!(len < 0)) && (!(len > filename.length())) && ((0 < path.length()) && (path.charAt(0) == 0))",
          "backwardsPathConjunction": "(!(filename == null)) && (!(filename == null)) && (!(filename.length() == 0)) && (!(Character.toUpperCase(Character.toUpperCase(Character.toUpperCase(ch0))) == ':')) && (!(filename.length() == 1)) && (!(Character.toUpperCase(Character.toUpperCase(Character.toUpperCase(ch0))) == '~')) && (filename.charAt(1) == ':') && (Character.toUpperCase(Character.toUpperCase(Character.toUpperCase(ch0))) >= 'A' && Character.toUpperCase(Character.toUpperCase(Character.toUpperCase(ch0))) <= 'Z') && (!(filename.length() == 2 || filename.charAt(2) == '/' || filename.charAt(2) == '\\\\' == false)) && (!(3 < 0)) && (!(3 > filename.length())) && (0 < filename.substring(0, 3).length()) && (filename.substring(0, 3).charAt(0) == 0)",
          "simplifiedPathConjunction": "filename.charAt(2) == ':' && filename.charAt(2) == '\\\\' && filename.substring(0, 3)_charAt == 0 && Character.toUpperCase(Character.toUpperCase(Character.toUpperCase(ch0))) >= 'A' && filename.length() >= 3 && Character.toUpperCase(Character.toUpperCase(Character.toUpperCase(ch0))) <= 'Z' && filename.substring(0, 3)_length > 0 && Character.toUpperCase(Character.toUpperCase(Character.toUpperCase(ch0))) != wit_str_0 && Character.toUpperCase(Character.toUpperCase(Character.toUpperCase(ch0))) != '~' && filename != null && filename.charAt(2) != '/' && filename.length() != 0 && filename.length() != 1 && filename.length() != 2",
          "z3Program": "from z3 import *\nfrom z3_all_models import *\n\nfilename0 = String('filename0')\nlen0 = Int('len0')\npath0 = String('path0')\nfilename0_isNull = Bool('filename0_isNull')\n\nconstraints = [\n  ch00 == Character.toUpperCase(ch0),\n  len0 == 3,\n  path0 == filename0.substring(0, len0),\n  And(And(And(And(And(And(And(And(And(And(And(And(Not(filename0_isNull), Not(filename0_isNull)), Not(Length(filename0) == 0)), Not(Character.toUpperCase(ch00) == ':')), Not(Length(filename0) == 1)), Not(Character.toUpperCase(ch00) == '~')), filename0.charAt(1) == ':'), And(Character.toUpperCase(ch00) >= 'A', Character.toUpperCase(ch00) <= 'Z')), Not(Or(Or(Length(filename0) == 2, filename0.charAt(2) == '/'), filename0.charAt(2) == '\\\\' == False))), Not(len0 < 0)), Not(len0 > Length(filename0))), 0 < Length(path0)), path0.charAt(0) == 0)\n]\n\nsolver = Solver()\nfor constraint in constraints:\n  solver.add(constraint)\n\nmodels = list(all_smt(solver))\nfor model in models: print(model)",
          "symPyProgram": "from sympy import Symbol\nfrom sympy import simplify\nfrom sympy.core.relational import Eq, Ne, StrictGreaterThan, StrictLessThan, LessThan, GreaterThan\nfrom sympy.printing import ccode\n\nfilename = Symbol('filename')\nfilename_length = Symbol('filename_length')\nCharacter_toUpperCase = Symbol('Character_toUpperCase')\nfilename_charAt = Symbol('filename_charAt')\nfilename_substring_length = Symbol('filename_substring_length')\nfilename_substring = Symbol('filename_substring')\nfilename_substring_charAt = Symbol('filename_substring_charAt')\nnull = Symbol('null')\nwit_str_0 = Symbol('wit_str_0') # ':'\nwit_str_1 = Symbol('wit_str_1') # '~'\nwit_str_2 = Symbol('wit_str_2') # ':'\nwit_str_3 = Symbol('wit_str_3') # 'A'\nwit_str_4 = Symbol('wit_str_4') # 'Z'\nwit_str_5 = Symbol('wit_str_5') # '/'\nwit_str_6 = Symbol('wit_str_6') # '\\\\'\npath_conjunction = (((((((((((((~((Eq(filename, null)))) & (~((Eq(filename, null))))) & (~((Eq(filename_length, 0))))) & (~((Eq(Character_toUpperCase, wit_str_0))))) & (~((Eq(filename_length, 1))))) & (~((Eq(Character_toUpperCase, wit_str_1))))) & (Eq(filename_charAt, wit_str_2))) & ((GreaterThan(Character_toUpperCase, wit_str_3)) & (LessThan(Character_toUpperCase, wit_str_4)))) & (~((((Eq(filename_length, 2)) | (Eq(filename_charAt, wit_str_5))) | (~((Eq(filename_charAt, wit_str_6)))))))) & (~((StrictLessThan(3, 0))))) & (~((StrictGreaterThan(3, filename_length))))) & (StrictLessThan(0, filename_substring_length))) & (Eq(filename_substring_charAt, 0)))\nprint(ccode(simplify(path_conjunction)))",
          "soundSymbolic": false,
          "soundBackwards": false,
          "maybe": true,
          "line": 763,
          "throwingLine": 776,
          "isStatic": true,
          "targetOnlyArguments": false
        },
        {
          "qualifiedSignature": "org.apache.commons.io.FilenameUtils.getPrefix(java.lang.String)",
          "exception": "throw new IllegalArgumentException(\"Null byte present in file/path name. There are no \" + \"known legitimate use cases for such data, but several injection attacks may use it\");",
          "pathCojunction": "(!(filename == null)) && (!(filename == null)) && (filename.length() == 0) && (!(len < 0)) && (!(len > filename.length())) && (0 < path.length()) && (path.charAt(0) == 0)",
          "symbolicPathConjunction": "(!(filename == null)) && (getPrefixLength(filename)) && (!(len < 0)) && (!(len > filename.length())) && ((0 < path.length()) && (path.charAt(0) == 0))",
          "backwardsPathConjunction": "(!(filename == null)) && (!(filename == null)) && (filename.length() == 0) && (!(0 < 0)) && (!(0 > filename.length())) && (0 < filename.substring(0, 0).length()) && (filename.substring(0, 0).charAt(0) == 0)",
          "simplifiedPathConjunction": "filename.length() == 0 && filename.substring(0, 0).charAt(0) == 0 && filename.substring(0, 0).length() > 0 && filename != null",
          "z3Program": "from z3 import *\nfrom z3_all_models import *\n\nfilename0 = String('filename0')\nlen0 = Int('len0')\npath0 = String('path0')\nfilename0_isNull = Bool('filename0_isNull')\n\nconstraints = [\n  len0 == 0,\n  path0 == filename0.substring(0, len0),\n  And(And(And(And(And(And(Not(filename0_isNull), Not(filename0_isNull)), Length(filename0) == 0), Not(len0 < 0)), Not(len0 > Length(filename0))), 0 < Length(path0)), path0.charAt(0) == 0)\n]\n\nsolver = Solver()\nfor constraint in constraints:\n  solver.add(constraint)\n\nmodels = list(all_smt(solver))\nfor model in models: print(model)",
          "symPyProgram": "from sympy import Symbol\nfrom sympy import simplify\nfrom sympy.core.relational import Eq, Ne, StrictGreaterThan, StrictLessThan, LessThan, GreaterThan\nfrom sympy.printing import ccode\n\nfilename = Symbol('filename')\nfilename_length = Symbol('filename_length')\nfilename_substring_length = Symbol('filename_substring_length')\nfilename_substring = Symbol('filename_substring')\nfilename_substring_charAt = Symbol('filename_substring_charAt')\nnull = Symbol('null')\npath_conjunction = (((((((~((Eq(filename, null)))) & (~((Eq(filename, null))))) & (Eq(filename_length, 0))) & (~((StrictLessThan(0, 0))))) & (~((StrictGreaterThan(0, filename_length))))) & (StrictLessThan(0, filename_substring_length))) & (Eq(filename_substring_charAt, 0)))\nprint(ccode(simplify(path_conjunction)))",
          "soundSymbolic": false,
          "soundBackwards": true,
          "maybe": true,
          "line": 763,
          "throwingLine": 776,
          "isStatic": true,
          "targetOnlyArguments": false
        },
        {
          "qualifiedSignature": "org.apache.commons.io.FilenameUtils.getPrefix(java.lang.String)",
          "exception": "throw new IllegalArgumentException(\"Null byte present in file/path name. There are no \" + \"known legitimate use cases for such data, but several injection attacks may use it\")",
          "pathCojunction": "(!(filename == null)) && (!(filename == null)) && (!(filename.length() == 0)) && (!(filename.charAt(0) == ':')) && (filename.length() == 1) && (filename.charAt(0) == '~') && (!(len < 0)) && (len > filename.length()) && (0 < path.length()) && (filename + UNIX_SEPARATOR.charAt(0) == 0)",
          "symbolicPathConjunction": "(!(filename == null)) && (getPrefixLength(filename)) && (!(len < 0)) && (len > filename.length()) && ((0 < path.length()) && (path.charAt(0) == 0))",
          "backwardsPathConjunction": "(!(filename == null)) && (!(filename == null)) && (!(filename.length() == 0)) && (!(filename.charAt(0) == ':')) && (filename.length() == 1) && (filename.charAt(0) == '~') && (!(2 < 0)) && (2 > filename.length()) && (0 < path.length()) && (filename + UNIX_SEPARATOR.charAt(0) == 0)",
          "simplifiedPathConjunction": "UNIX_SEPARATOR.charAt(0) == -filename && filename.charAt(0) == '~' && filename.length() == 1 && path.length() > 0 && filename != null && filename.charAt(0) != ':'",
          "z3Program": "from z3 import *\nfrom z3_all_models import *\n\nfilename0 = String('filename0')\nlen0 = Int('len0')\npath0 = String('path0')\nfilename0_isNull = Bool('filename0_isNull')\n\nconstraints = [\n  len0 == 2,\n  And(And(And(And(And(And(And(And(And(Not(filename0_isNull), Not(filename0_isNull)), Not(Length(filename0) == 0)), Not(filename0.charAt(0) == ':')), Length(filename0) == 1), filename0.charAt(0) == '~'), Not(len0 < 0)), len0 > Length(filename0)), 0 < Length(path0)), filename0 + UNIX_SEPARATOR.charAt(0) == 0)\n]\n\nsolver = Solver()\nfor constraint in constraints:\n  solver.add(constraint)\n\nmodels = list(all_smt(solver))\nfor model in models: print(model)",
          "symPyProgram": "from sympy import Symbol\nfrom sympy import simplify\nfrom sympy.core.relational import Eq, Ne, StrictGreaterThan, StrictLessThan, LessThan, GreaterThan\nfrom sympy.printing import ccode\n\nfilename = Symbol('filename')\npath = Symbol('path')\nfilename_length = Symbol('filename_length')\nfilename_charAt = Symbol('filename_charAt')\npath_length = Symbol('path_length')\nUNIX_SEPARATOR_charAt = Symbol('UNIX_SEPARATOR_charAt')\nnull = Symbol('null')\nwit_str_0 = Symbol('wit_str_0') # ':'\nwit_str_1 = Symbol('wit_str_1') # '~'\npath_conjunction = ((((((((((~((Eq(filename, null)))) & (~((Eq(filename, null))))) & (~((Eq(filename_length, 0))))) & (~((Eq(filename_charAt, wit_str_0))))) & (Eq(filename_length, 1))) & (Eq(filename_charAt, wit_str_1))) & (~((StrictLessThan(2, 0))))) & (StrictGreaterThan(2, filename_length))) & (StrictLessThan(0, path_length))) & (Eq((filename + UNIX_SEPARATOR_charAt), 0)))\nprint(ccode(simplify(path_conjunction)))",
          "soundSymbolic": false,
          "soundBackwards": false,
          "maybe": true,
          "line": 763,
          "throwingLine": 772,
          "isStatic": true,
          "targetOnlyArguments": false
        },
        {
          "qualifiedSignature": "org.apache.commons.io.FilenameUtils.getPath(java.lang.String)",
          "exception": "throw new IllegalArgumentException(\"Null byte present in file/path name. There are no \" + \"known legitimate use cases for such data, but several injection attacks may use it\")",
          "pathCojunction": "(!(filename == null)) && (!(filename == null)) && (!(filename.length() == 0)) && (!(filename.charAt(0) == ':')) && (filename.length() == 1) && (!(filename.charAt(0) == '~')) && (filename.charAt(0) == '/' || filename.charAt(0) == '\\\\') && (!(1 < 0)) && (filename == null) && (!(1 >= filename.length() || NOT_FOUND < 0 || 1 >= index + separatorAdd)) && (0 < filename.substring(prefix, endIndex).length()) && (filename.substring(prefix, endIndex).charAt(0) == 0)",
          "symbolicPathConjunction": "((!(filename == null)) && (getPrefixLength(filename)) && (!(1 < 0)) && (indexOfLastSeparator(filename)) && (!(prefix >= filename.length() || index < 0 || prefix >= endIndex)) && (failIfNullBytePresent(path)))",
          "backwardsPathConjunction": "(!(filename == null)) && (!(filename == null)) && (!(filename.length() == 0)) && (!(filename.charAt(0) == ':')) && (filename.length() == 1) && (!(filename.charAt(0) == '~')) && (filename.charAt(0) == '/' || filename.charAt(0) == '\\\\') && (!(1 < 0)) && (filename == null) && (!(1 >= filename.length() || NOT_FOUND < 0 || 1 >= NOT_FOUND + separatorAdd)) && (0 < filename.substring(1, NOT_FOUND + separatorAdd).length()) && (filename.substring(1, NOT_FOUND + separatorAdd).charAt(0) == 0)",
          "z3Program": "from z3 import *\nfrom z3_all_models import *\n\nfilename0 = String('filename0')\nseparatorAdd0 = Int('separatorAdd0')\nprefix0 = Int('prefix0')\nendIndex0 = Int('endIndex0')\nNOT_FOUND0 = Int('NOT_FOUND0')\nindex0 = Int('index0')\nfilename0_isNull = Bool('filename0_isNull')\n\nconstraints = [\n  prefix0 == 1,\n  endIndex0 == index + separatorAdd0,\n  NOT_FOUND0 == -1,\n  index0 == NOT_FOUND0,\n  And(And(And(And(And(And(And(And(And(And(And(Not(filename0_isNull), Not(filename0_isNull)), Not(Length(filename0) == 0)), Not(filename0.charAt(0) == ':')), Length(filename0) == 1), Not(filename0.charAt(0) == '~')), Or(filename0.charAt(0) == '/', filename0.charAt(0) == '\\\\')), Not(1 < 0)), filename0_isNull), Not(Or(Or(1 >= Length(filename0), NOT_FOUND0 < 0), 1 >= index0 + separatorAdd0))), 0 < filename0.substring(prefix0, endIndex0).length()), filename0.substring(prefix0, endIndex0).charAt(0) == 0)\n]\n\nsolver = Solver()\nfor constraint in constraints:\n  solver.add(constraint)\n\nmodels = list(all_smt(solver))\nfor model in models: print(model)",
          "symPyProgram": "from sympy import Symbol\nfrom sympy import simplify\nfrom sympy.core.relational import Eq, Ne, StrictGreaterThan, StrictLessThan, LessThan, GreaterThan\nfrom sympy.printing import ccode\n\nfilename = Symbol('filename')\nseparatorAdd = Symbol('separatorAdd', integer=True)\nfilename_length = Symbol('filename_length')\nfilename_charAt = Symbol('filename_charAt')\nfilename_substring_length = Symbol('filename_substring_length')\nfilename_substring = Symbol('filename_substring')\nfilename_substring_charAt = Symbol('filename_substring_charAt')\nnull = Symbol('null')\nwit_str_0 = Symbol('wit_str_0') # ':'\nwit_str_1 = Symbol('wit_str_1') # '~'\nwit_str_2 = Symbol('wit_str_2') # '/'\nwit_str_3 = Symbol('wit_str_3') # '\\\\'\npath_conjunction = ((((((((((((~((Eq(filename, null)))) & (~((Eq(filename, null))))) & (~((Eq(filename_length, 0))))) & (~((Eq(filename_charAt, wit_str_0))))) & (Eq(filename_length, 1))) & (~((Eq(filename_charAt, wit_str_1))))) & ((Eq(filename_charAt, wit_str_2)) | (Eq(filename_charAt, wit_str_3)))) & (~((StrictLessThan(1, 0))))) & (Eq(filename, null))) & (~((((GreaterThan(1, filename_length)) | (StrictLessThan(-1, 0))) | (GreaterThan(1, (NOT_FOUND + separatorAdd))))))) & (StrictLessThan(0, filename_substring_length))) & (Eq(filename_substring_charAt, 0)))\nprint(ccode(simplify(path_conjunction)))",
          "soundSymbolic": true,
          "soundBackwards": false,
          "maybe": true,
          "line": 803,
          "throwingLine": 804,
          "isStatic": true,
          "targetOnlyArguments": false
        },
        {
          "qualifiedSignature": "org.apache.commons.io.FilenameUtils.getPath(java.lang.String)",
          "exception": "throw new IllegalArgumentException(\"Null byte present in file/path name. There are no \" + \"known legitimate use cases for such data, but several injection attacks may use it\")",
          "pathCojunction": "(!(filename == null)) && (filename == null) && (!(NOT_FOUND < 0)) && (filename == null) && (!(NOT_FOUND >= filename.length() || NOT_FOUND < 0 || NOT_FOUND >= index + separatorAdd)) && (0 < filename.substring(prefix, endIndex).length()) && (filename.substring(prefix, endIndex).charAt(0) == 0)",
          "symbolicPathConjunction": "((!(filename == null)) && (getPrefixLength(filename)) && (!(NOT_FOUND < 0)) && (indexOfLastSeparator(filename)) && (!(prefix >= filename.length() || index < 0 || prefix >= endIndex)) && (failIfNullBytePresent(path)))",
          "backwardsPathConjunction": "(!(filename == null)) && (filename == null) && (!(NOT_FOUND < 0)) && (filename == null) && (!(NOT_FOUND >= filename.length() || NOT_FOUND < 0 || NOT_FOUND >= NOT_FOUND + separatorAdd)) && (0 < filename.substring(NOT_FOUND, NOT_FOUND + separatorAdd).length()) && (filename.substring(NOT_FOUND, NOT_FOUND + separatorAdd).charAt(0) == 0)",
          "z3Program": "from z3 import *\nfrom z3_all_models import *\n\nfilename0 = String('filename0')\nseparatorAdd0 = Int('separatorAdd0')\nprefix0 = Int('prefix0')\nendIndex0 = Int('endIndex0')\nNOT_FOUND0 = Int('NOT_FOUND0')\nindex0 = Int('index0')\nfilename0_isNull = Bool('filename0_isNull')\n\nconstraints = [\n  prefix0 == NOT_FOUND,\n  endIndex0 == index + separatorAdd0,\n  NOT_FOUND0 == -1,\n  index0 == NOT_FOUND0,\n  And(And(And(And(And(And(Not(filename0_isNull), filename0_isNull), Not(NOT_FOUND0 < 0)), filename0_isNull), Not(Or(Or(NOT_FOUND0 >= Length(filename0), NOT_FOUND0 < 0), NOT_FOUND0 >= index0 + separatorAdd0))), 0 < filename0.substring(prefix0, endIndex0).length()), filename0.substring(prefix0, endIndex0).charAt(0) == 0)\n]\n\nsolver = Solver()\nfor constraint in constraints:\n  solver.add(constraint)\n\nmodels = list(all_smt(solver))\nfor model in models: print(model)",
          "symPyProgram": "from sympy import Symbol\nfrom sympy import simplify\nfrom sympy.core.relational import Eq, Ne, StrictGreaterThan, StrictLessThan, LessThan, GreaterThan\nfrom sympy.printing import ccode\n\nfilename = Symbol('filename')\nseparatorAdd = Symbol('separatorAdd', integer=True)\nfilename_length = Symbol('filename_length')\nfilename_substring_length = Symbol('filename_substring_length')\nfilename_substring = Symbol('filename_substring')\nfilename_substring_charAt = Symbol('filename_substring_charAt')\nnull = Symbol('null')\npath_conjunction = (((((((~((Eq(filename, null)))) & (Eq(filename, null))) & (~((StrictLessThan(-1, 0))))) & (Eq(filename, null))) & (~((((GreaterThan(-1, filename_length)) | (StrictLessThan(-1, 0))) | (GreaterThan(-1, (NOT_FOUND + separatorAdd))))))) & (StrictLessThan(0, filename_substring_length))) & (Eq(filename_substring_charAt, 0)))\nprint(ccode(simplify(path_conjunction)))",
          "soundSymbolic": true,
          "soundBackwards": false,
          "maybe": true,
          "line": 803,
          "throwingLine": 804,
          "isStatic": true,
          "targetOnlyArguments": false
        },
        {
          "qualifiedSignature": "org.apache.commons.io.FilenameUtils.getPath(java.lang.String)",
          "exception": "throw new IllegalArgumentException(\"Null byte present in file/path name. There are no \" + \"known legitimate use cases for such data, but several injection attacks may use it\")",
          "pathCojunction": "(!(filename == null)) && (!(filename == null)) && (!(filename.length() == 0)) && (!(Character.toUpperCase(Character.toUpperCase(ch0)) == ':')) && (!(filename.length() == 1)) && (!(Character.toUpperCase(Character.toUpperCase(ch0)) == '~')) && (filename.charAt(1) == ':') && (Character.toUpperCase(Character.toUpperCase(ch0)) >= 'A' && Character.toUpperCase(Character.toUpperCase(ch0)) <= 'Z') && (!(filename.length() == 2 || filename.charAt(2) == '/' || filename.charAt(2) == '\\\\' == false)) && (!(3 < 0)) && (filename == null) && (!(3 >= filename.length() || NOT_FOUND < 0 || 3 >= index + separatorAdd)) && (0 < filename.substring(prefix, endIndex).length()) && (filename.substring(prefix, endIndex).charAt(0) == 0)",
          "symbolicPathConjunction": "((!(filename == null)) && (getPrefixLength(filename)) && (!(3 < 0)) && (indexOfLastSeparator(filename)) && (!(prefix >= filename.length() || index < 0 || prefix >= endIndex)) && (failIfNullBytePresent(path)))",
          "backwardsPathConjunction": "(!(filename == null)) && (!(filename == null)) && (!(filename.length() == 0)) && (!(Character.toUpperCase(Character.toUpperCase(Character.toUpperCase(Character.toUpperCase(ch0)))) == ':')) && (!(filename.length() == 1)) && (!(Character.toUpperCase(Character.toUpperCase(Character.toUpperCase(Character.toUpperCase(ch0)))) == '~')) && (filename.charAt(1) == ':') && (Character.toUpperCase(Character.toUpperCase(Character.toUpperCase(Character.toUpperCase(ch0)))) >= 'A' && Character.toUpperCase(Character.toUpperCase(Character.toUpperCase(Character.toUpperCase(ch0)))) <= 'Z') && (!(filename.length() == 2 || filename.charAt(2) == '/' || filename.charAt(2) == '\\\\' == false)) && (!(3 < 0)) && (filename == null) && (!(3 >= filename.length() || NOT_FOUND < 0 || 3 >= NOT_FOUND + separatorAdd)) && (0 < filename.substring(3, NOT_FOUND + separatorAdd).length()) && (filename.substring(3, NOT_FOUND + separatorAdd).charAt(0) == 0)",
          "z3Program": "from z3 import *\nfrom z3_all_models import *\n\nfilename0 = String('filename0')\nseparatorAdd0 = Int('separatorAdd0')\nprefix0 = Int('prefix0')\nendIndex0 = Int('endIndex0')\nNOT_FOUND0 = Int('NOT_FOUND0')\nindex0 = Int('index0')\nfilename0_isNull = Bool('filename0_isNull')\n\nconstraints = [\n  prefix0 == 3,\n  endIndex0 == index + separatorAdd0,\n  NOT_FOUND0 == -1,\n  index0 == NOT_FOUND0,\n  ch00 == Character.toUpperCase(ch0),\n  And(And(And(And(And(And(And(And(And(And(And(And(And(Not(filename0_isNull), Not(filename0_isNull)), Not(Length(filename0) == 0)), Not(Character.toUpperCase(Character.toUpperCase(ch00)) == ':')), Not(Length(filename0) == 1)), Not(Character.toUpperCase(Character.toUpperCase(ch00)) == '~')), filename0.charAt(1) == ':'), And(Character.toUpperCase(Character.toUpperCase(ch00)) >= 'A', Character.toUpperCase(Character.toUpperCase(ch00)) <= 'Z')), Not(Or(Or(Length(filename0) == 2, filename0.charAt(2) == '/'), filename0.charAt(2) == '\\\\' == False))), Not(3 < 0)), filename0_isNull), Not(Or(Or(3 >= Length(filename0), NOT_FOUND0 < 0), 3 >= index0 + separatorAdd0))), 0 < filename0.substring(prefix0, endIndex0).length()), filename0.substring(prefix0, endIndex0).charAt(0) == 0)\n]\n\nsolver = Solver()\nfor constraint in constraints:\n  solver.add(constraint)\n\nmodels = list(all_smt(solver))\nfor model in models: print(model)",
          "symPyProgram": "from sympy import Symbol\nfrom sympy import simplify\nfrom sympy.core.relational import Eq, Ne, StrictGreaterThan, StrictLessThan, LessThan, GreaterThan\nfrom sympy.printing import ccode\n\nfilename = Symbol('filename')\nseparatorAdd = Symbol('separatorAdd', integer=True)\nfilename_length = Symbol('filename_length')\nCharacter_toUpperCase = Symbol('Character_toUpperCase')\nfilename_charAt = Symbol('filename_charAt')\nfilename_substring_length = Symbol('filename_substring_length')\nfilename_substring = Symbol('filename_substring')\nfilename_substring_charAt = Symbol('filename_substring_charAt')\nnull = Symbol('null')\nwit_str_0 = Symbol('wit_str_0') # ':'\nwit_str_1 = Symbol('wit_str_1') # '~'\nwit_str_2 = Symbol('wit_str_2') # ':'\nwit_str_3 = Symbol('wit_str_3') # 'A'\nwit_str_4 = Symbol('wit_str_4') # 'Z'\nwit_str_5 = Symbol('wit_str_5') # '/'\nwit_str_6 = Symbol('wit_str_6') # '\\\\'\npath_conjunction = ((((((((((((((~((Eq(filename, null)))) & (~((Eq(filename, null))))) & (~((Eq(filename_length, 0))))) & (~((Eq(Character_toUpperCase, wit_str_0))))) & (~((Eq(filename_length, 1))))) & (~((Eq(Character_toUpperCase, wit_str_1))))) & (Eq(filename_charAt, wit_str_2))) & ((GreaterThan(Character_toUpperCase, wit_str_3)) & (LessThan(Character_toUpperCase, wit_str_4)))) & (~((((Eq(filename_length, 2)) | (Eq(filename_charAt, wit_str_5))) | (~((Eq(filename_charAt, wit_str_6)))))))) & (~((StrictLessThan(3, 0))))) & (Eq(filename, null))) & (~((((GreaterThan(3, filename_length)) | (StrictLessThan(-1, 0))) | (GreaterThan(3, (NOT_FOUND + separatorAdd))))))) & (StrictLessThan(0, filename_substring_length))) & (Eq(filename_substring_charAt, 0)))\nprint(ccode(simplify(path_conjunction)))",
          "soundSymbolic": true,
          "soundBackwards": false,
          "maybe": true,
          "line": 803,
          "throwingLine": 804,
          "isStatic": true,
          "targetOnlyArguments": false
        },
        {
          "qualifiedSignature": "org.apache.commons.io.FilenameUtils.getPathNoEndSeparator(java.lang.String)",
          "exception": "throw new IllegalArgumentException(\"Null byte present in file/path name. There are no \" + \"known legitimate use cases for such data, but several injection attacks may use it\")",
          "pathCojunction": "(!(filename == null)) && (filename == null) && (!(NOT_FOUND < 0)) && (filename == null) && (!(NOT_FOUND >= filename.length() || NOT_FOUND < 0 || NOT_FOUND >= index + separatorAdd)) && (0 < filename.substring(prefix, endIndex).length()) && (filename.substring(prefix, endIndex).charAt(0) == 0)",
          "symbolicPathConjunction": "((!(filename == null)) && (getPrefixLength(filename)) && (!(-1 < 0)) && (indexOfLastSeparator(filename)) && (!(prefix >= filename.length() || index < 0 || prefix >= endIndex)) && (failIfNullBytePresent(path)))",
          "backwardsPathConjunction": "(!(filename == null)) && (filename == null) && (!(NOT_FOUND < 0)) && (filename == null) && (!(NOT_FOUND >= filename.length() || NOT_FOUND < 0 || NOT_FOUND >= NOT_FOUND + separatorAdd)) && (0 < filename.substring(NOT_FOUND, NOT_FOUND + separatorAdd).length()) && (filename.substring(NOT_FOUND, NOT_FOUND + separatorAdd).charAt(0) == 0)",
          "z3Program": "from z3 import *\nfrom z3_all_models import *\n\nfilename0 = String('filename0')\nseparatorAdd0 = Int('separatorAdd0')\nprefix0 = Int('prefix0')\nendIndex0 = Int('endIndex0')\nNOT_FOUND0 = Int('NOT_FOUND0')\nindex0 = Int('index0')\nfilename0_isNull = Bool('filename0_isNull')\n\nconstraints = [\n  prefix0 == NOT_FOUND,\n  endIndex0 == index + separatorAdd0,\n  NOT_FOUND0 == -1,\n  index0 == NOT_FOUND0,\n  And(And(And(And(And(And(Not(filename0_isNull), filename0_isNull), Not(NOT_FOUND0 < 0)), filename0_isNull), Not(Or(Or(NOT_FOUND0 >= Length(filename0), NOT_FOUND0 < 0), NOT_FOUND0 >= index0 + separatorAdd0))), 0 < filename0.substring(prefix0, endIndex0).length()), filename0.substring(prefix0, endIndex0).charAt(0) == 0)\n]\n\nsolver = Solver()\nfor constraint in constraints:\n  solver.add(constraint)\n\nmodels = list(all_smt(solver))\nfor model in models: print(model)",
          "symPyProgram": "from sympy import Symbol\nfrom sympy import simplify\nfrom sympy.core.relational import Eq, Ne, StrictGreaterThan, StrictLessThan, LessThan, GreaterThan\nfrom sympy.printing import ccode\n\nfilename = Symbol('filename')\nseparatorAdd = Symbol('separatorAdd', integer=True)\nfilename_length = Symbol('filename_length')\nfilename_substring_length = Symbol('filename_substring_length')\nfilename_substring = Symbol('filename_substring')\nfilename_substring_charAt = Symbol('filename_substring_charAt')\nnull = Symbol('null')\npath_conjunction = (((((((~((Eq(filename, null)))) & (Eq(filename, null))) & (~((StrictLessThan(-1, 0))))) & (Eq(filename, null))) & (~((((GreaterThan(-1, filename_length)) | (StrictLessThan(-1, 0))) | (GreaterThan(-1, (NOT_FOUND + separatorAdd))))))) & (StrictLessThan(0, filename_substring_length))) & (Eq(filename_substring_charAt, 0)))\nprint(ccode(simplify(path_conjunction)))",
          "soundSymbolic": true,
          "soundBackwards": false,
          "maybe": true,
          "line": 831,
          "throwingLine": 832,
          "isStatic": true,
          "targetOnlyArguments": false
        },
        {
          "qualifiedSignature": "org.apache.commons.io.FilenameUtils.getPathNoEndSeparator(java.lang.String)",
          "exception": "throw new IllegalArgumentException(\"Null byte present in file/path name. There are no \" + \"known legitimate use cases for such data, but several injection attacks may use it\")",
          "pathCojunction": "(!(filename == null)) && (!(filename == null)) && (!(filename.length() == 0)) && (!(Character.toUpperCase(Character.toUpperCase(ch0)) == ':')) && (!(filename.length() == 1)) && (!(Character.toUpperCase(Character.toUpperCase(ch0)) == '~')) && (filename.charAt(1) == ':') && (Character.toUpperCase(Character.toUpperCase(ch0)) >= 'A' && Character.toUpperCase(Character.toUpperCase(ch0)) <= 'Z') && (!(filename.length() == 2 || filename.charAt(2) == '/' || filename.charAt(2) == '\\\\' == false)) && (!(3 < 0)) && (filename == null) && (!(3 >= filename.length() || NOT_FOUND < 0 || 3 >= index + separatorAdd)) && (0 < filename.substring(prefix, endIndex).length()) && (filename.substring(prefix, endIndex).charAt(0) == 0)",
          "symbolicPathConjunction": "((!(filename == null)) && (getPrefixLength(filename)) && (!(3 < 0)) && (indexOfLastSeparator(filename)) && (!(prefix >= filename.length() || index < 0 || prefix >= endIndex)) && (failIfNullBytePresent(path)))",
          "backwardsPathConjunction": "(!(filename == null)) && (!(filename == null)) && (!(filename.length() == 0)) && (!(Character.toUpperCase(Character.toUpperCase(Character.toUpperCase(Character.toUpperCase(ch0)))) == ':')) && (!(filename.length() == 1)) && (!(Character.toUpperCase(Character.toUpperCase(Character.toUpperCase(Character.toUpperCase(ch0)))) == '~')) && (filename.charAt(1) == ':') && (Character.toUpperCase(Character.toUpperCase(Character.toUpperCase(Character.toUpperCase(ch0)))) >= 'A' && Character.toUpperCase(Character.toUpperCase(Character.toUpperCase(Character.toUpperCase(ch0)))) <= 'Z') && (!(filename.length() == 2 || filename.charAt(2) == '/' || filename.charAt(2) == '\\\\' == false)) && (!(3 < 0)) && (filename == null) && (!(3 >= filename.length() || NOT_FOUND < 0 || 3 >= NOT_FOUND + separatorAdd)) && (0 < filename.substring(3, NOT_FOUND + separatorAdd).length()) && (filename.substring(3, NOT_FOUND + separatorAdd).charAt(0) == 0)",
          "z3Program": "from z3 import *\nfrom z3_all_models import *\n\nfilename0 = String('filename0')\nseparatorAdd0 = Int('separatorAdd0')\nprefix0 = Int('prefix0')\nendIndex0 = Int('endIndex0')\nNOT_FOUND0 = Int('NOT_FOUND0')\nindex0 = Int('index0')\nfilename0_isNull = Bool('filename0_isNull')\n\nconstraints = [\n  prefix0 == 3,\n  endIndex0 == index + separatorAdd0,\n  NOT_FOUND0 == -1,\n  index0 == NOT_FOUND0,\n  ch00 == Character.toUpperCase(ch0),\n  And(And(And(And(And(And(And(And(And(And(And(And(And(Not(filename0_isNull), Not(filename0_isNull)), Not(Length(filename0) == 0)), Not(Character.toUpperCase(Character.toUpperCase(ch00)) == ':')), Not(Length(filename0) == 1)), Not(Character.toUpperCase(Character.toUpperCase(ch00)) == '~')), filename0.charAt(1) == ':'), And(Character.toUpperCase(Character.toUpperCase(ch00)) >= 'A', Character.toUpperCase(Character.toUpperCase(ch00)) <= 'Z')), Not(Or(Or(Length(filename0) == 2, filename0.charAt(2) == '/'), filename0.charAt(2) == '\\\\' == False))), Not(3 < 0)), filename0_isNull), Not(Or(Or(3 >= Length(filename0), NOT_FOUND0 < 0), 3 >= index0 + separatorAdd0))), 0 < filename0.substring(prefix0, endIndex0).length()), filename0.substring(prefix0, endIndex0).charAt(0) == 0)\n]\n\nsolver = Solver()\nfor constraint in constraints:\n  solver.add(constraint)\n\nmodels = list(all_smt(solver))\nfor model in models: print(model)",
          "symPyProgram": "from sympy import Symbol\nfrom sympy import simplify\nfrom sympy.core.relational import Eq, Ne, StrictGreaterThan, StrictLessThan, LessThan, GreaterThan\nfrom sympy.printing import ccode\n\nfilename = Symbol('filename')\nseparatorAdd = Symbol('separatorAdd', integer=True)\nfilename_length = Symbol('filename_length')\nCharacter_toUpperCase = Symbol('Character_toUpperCase')\nfilename_charAt = Symbol('filename_charAt')\nfilename_substring_length = Symbol('filename_substring_length')\nfilename_substring = Symbol('filename_substring')\nfilename_substring_charAt = Symbol('filename_substring_charAt')\nnull = Symbol('null')\nwit_str_0 = Symbol('wit_str_0') # ':'\nwit_str_1 = Symbol('wit_str_1') # '~'\nwit_str_2 = Symbol('wit_str_2') # ':'\nwit_str_3 = Symbol('wit_str_3') # 'A'\nwit_str_4 = Symbol('wit_str_4') # 'Z'\nwit_str_5 = Symbol('wit_str_5') # '/'\nwit_str_6 = Symbol('wit_str_6') # '\\\\'\npath_conjunction = ((((((((((((((~((Eq(filename, null)))) & (~((Eq(filename, null))))) & (~((Eq(filename_length, 0))))) & (~((Eq(Character_toUpperCase, wit_str_0))))) & (~((Eq(filename_length, 1))))) & (~((Eq(Character_toUpperCase, wit_str_1))))) & (Eq(filename_charAt, wit_str_2))) & ((GreaterThan(Character_toUpperCase, wit_str_3)) & (LessThan(Character_toUpperCase, wit_str_4)))) & (~((((Eq(filename_length, 2)) | (Eq(filename_charAt, wit_str_5))) | (~((Eq(filename_charAt, wit_str_6)))))))) & (~((StrictLessThan(3, 0))))) & (Eq(filename, null))) & (~((((GreaterThan(3, filename_length)) | (StrictLessThan(-1, 0))) | (GreaterThan(3, (NOT_FOUND + separatorAdd))))))) & (StrictLessThan(0, filename_substring_length))) & (Eq(filename_substring_charAt, 0)))\nprint(ccode(simplify(path_conjunction)))",
          "soundSymbolic": true,
          "soundBackwards": false,
          "maybe": true,
          "line": 831,
          "throwingLine": 832,
          "isStatic": true,
          "targetOnlyArguments": false
        },
        {
          "qualifiedSignature": "org.apache.commons.io.FilenameUtils.getFullPath(java.lang.String)",
          "exception": "throw new IllegalArgumentException(\"Null byte present in file/path name. There are no \" + \"known legitimate use cases for such data, but several injection attacks may use it\")",
          "pathCojunction": "(!(filename == null)) && (!(filename == null)) && (!(filename.length() == 0)) && (!(Character.toUpperCase(Character.toUpperCase(ch0)) == ':')) && (!(filename.length() == 1)) && (!(Character.toUpperCase(Character.toUpperCase(ch0)) == '~')) && (filename.charAt(1) == ':') && (!(Character.toUpperCase(Character.toUpperCase(ch0)) >= 'A' && Character.toUpperCase(Character.toUpperCase(ch0)) <= 'Z')) && (!(Character.toUpperCase(Character.toUpperCase(ch0)) == '/')) && (!(NOT_FOUND < 0)) && (NOT_FOUND >= filename.length()) && (true) && (!(filename == null)) && (!(filename == null)) && (!(filename.length() == 0)) && (!(filename.charAt(0) == ':')) && (!(filename.length() == 1)) && (!(filename.charAt(0) == '~')) && (!(filename.charAt(1) == ':')) && (filename.charAt(0) == '/' || filename.charAt(0) == '\\\\' && filename.charAt(1) == '/' || filename.charAt(1) == '\\\\') && (filename.indexOf('/', 2) == -1 && filename.indexOf('\\\\', 2) == -1 || filename.indexOf('/', 2) == 2 || filename.indexOf('\\\\', 2) == 2) && (!(-1 < 0)) && (-1 > filename.length()) && (0 < path.length()) && (filename + '/'.charAt(0) == 0)",
          "symbolicPathConjunction": "((!(filename == null)) && (getPrefixLength(filename)) && (!(NOT_FOUND < 0)) && (prefix >= filename.length()) && (includeSeparator) && (getPrefix(filename)))",
          "backwardsPathConjunction": "(!(filename == null)) && (!(filename == null)) && (!(filename.length() == 0)) && (!(Character.toUpperCase(Character.toUpperCase(Character.toUpperCase(Character.toUpperCase(ch0)))) == ':')) && (!(filename.length() == 1)) && (!(Character.toUpperCase(Character.toUpperCase(Character.toUpperCase(Character.toUpperCase(ch0)))) == '~')) && (filename.charAt(1) == ':') && (!(Character.toUpperCase(Character.toUpperCase(Character.toUpperCase(Character.toUpperCase(ch0)))) >= 'A' && Character.toUpperCase(Character.toUpperCase(Character.toUpperCase(Character.toUpperCase(ch0)))) <= 'Z')) && (!(Character.toUpperCase(Character.toUpperCase(Character.toUpperCase(Character.toUpperCase(ch0)))) == '/')) && (!(NOT_FOUND < 0)) && (NOT_FOUND >= filename.length()) && (true) && (!(filename == null)) && (!(filename == null)) && (!(filename.length() == 0)) && (!(filename.charAt(0) == ':')) && (!(filename.length() == 1)) && (!(filename.charAt(0) == '~')) && (!(filename.charAt(1) == ':')) && (filename.charAt(0) == '/' || filename.charAt(0) == '\\\\' && filename.charAt(1) == '/' || filename.charAt(1) == '\\\\') && (filename.indexOf('/', 2) == -1 && filename.indexOf('\\\\', 2) == -1 || filename.indexOf('/', 2) == 2 || filename.indexOf('\\\\', 2) == 2) && (!(-1 < 0)) && (-1 > filename.length()) && (0 < path.length()) && (filename + '/'.charAt(0) == 0)",
          "z3Program": "from z3 import *\nfrom z3_all_models import *\n\nfilename0 = String('filename0')\npath0 = String('path0')\nNOT_FOUND0 = Int('NOT_FOUND0')\nfilename0_isNull = Bool('filename0_isNull')\n\nconstraints = [\n  NOT_FOUND0 == -1,\n  ch00 == Character.toUpperCase(ch0),\n  And(And(And(And(And(And(And(And(And(And(And(And(And(And(And(And(And(And(And(And(And(And(And(And(Not(filename0_isNull), Not(filename0_isNull)), Not(Length(filename0) == 0)), Not(Character.toUpperCase(Character.toUpperCase(ch00)) == ':')), Not(Length(filename0) == 1)), Not(Character.toUpperCase(Character.toUpperCase(ch00)) == '~')), filename0.charAt(1) == ':'), Not(And(Character.toUpperCase(Character.toUpperCase(ch00)) >= 'A', Character.toUpperCase(Character.toUpperCase(ch00)) <= 'Z'))), Not(Character.toUpperCase(Character.toUpperCase(ch00)) == '/')), Not(NOT_FOUND0 < 0)), NOT_FOUND0 >= Length(filename0)), True), Not(filename0_isNull)), Not(filename0_isNull)), Not(Length(filename0) == 0)), Not(filename0.charAt(0) == ':')), Not(Length(filename0) == 1)), Not(filename0.charAt(0) == '~')), Not(filename0.charAt(1) == ':')), Or(Or(filename0.charAt(0) == '/', And(filename0.charAt(0) == '\\\\', filename0.charAt(1) == '/')), filename0.charAt(1) == '\\\\')), Or(Or(And(filename0.indexOf('/', 2) == -1, filename0.indexOf('\\\\', 2) == -1), filename0.indexOf('/', 2) == 2), filename0.indexOf('\\\\', 2) == 2)), Not(-1 < 0)), -1 > Length(filename0)), 0 < Length(path0)), filename0 + '/'.charAt(0) == 0)\n]\n\nsolver = Solver()\nfor constraint in constraints:\n  solver.add(constraint)\n\nmodels = list(all_smt(solver))\nfor model in models: print(model)",
          "symPyProgram": "from sympy import Symbol\nfrom sympy import simplify\nfrom sympy.core.relational import Eq, Ne, StrictGreaterThan, StrictLessThan, LessThan, GreaterThan\nfrom sympy.printing import ccode\n\nfilename = Symbol('filename')\npath = Symbol('path')\nfilename_length = Symbol('filename_length')\nCharacter_toUpperCase = Symbol('Character_toUpperCase')\nfilename_charAt = Symbol('filename_charAt')\nfilename_indexOf = Symbol('filename_indexOf')\npath_length = Symbol('path_length')\n'/'_charAt = Symbol(''/'_charAt')\nnull = Symbol('null')\nwit_str_0 = Symbol('wit_str_0') # ':'\nwit_str_1 = Symbol('wit_str_1') # '~'\nwit_str_2 = Symbol('wit_str_2') # ':'\nwit_str_3 = Symbol('wit_str_3') # 'A'\nwit_str_4 = Symbol('wit_str_4') # 'Z'\nwit_str_5 = Symbol('wit_str_5') # '/'\nwit_str_6 = Symbol('wit_str_6') # ':'\nwit_str_7 = Symbol('wit_str_7') # '~'\nwit_str_8 = Symbol('wit_str_8') # ':'\nwit_str_9 = Symbol('wit_str_9') # '/'\nwit_str_10 = Symbol('wit_str_10') # '\\\\'\nwit_str_11 = Symbol('wit_str_11') # '/'\nwit_str_12 = Symbol('wit_str_12') # '\\\\'\npath_conjunction = (((((((((((((((((((((((((~((Eq(filename, null)))) & (~((Eq(filename, null))))) & (~((Eq(filename_length, 0))))) & (~((Eq(Character_toUpperCase, wit_str_0))))) & (~((Eq(filename_length, 1))))) & (~((Eq(Character_toUpperCase, wit_str_1))))) & (Eq(filename_charAt, wit_str_2))) & (~(((GreaterThan(Character_toUpperCase, wit_str_3)) & (LessThan(Character_toUpperCase, wit_str_4)))))) & (~((Eq(Character_toUpperCase, wit_str_5))))) & (~((StrictLessThan(-1, 0))))) & (GreaterThan(-1, filename_length))) & True) & (~((Eq(filename, null))))) & (~((Eq(filename, null))))) & (~((Eq(filename_length, 0))))) & (~((Eq(filename_charAt, wit_str_6))))) & (~((Eq(filename_length, 1))))) & (~((Eq(filename_charAt, wit_str_7))))) & (~((Eq(filename_charAt, wit_str_8))))) & (((Eq(filename_charAt, wit_str_9)) | ((Eq(filename_charAt, wit_str_10)) & (Eq(filename_charAt, wit_str_11)))) | (Eq(filename_charAt, wit_str_12)))) & ((((Eq(filename_indexOf, -1)) & (Eq(filename_indexOf, -1))) | (Eq(filename_indexOf, 2))) | (Eq(filename_indexOf, 2)))) & (~((StrictLessThan(-1, 0))))) & (StrictGreaterThan(-1, filename_length))) & (StrictLessThan(0, path_length))) & (Eq((filename + '/'_charAt), 0)))\nprint(ccode(simplify(path_conjunction)))",
          "soundSymbolic": true,
          "soundBackwards": false,
          "maybe": true,
          "line": 885,
          "throwingLine": 886,
          "isStatic": true,
          "targetOnlyArguments": false
        },
        {
          "qualifiedSignature": "org.apache.commons.io.FilenameUtils.getFullPath(java.lang.String)",
          "exception": "throw new IllegalArgumentException(\"Null byte present in file/path name. There are no \" + \"known legitimate use cases for such data, but several injection attacks may use it\")",
          "pathCojunction": "(!(filename == null)) && (!(filename == null)) && (!(filename.length() == 0)) && (!(filename.charAt(0) == ':')) && (!(filename.length() == 1)) && (!(filename.charAt(0) == '~')) && (!(filename.charAt(1) == ':')) && (!(filename.charAt(0) == '/' || filename.charAt(0) == '\\\\' && filename.charAt(1) == '/' || filename.charAt(1) == '\\\\')) && (!(filename.charAt(0) == '/' || filename.charAt(0) == '\\\\')) && (!(0 < 0)) && (0 >= filename.length()) && (true) && (!(filename == null)) && (!(filename == null)) && (!(filename.length() == 0)) && (!(Character.toUpperCase(Character.toUpperCase(Character.toUpperCase(ch0))) == ':')) && (!(filename.length() == 1)) && (!(Character.toUpperCase(Character.toUpperCase(Character.toUpperCase(ch0))) == '~')) && (filename.charAt(1) == ':') && (Character.toUpperCase(Character.toUpperCase(Character.toUpperCase(ch0))) >= 'A' && Character.toUpperCase(Character.toUpperCase(Character.toUpperCase(ch0))) <= 'Z') && (filename.length() == 2 || filename.charAt(2) == '/' || filename.charAt(2) == '\\\\' == false) && (!(2 < 0)) && (!(2 > filename.length())) && (0 < filename.substring(0, 2).length()) && (filename.substring(0, 2).charAt(0) == 0)",
          "symbolicPathConjunction": "((!(filename == null)) && (getPrefixLength(filename)) && (!(0 < 0)) && (prefix >= filename.length()) && (includeSeparator) && (getPrefix(filename)))",
          "backwardsPathConjunction": "(!(filename == null)) && (!(filename == null)) && (!(filename.length() == 0)) && (!(filename.charAt(0) == ':')) && (!(filename.length() == 1)) && (!(filename.charAt(0) == '~')) && (!(filename.charAt(1) == ':')) && (!(filename.charAt(0) == '/' || filename.charAt(0) == '\\\\' && filename.charAt(1) == '/' || filename.charAt(1) == '\\\\')) && (!(filename.charAt(0) == '/' || filename.charAt(0) == '\\\\')) && (!(0 < 0)) && (0 >= filename.length()) && (true) && (!(filename == null)) && (!(filename == null)) && (!(filename.length() == 0)) && (!(Character.toUpperCase(Character.toUpperCase(Character.toUpperCase(Character.toUpperCase(Character.toUpperCase(ch0))))) == ':')) && (!(filename.length() == 1)) && (!(Character.toUpperCase(Character.toUpperCase(Character.toUpperCase(Character.toUpperCase(Character.toUpperCase(ch0))))) == '~')) && (filename.charAt(1) == ':') && (Character.toUpperCase(Character.toUpperCase(Character.toUpperCase(Character.toUpperCase(Character.toUpperCase(ch0))))) >= 'A' && Character.toUpperCase(Character.toUpperCase(Character.toUpperCase(Character.toUpperCase(Character.toUpperCase(ch0))))) <= 'Z') && (filename.length() == 2 || filename.charAt(2) == '/' || filename.charAt(2) == '\\\\' == false) && (!(2 < 0)) && (!(2 > filename.length())) && (0 < filename.substring(0, 2).length()) && (filename.substring(0, 2).charAt(0) == 0)",
          "z3Program": "from z3 import *\nfrom z3_all_models import *\n\nfilename0 = String('filename0')\nfilename0_isNull = Bool('filename0_isNull')\n\nconstraints = [\n  ch00 == Character.toUpperCase(ch0),\n  And(And(And(And(And(And(And(And(And(And(And(And(And(And(And(And(And(And(And(And(And(And(And(And(Not(filename0_isNull), Not(filename0_isNull)), Not(Length(filename0) == 0)), Not(filename0.charAt(0) == ':')), Not(Length(filename0) == 1)), Not(filename0.charAt(0) == '~')), Not(filename0.charAt(1) == ':')), Not(Or(Or(filename0.charAt(0) == '/', And(filename0.charAt(0) == '\\\\', filename0.charAt(1) == '/')), filename0.charAt(1) == '\\\\'))), Not(Or(filename0.charAt(0) == '/', filename0.charAt(0) == '\\\\'))), Not(0 < 0)), 0 >= Length(filename0)), True), Not(filename0_isNull)), Not(filename0_isNull)), Not(Length(filename0) == 0)), Not(Character.toUpperCase(Character.toUpperCase(Character.toUpperCase(ch00))) == ':')), Not(Length(filename0) == 1)), Not(Character.toUpperCase(Character.toUpperCase(Character.toUpperCase(ch00))) == '~')), filename0.charAt(1) == ':'), And(Character.toUpperCase(Character.toUpperCase(Character.toUpperCase(ch00))) >= 'A', Character.toUpperCase(Character.toUpperCase(Character.toUpperCase(ch00))) <= 'Z')), Or(Or(Length(filename0) == 2, filename0.charAt(2) == '/'), filename0.charAt(2) == '\\\\' == False)), Not(2 < 0)), Not(2 > Length(filename0))), 0 < filename0.substring(0, 2).length()), filename0.substring(0, 2).charAt(0) == 0)\n]\n\nsolver = Solver()\nfor constraint in constraints:\n  solver.add(constraint)\n\nmodels = list(all_smt(solver))\nfor model in models: print(model)",
          "symPyProgram": "from sympy import Symbol\nfrom sympy import simplify\nfrom sympy.core.relational import Eq, Ne, StrictGreaterThan, StrictLessThan, LessThan, GreaterThan\nfrom sympy.printing import ccode\n\nfilename = Symbol('filename')\nfilename_length = Symbol('filename_length')\nfilename_charAt = Symbol('filename_charAt')\nCharacter_toUpperCase = Symbol('Character_toUpperCase')\nfilename_substring_length = Symbol('filename_substring_length')\nfilename_substring = Symbol('filename_substring')\nfilename_substring_charAt = Symbol('filename_substring_charAt')\nnull = Symbol('null')\nwit_str_0 = Symbol('wit_str_0') # ':'\nwit_str_1 = Symbol('wit_str_1') # '~'\nwit_str_2 = Symbol('wit_str_2') # ':'\nwit_str_3 = Symbol('wit_str_3') # '/'\nwit_str_4 = Symbol('wit_str_4') # '\\\\'\nwit_str_5 = Symbol('wit_str_5') # '/'\nwit_str_6 = Symbol('wit_str_6') # '\\\\'\nwit_str_7 = Symbol('wit_str_7') # '/'\nwit_str_8 = Symbol('wit_str_8') # '\\\\'\nwit_str_9 = Symbol('wit_str_9') # ':'\nwit_str_10 = Symbol('wit_str_10') # '~'\nwit_str_11 = Symbol('wit_str_11') # ':'\nwit_str_12 = Symbol('wit_str_12') # 'A'\nwit_str_13 = Symbol('wit_str_13') # 'Z'\nwit_str_14 = Symbol('wit_str_14') # '/'\nwit_str_15 = Symbol('wit_str_15') # '\\\\'\npath_conjunction = (((((((((((((((((((((((((~((Eq(filename, null)))) & (~((Eq(filename, null))))) & (~((Eq(filename_length, 0))))) & (~((Eq(filename_charAt, wit_str_0))))) & (~((Eq(filename_length, 1))))) & (~((Eq(filename_charAt, wit_str_1))))) & (~((Eq(filename_charAt, wit_str_2))))) & (~((((Eq(filename_charAt, wit_str_3)) | ((Eq(filename_charAt, wit_str_4)) & (Eq(filename_charAt, wit_str_5)))) | (Eq(filename_charAt, wit_str_6)))))) & (~(((Eq(filename_charAt, wit_str_7)) | (Eq(filename_charAt, wit_str_8)))))) & (~((StrictLessThan(0, 0))))) & (GreaterThan(0, filename_length))) & True) & (~((Eq(filename, null))))) & (~((Eq(filename, null))))) & (~((Eq(filename_length, 0))))) & (~((Eq(Character_toUpperCase, wit_str_9))))) & (~((Eq(filename_length, 1))))) & (~((Eq(Character_toUpperCase, wit_str_10))))) & (Eq(filename_charAt, wit_str_11))) & ((GreaterThan(Character_toUpperCase, wit_str_12)) & (LessThan(Character_toUpperCase, wit_str_13)))) & (((Eq(filename_length, 2)) | (Eq(filename_charAt, wit_str_14))) | (~((Eq(filename_charAt, wit_str_15)))))) & (~((StrictLessThan(2, 0))))) & (~((StrictGreaterThan(2, filename_length))))) & (StrictLessThan(0, filename_substring_length))) & (Eq(filename_substring_charAt, 0)))\nprint(ccode(simplify(path_conjunction)))",
          "soundSymbolic": true,
          "soundBackwards": false,
          "maybe": true,
          "line": 885,
          "throwingLine": 886,
          "isStatic": true,
          "targetOnlyArguments": false
        },
        {
          "qualifiedSignature": "org.apache.commons.io.FilenameUtils.getFullPathNoEndSeparator(java.lang.String)",
          "exception": "throw new IllegalArgumentException(\"Null byte present in file/path name. There are no \" + \"known legitimate use cases for such data, but several injection attacks may use it\")",
          "pathCojunction": "(!(filename == null)) && (!(filename == null)) && (!(filename.length() == 0)) && (!(filename.charAt(0) == ':')) && (!(filename.length() == 1)) && (filename.charAt(0) == '~') && (filename.indexOf('/', 1) == -1 && filename.indexOf('\\\\', 1) == -1) && (!(filename.length() + 1 < 0)) && (filename.length() + 1 >= filename.length()) && (false) && (!(filename == null)) && (!(filename == null)) && (!(filename.length() == 0)) && (!(filename.charAt(0) == ':')) && (!(filename.length() == 1)) && (!(filename.charAt(0) == '~')) && (!(filename.charAt(1) == ':')) && (!(filename.charAt(0) == '/' || filename.charAt(0) == '\\\\' && filename.charAt(1) == '/' || filename.charAt(1) == '\\\\')) && (!(filename.charAt(0) == '/' || filename.charAt(0) == '\\\\')) && (!(0 < 0)) && (0 > filename.length()) && (0 < path.length()) && (filename + '/'.charAt(0) == 0)",
          "symbolicPathConjunction": "((!(filename == null)) && (getPrefixLength(filename)) && (!(filename.length() + 1 < 0)) && (prefix >= filename.length()) && (includeSeparator) && (getPrefix(filename)))",
          "backwardsPathConjunction": "(!(filename == null)) && (!(filename == null)) && (!(filename.length() == 0)) && (!(filename.charAt(0) == ':')) && (!(filename.length() == 1)) && (filename.charAt(0) == '~') && (filename.indexOf('/', 1) == -1 && filename.indexOf('\\\\', 1) == -1) && (!(filename.length() + 1 < 0)) && (filename.length() + 1 >= filename.length()) && (false) && (!(filename == null)) && (!(filename == null)) && (!(filename.length() == 0)) && (!(filename.charAt(0) == ':')) && (!(filename.length() == 1)) && (!(filename.charAt(0) == '~')) && (!(filename.charAt(1) == ':')) && (!(filename.charAt(0) == '/' || filename.charAt(0) == '\\\\' && filename.charAt(1) == '/' || filename.charAt(1) == '\\\\')) && (!(filename.charAt(0) == '/' || filename.charAt(0) == '\\\\')) && (!(0 < 0)) && (0 > filename.length()) && (0 < path.length()) && (filename + '/'.charAt(0) == 0)",
          "z3Program": "from z3 import *\nfrom z3_all_models import *\n\nfilename0 = String('filename0')\npath0 = String('path0')\nfilename0_isNull = Bool('filename0_isNull')\n\nconstraints = [\n  And(And(And(And(And(And(And(And(And(And(And(And(And(And(And(And(And(And(And(And(And(And(Not(filename0_isNull), Not(filename0_isNull)), Not(Length(filename0) == 0)), Not(filename0.charAt(0) == ':')), Not(Length(filename0) == 1)), filename0.charAt(0) == '~'), And(filename0.indexOf('/', 1) == -1, filename0.indexOf('\\\\', 1) == -1)), Not(Length(filename0) + 1 < 0)), Length(filename0) + 1 >= Length(filename0)), False), Not(filename0_isNull)), Not(filename0_isNull)), Not(Length(filename0) == 0)), Not(filename0.charAt(0) == ':')), Not(Length(filename0) == 1)), Not(filename0.charAt(0) == '~')), Not(filename0.charAt(1) == ':')), Not(Or(Or(filename0.charAt(0) == '/', And(filename0.charAt(0) == '\\\\', filename0.charAt(1) == '/')), filename0.charAt(1) == '\\\\'))), Not(Or(filename0.charAt(0) == '/', filename0.charAt(0) == '\\\\'))), Not(0 < 0)), 0 > Length(filename0)), 0 < Length(path0)), filename0 + '/'.charAt(0) == 0)\n]\n\nsolver = Solver()\nfor constraint in constraints:\n  solver.add(constraint)\n\nmodels = list(all_smt(solver))\nfor model in models: print(model)",
          "symPyProgram": "from sympy import Symbol\nfrom sympy import simplify\nfrom sympy.core.relational import Eq, Ne, StrictGreaterThan, StrictLessThan, LessThan, GreaterThan\nfrom sympy.printing import ccode\n\nfilename = Symbol('filename')\npath = Symbol('path')\nfilename_length = Symbol('filename_length')\nfilename_charAt = Symbol('filename_charAt')\nfilename_indexOf = Symbol('filename_indexOf')\npath_length = Symbol('path_length')\n'/'_charAt = Symbol(''/'_charAt')\nnull = Symbol('null')\nwit_str_0 = Symbol('wit_str_0') # ':'\nwit_str_1 = Symbol('wit_str_1') # '~'\nwit_str_2 = Symbol('wit_str_2') # ':'\nwit_str_3 = Symbol('wit_str_3') # '~'\nwit_str_4 = Symbol('wit_str_4') # ':'\nwit_str_5 = Symbol('wit_str_5') # '/'\nwit_str_6 = Symbol('wit_str_6') # '\\\\'\nwit_str_7 = Symbol('wit_str_7') # '/'\nwit_str_8 = Symbol('wit_str_8') # '\\\\'\nwit_str_9 = Symbol('wit_str_9') # '/'\nwit_str_10 = Symbol('wit_str_10') # '\\\\'\npath_conjunction = (((((((((((((((((((((((~((Eq(filename, null)))) & (~((Eq(filename, null))))) & (~((Eq(filename_length, 0))))) & (~((Eq(filename_charAt, wit_str_0))))) & (~((Eq(filename_length, 1))))) & (Eq(filename_charAt, wit_str_1))) & ((Eq(filename_indexOf, -1)) & (Eq(filename_indexOf, -1)))) & (~((StrictLessThan((filename_length + 1), 0))))) & (GreaterThan((filename_length + 1), filename_length))) & False) & (~((Eq(filename, null))))) & (~((Eq(filename, null))))) & (~((Eq(filename_length, 0))))) & (~((Eq(filename_charAt, wit_str_2))))) & (~((Eq(filename_length, 1))))) & (~((Eq(filename_charAt, wit_str_3))))) & (~((Eq(filename_charAt, wit_str_4))))) & (~((((Eq(filename_charAt, wit_str_5)) | ((Eq(filename_charAt, wit_str_6)) & (Eq(filename_charAt, wit_str_7)))) | (Eq(filename_charAt, wit_str_8)))))) & (~(((Eq(filename_charAt, wit_str_9)) | (Eq(filename_charAt, wit_str_10)))))) & (~((StrictLessThan(0, 0))))) & (StrictGreaterThan(0, filename_length))) & (StrictLessThan(0, path_length))) & (Eq((filename + '/'_charAt), 0)))\nprint(ccode(simplify(path_conjunction)))",
          "soundSymbolic": true,
          "soundBackwards": false,
          "maybe": true,
          "line": 915,
          "throwingLine": 916,
          "isStatic": true,
          "targetOnlyArguments": false
        },
        {
          "qualifiedSignature": "org.apache.commons.io.FilenameUtils.getName(java.lang.String)",
          "exception": "throw new IllegalArgumentException(\"Null byte present in file/path name. There are no \" + \"known legitimate use cases for such data, but several injection attacks may use it\")",
          "pathCojunction": "(!(filename == null)) && (0 < path.length()) && (filename.charAt(0) == 0)",
          "symbolicPathConjunction": "(!(filename == null)) && (!(0 < path.length()) && (path.charAt(0) == 0))",
          "backwardsPathConjunction": "(!(filename == null)) && (0 < path.length()) && (filename.charAt(0) == 0)",
          "simplifiedPathConjunction": "filename.charAt(0) == 0 && path.length() > 0 && filename != null",
          "z3Program": "from z3 import *\nfrom z3_all_models import *\n\nfilename0 = String('filename0')\npath0 = String('path0')\nfilename0_isNull = Bool('filename0_isNull')\n\nconstraints = [\n  And(And(Not(filename0_isNull), 0 < Length(path0)), filename0.charAt(0) == 0)\n]\n\nsolver = Solver()\nfor constraint in constraints:\n  solver.add(constraint)\n\nmodels = list(all_smt(solver))\nfor model in models: print(model)",
          "symPyProgram": "from sympy import Symbol\nfrom sympy import simplify\nfrom sympy.core.relational import Eq, Ne, StrictGreaterThan, StrictLessThan, LessThan, GreaterThan\nfrom sympy.printing import ccode\n\nfilename = Symbol('filename')\npath = Symbol('path')\npath_length = Symbol('path_length')\nfilename_charAt = Symbol('filename_charAt')\nnull = Symbol('null')\npath_conjunction = (((~((Eq(filename, null)))) & (StrictLessThan(0, path_length))) & (Eq(filename_charAt, 0)))\nprint(ccode(simplify(path_conjunction)))",
          "soundSymbolic": true,
          "soundBackwards": false,
          "maybe": true,
          "line": 970,
          "throwingLine": 974,
          "isStatic": true,
          "targetOnlyArguments": false
        },
        {
          "qualifiedSignature": "org.apache.commons.io.FilenameUtils.removeExtension(java.lang.String)",
          "exception": "throw new IllegalArgumentException(\"Null byte present in file/path name. There are no \" + \"known legitimate use cases for such data, but several injection attacks may use it\")",
          "pathCojunction": "(!(filename == null)) && (0 < path.length()) && (filename.charAt(0) == 0)",
          "symbolicPathConjunction": "(!(filename == null)) && (!(0 < path.length()) && (path.charAt(0) == 0))",
          "backwardsPathConjunction": "(!(filename == null)) && (0 < path.length()) && (filename.charAt(0) == 0)",
          "simplifiedPathConjunction": "filename.charAt(0) == 0 && path.length() > 0 && filename != null",
          "z3Program": "from z3 import *\nfrom z3_all_models import *\n\nfilename0 = String('filename0')\npath0 = String('path0')\nfilename0_isNull = Bool('filename0_isNull')\n\nconstraints = [\n  And(And(Not(filename0_isNull), 0 < Length(path0)), filename0.charAt(0) == 0)\n]\n\nsolver = Solver()\nfor constraint in constraints:\n  solver.add(constraint)\n\nmodels = list(all_smt(solver))\nfor model in models: print(model)",
          "symPyProgram": "from sympy import Symbol\nfrom sympy import simplify\nfrom sympy.core.relational import Eq, Ne, StrictGreaterThan, StrictLessThan, LessThan, GreaterThan\nfrom sympy.printing import ccode\n\nfilename = Symbol('filename')\npath = Symbol('path')\npath_length = Symbol('path_length')\nfilename_charAt = Symbol('filename_charAt')\nnull = Symbol('null')\npath_conjunction = (((~((Eq(filename, null)))) & (StrictLessThan(0, path_length))) & (Eq(filename_charAt, 0)))\nprint(ccode(simplify(path_conjunction)))",
          "soundSymbolic": true,
          "soundBackwards": false,
          "maybe": true,
          "line": 1065,
          "throwingLine": 1069,
          "isStatic": true,
          "targetOnlyArguments": false
        },
        {
          "qualifiedSignature": "org.apache.commons.io.FilenameUtils.isExtension(java.lang.String, java.lang.String)",
          "exception": "throw new IllegalArgumentException(\"Null byte present in file/path name. There are no \" + \"known legitimate use cases for such data, but several injection attacks may use it\")",
          "pathCojunction": "(!(filename == null)) && (0 < path.length()) && (filename.charAt(0) == 0)",
          "symbolicPathConjunction": "(!(filename == null)) && (!(0 < path.length()) && (path.charAt(0) == 0))",
          "backwardsPathConjunction": "(!(filename == null)) && (0 < path.length()) && (filename.charAt(0) == 0)",
          "simplifiedPathConjunction": "filename.charAt(0) == 0 && path.length() > 0 && filename != null",
          "z3Program": "from z3 import *\nfrom z3_all_models import *\n\nfilename0 = String('filename0')\nextension0 = String('extension0')\npath0 = String('path0')\nfilename0_isNull = Bool('filename0_isNull')\n\nconstraints = [\n  And(And(Not(filename0_isNull), 0 < Length(path0)), filename0.charAt(0) == 0)\n]\n\nsolver = Solver()\nfor constraint in constraints:\n  solver.add(constraint)\n\nmodels = list(all_smt(solver))\nfor model in models: print(model)",
          "symPyProgram": "from sympy import Symbol\nfrom sympy import simplify\nfrom sympy.core.relational import Eq, Ne, StrictGreaterThan, StrictLessThan, LessThan, GreaterThan\nfrom sympy.printing import ccode\n\nfilename = Symbol('filename')\npath = Symbol('path')\npath_length = Symbol('path_length')\nfilename_charAt = Symbol('filename_charAt')\nnull = Symbol('null')\npath_conjunction = (((~((Eq(filename, null)))) & (StrictLessThan(0, path_length))) & (Eq(filename_charAt, 0)))\nprint(ccode(simplify(path_conjunction)))",
          "soundSymbolic": true,
          "soundBackwards": false,
          "maybe": true,
          "line": 1188,
          "throwingLine": 1192,
          "isStatic": true,
          "targetOnlyArguments": false
        }
      ]
    },
    {
      "path": "/home/yanghengqin/commons-io-commons-io-2.6/src/main/java/org/apache/commons/io/input/NullInputStream.java",
      "methods": [
        {
          "qualifiedSignature": "org.apache.commons.io.input.NullInputStream.mark(int)",
          "exception": "throw new UnsupportedOperationException(\"Mark not supported\");",
          "pathCojunction": "(!(markSupported))",
          "symbolicPathConjunction": "(!(markSupported))",
          "backwardsPathConjunction": "(!(markSupported))",
          "simplifiedPathConjunction": "!markSupported",
          "z3Inputs": "[markSupported0 = False]\n",
          "z3Program": "from z3 import *\nfrom z3_all_models import *\n\nreadlimit0 = Int('readlimit0')\nmarkSupported0 = Bool('markSupported0')\n\nconstraints = [\n  Not(markSupported0)\n]\n\nsolver = Solver()\nfor constraint in constraints:\n  solver.add(constraint)\n\nmodels = list(all_smt(solver))\nfor model in models: print(model)",
          "symPyProgram": "from sympy import Symbol\nfrom sympy import simplify\nfrom sympy.core.relational import Eq, Ne, StrictGreaterThan, StrictLessThan, LessThan, GreaterThan\nfrom sympy.printing import ccode\n\nmarkSupported = Symbol('markSupported')\npath_conjunction = (~(markSupported))\nprint(ccode(simplify(path_conjunction)))",
          "soundSymbolic": true,
          "soundBackwards": true,
          "maybe": false,
          "line": 158,
          "throwingLine": 160,
          "isStatic": false,
          "targetOnlyArguments": false
        },
        {
          "qualifiedSignature": "org.apache.commons.io.input.NullInputStream.read()",
          "exception": "throw new IOException(\"Read after end of file\");",
          "pathCojunction": "(eof)",
          "symbolicPathConjunction": "(eof)",
          "backwardsPathConjunction": "(eof)",
          "simplifiedPathConjunction": "eof",
          "z3Inputs": "[eof0 = True]\n",
          "z3Program": "from z3 import *\nfrom z3_all_models import *\n\neof0 = Bool('eof0')\n\nconstraints = [\n  eof0\n]\n\nsolver = Solver()\nfor constraint in constraints:\n  solver.add(constraint)\n\nmodels = list(all_smt(solver))\nfor model in models: print(model)",
          "symPyProgram": "from sympy import Symbol\nfrom sympy import simplify\nfrom sympy.core.relational import Eq, Ne, StrictGreaterThan, StrictLessThan, LessThan, GreaterThan\nfrom sympy.printing import ccode\n\neof = Symbol('eof')\npath_conjunction = eof\nprint(ccode(simplify(path_conjunction)))",
          "soundSymbolic": true,
          "soundBackwards": true,
          "maybe": false,
          "line": 187,
          "throwingLine": 189,
          "isStatic": false,
          "targetOnlyArguments": false
        },
        {
          "qualifiedSignature": "org.apache.commons.io.input.NullInputStream.read()",
          "exception": "throw new EOFException();",
          "pathCojunction": "(!(eof)) && (position == size) && (throwEofException)",
          "symbolicPathConjunction": "(!(eof)) && (position == size) && (throwEofException)",
          "backwardsPathConjunction": "(!(eof)) && (position == size) && (throwEofException)",
          "simplifiedPathConjunction": "throwEofException && position == size && !eof",
          "z3Inputs": "[size0 = -9223372036854775808,\n throwEofException0 = True,\n position0 = -9223372036854775808,\n eof0 = False]\n[eof0 = False,\n position0 = 0,\n throwEofException0 = True,\n size0 = 0]\n[eof0 = False,\n position0 = -1,\n throwEofException0 = True,\n size0 = -1]\n[eof0 = False,\n position0 = -2,\n throwEofException0 = True,\n size0 = -2]\n[eof0 = False,\n position0 = -3,\n throwEofException0 = True,\n size0 = -3]\n[eof0 = False,\n position0 = -4,\n throwEofException0 = True,\n size0 = -4]\n[eof0 = False,\n position0 = -5,\n throwEofException0 = True,\n size0 = -5]\n[eof0 = False,\n position0 = -6,\n throwEofException0 = True,\n size0 = -6]\n[eof0 = False,\n position0 = -7,\n throwEofException0 = True,\n size0 = -7]\n[eof0 = False,\n position0 = -8,\n throwEofException0 = True,\n size0 = -8]\n",
          "z3Program": "from z3 import *\nfrom z3_all_models import *\n\neof0 = Bool('eof0')\nposition0 = Int('position0')\nsize0 = Int('size0')\nthrowEofException0 = Bool('throwEofException0')\n\nconstraints = [\n  position0 >= -9223372036854775808, position0 <= 9223372036854775807, # implicit\n  size0 >= -9223372036854775808, size0 <= 9223372036854775807, # implicit\n  And(And(Not(eof0), position0 == size0), throwEofException0)\n]\n\nsolver = Solver()\nfor constraint in constraints:\n  solver.add(constraint)\n\nmodels = list(all_smt(solver))\nfor model in models: print(model)",
          "symPyProgram": "from sympy import Symbol\nfrom sympy import simplify\nfrom sympy.core.relational import Eq, Ne, StrictGreaterThan, StrictLessThan, LessThan, GreaterThan\nfrom sympy.printing import ccode\n\neof = Symbol('eof')\nposition = Symbol('position')\nsize = Symbol('size')\nthrowEofException = Symbol('throwEofException')\npath_conjunction = (((~(eof)) & (Eq(position, size))) & throwEofException)\nprint(ccode(simplify(path_conjunction)))",
          "soundSymbolic": true,
          "soundBackwards": true,
          "maybe": false,
          "line": 187,
          "throwingLine": 192,
          "isStatic": false,
          "targetOnlyArguments": false
        },
        {
          "qualifiedSignature": "org.apache.commons.io.input.NullInputStream.read(byte[])",
          "exception": "throw new EOFException()",
          "pathCojunction": "(!(eof)) && (position == size) && (throwEofException)",
          "symbolicPathConjunction": "(read(bytes, 0, bytes.length))",
          "backwardsPathConjunction": "(!(eof)) && (position == size) && (throwEofException)",
          "simplifiedPathConjunction": "throwEofException && position == size && !eof",
          "z3Inputs": "[size0 = -9223372036854775808,\n throwEofException0 = True,\n position0 = -9223372036854775808,\n eof0 = False]\n[eof0 = False,\n position0 = 0,\n throwEofException0 = True,\n size0 = 0]\n[eof0 = False,\n position0 = -1,\n throwEofException0 = True,\n size0 = -1]\n[eof0 = False,\n position0 = -2,\n throwEofException0 = True,\n size0 = -2]\n[eof0 = False,\n position0 = -3,\n throwEofException0 = True,\n size0 = -3]\n[eof0 = False,\n position0 = -4,\n throwEofException0 = True,\n size0 = -4]\n[eof0 = False,\n position0 = -5,\n throwEofException0 = True,\n size0 = -5]\n[eof0 = False,\n position0 = -6,\n throwEofException0 = True,\n size0 = -6]\n[eof0 = False,\n position0 = -7,\n throwEofException0 = True,\n size0 = -7]\n[eof0 = False,\n position0 = -8,\n throwEofException0 = True,\n size0 = -8]\n",
          "z3Program": "from z3 import *\nfrom z3_all_models import *\n\nsize0 = Int('size0')\nposition0 = Int('position0')\nthrowEofException0 = Bool('throwEofException0')\neof0 = Bool('eof0')\n\nconstraints = [\n  size0 >= -9223372036854775808, size0 <= 9223372036854775807, # implicit\n  position0 >= -9223372036854775808, position0 <= 9223372036854775807, # implicit\n  And(And(Not(eof0), position0 == size0), throwEofException0)\n]\n\nsolver = Solver()\nfor constraint in constraints:\n  solver.add(constraint)\n\nmodels = list(all_smt(solver))\nfor model in models: print(model)",
          "symPyProgram": "from sympy import Symbol\nfrom sympy import simplify\nfrom sympy.core.relational import Eq, Ne, StrictGreaterThan, StrictLessThan, LessThan, GreaterThan\nfrom sympy.printing import ccode\n\nsize = Symbol('size')\nposition = Symbol('position')\nthrowEofException = Symbol('throwEofException')\neof = Symbol('eof')\npath_conjunction = (((~(eof)) & (Eq(position, size))) & throwEofException)\nprint(ccode(simplify(path_conjunction)))",
          "soundSymbolic": true,
          "soundBackwards": true,
          "maybe": false,
          "line": 210,
          "throwingLine": 211,
          "isStatic": false,
          "targetOnlyArguments": false
        },
        {
          "qualifiedSignature": "org.apache.commons.io.input.NullInputStream.read(byte[])",
          "exception": "throw new IOException(\"Read after end of file\")",
          "pathCojunction": "(eof)",
          "symbolicPathConjunction": "(read(bytes, 0, bytes.length))",
          "backwardsPathConjunction": "(eof)",
          "simplifiedPathConjunction": "eof",
          "z3Inputs": "[eof0 = True]\n",
          "z3Program": "from z3 import *\nfrom z3_all_models import *\n\neof0 = Bool('eof0')\n\nconstraints = [\n  eof0\n]\n\nsolver = Solver()\nfor constraint in constraints:\n  solver.add(constraint)\n\nmodels = list(all_smt(solver))\nfor model in models: print(model)",
          "symPyProgram": "from sympy import Symbol\nfrom sympy import simplify\nfrom sympy.core.relational import Eq, Ne, StrictGreaterThan, StrictLessThan, LessThan, GreaterThan\nfrom sympy.printing import ccode\n\neof = Symbol('eof')\npath_conjunction = eof\nprint(ccode(simplify(path_conjunction)))",
          "soundSymbolic": true,
          "soundBackwards": true,
          "maybe": false,
          "line": 210,
          "throwingLine": 211,
          "isStatic": false,
          "targetOnlyArguments": false
        },
        {
          "qualifiedSignature": "org.apache.commons.io.input.NullInputStream.read(byte[], int, int)",
          "exception": "throw new IOException(\"Read after end of file\");",
          "pathCojunction": "(eof)",
          "symbolicPathConjunction": "(eof)",
          "backwardsPathConjunction": "(eof)",
          "simplifiedPathConjunction": "eof",
          "z3Inputs": "[eof0 = True]\n",
          "z3Program": "from z3 import *\nfrom z3_all_models import *\n\noffset0 = Int('offset0')\nlength0 = Int('length0')\neof0 = Bool('eof0')\n\nconstraints = [\n  eof0\n]\n\nsolver = Solver()\nfor constraint in constraints:\n  solver.add(constraint)\n\nmodels = list(all_smt(solver))\nfor model in models: print(model)",
          "symPyProgram": "from sympy import Symbol\nfrom sympy import simplify\nfrom sympy.core.relational import Eq, Ne, StrictGreaterThan, StrictLessThan, LessThan, GreaterThan\nfrom sympy.printing import ccode\n\neof = Symbol('eof')\npath_conjunction = eof\nprint(ccode(simplify(path_conjunction)))",
          "soundSymbolic": true,
          "soundBackwards": true,
          "maybe": false,
          "line": 228,
          "throwingLine": 230,
          "isStatic": false,
          "targetOnlyArguments": false
        },
        {
          "qualifiedSignature": "org.apache.commons.io.input.NullInputStream.read(byte[], int, int)",
          "exception": "throw new EOFException();",
          "pathCojunction": "(!(eof)) && (position == size) && (throwEofException)",
          "symbolicPathConjunction": "(!(eof)) && (position == size) && (throwEofException)",
          "backwardsPathConjunction": "(!(eof)) && (position == size) && (throwEofException)",
          "simplifiedPathConjunction": "throwEofException && position == size && !eof",
          "z3Inputs": "[size0 = -9223372036854775808,\n throwEofException0 = True,\n position0 = -9223372036854775808,\n eof0 = False]\n[eof0 = False,\n position0 = 0,\n throwEofException0 = True,\n size0 = 0]\n[eof0 = False,\n position0 = -1,\n throwEofException0 = True,\n size0 = -1]\n[eof0 = False,\n position0 = -2,\n throwEofException0 = True,\n size0 = -2]\n[eof0 = False,\n position0 = -3,\n throwEofException0 = True,\n size0 = -3]\n[eof0 = False,\n position0 = -4,\n throwEofException0 = True,\n size0 = -4]\n[eof0 = False,\n position0 = -5,\n throwEofException0 = True,\n size0 = -5]\n[eof0 = False,\n position0 = -6,\n throwEofException0 = True,\n size0 = -6]\n[eof0 = False,\n position0 = -7,\n throwEofException0 = True,\n size0 = -7]\n[eof0 = False,\n position0 = -8,\n throwEofException0 = True,\n size0 = -8]\n",
          "z3Program": "from z3 import *\nfrom z3_all_models import *\n\noffset0 = Int('offset0')\nlength0 = Int('length0')\neof0 = Bool('eof0')\nposition0 = Int('position0')\nsize0 = Int('size0')\nthrowEofException0 = Bool('throwEofException0')\n\nconstraints = [\n  position0 >= -9223372036854775808, position0 <= 9223372036854775807, # implicit\n  size0 >= -9223372036854775808, size0 <= 9223372036854775807, # implicit\n  And(And(Not(eof0), position0 == size0), throwEofException0)\n]\n\nsolver = Solver()\nfor constraint in constraints:\n  solver.add(constraint)\n\nmodels = list(all_smt(solver))\nfor model in models: print(model)",
          "symPyProgram": "from sympy import Symbol\nfrom sympy import simplify\nfrom sympy.core.relational import Eq, Ne, StrictGreaterThan, StrictLessThan, LessThan, GreaterThan\nfrom sympy.printing import ccode\n\neof = Symbol('eof')\nposition = Symbol('position')\nsize = Symbol('size')\nthrowEofException = Symbol('throwEofException')\npath_conjunction = (((~(eof)) & (Eq(position, size))) & throwEofException)\nprint(ccode(simplify(path_conjunction)))",
          "soundSymbolic": true,
          "soundBackwards": true,
          "maybe": false,
          "line": 228,
          "throwingLine": 233,
          "isStatic": false,
          "targetOnlyArguments": false
        },
        {
          "qualifiedSignature": "org.apache.commons.io.input.NullInputStream.reset()",
          "exception": "throw new UnsupportedOperationException(\"Mark not supported\");",
          "pathCojunction": "(!(markSupported))",
          "symbolicPathConjunction": "(!(markSupported))",
          "backwardsPathConjunction": "(!(markSupported))",
          "simplifiedPathConjunction": "!markSupported",
          "z3Inputs": "[markSupported0 = False]\n",
          "z3Program": "from z3 import *\nfrom z3_all_models import *\n\nmarkSupported0 = Bool('markSupported0')\n\nconstraints = [\n  Not(markSupported0)\n]\n\nsolver = Solver()\nfor constraint in constraints:\n  solver.add(constraint)\n\nmodels = list(all_smt(solver))\nfor model in models: print(model)",
          "symPyProgram": "from sympy import Symbol\nfrom sympy import simplify\nfrom sympy.core.relational import Eq, Ne, StrictGreaterThan, StrictLessThan, LessThan, GreaterThan\nfrom sympy.printing import ccode\n\nmarkSupported = Symbol('markSupported')\npath_conjunction = (~(markSupported))\nprint(ccode(simplify(path_conjunction)))",
          "soundSymbolic": true,
          "soundBackwards": true,
          "maybe": false,
          "line": 254,
          "throwingLine": 256,
          "isStatic": false,
          "targetOnlyArguments": false
        },
        {
          "qualifiedSignature": "org.apache.commons.io.input.NullInputStream.reset()",
          "exception": "throw new IOException(\"No position has been marked\");",
          "pathCojunction": "(!(!markSupported)) && (mark < 0)",
          "symbolicPathConjunction": "(!(!markSupported)) && (mark < 0)",
          "backwardsPathConjunction": "(!(!markSupported)) && (mark < 0)",
          "simplifiedPathConjunction": "markSupported && mark < 0",
          "z3Inputs": "[mark0 = -1, markSupported0 = True]\n[mark0 = -2, markSupported0 = True]\n[mark0 = -3, markSupported0 = True]\n[mark0 = -4, markSupported0 = True]\n[mark0 = -5, markSupported0 = True]\n[mark0 = -6, markSupported0 = True]\n[mark0 = -7, markSupported0 = True]\n[mark0 = -8, markSupported0 = True]\n[mark0 = -9, markSupported0 = True]\n[mark0 = -10, markSupported0 = True]\n",
          "z3Program": "from z3 import *\nfrom z3_all_models import *\n\nmarkSupported0 = Bool('markSupported0')\nmark0 = Int('mark0')\n\nconstraints = [\n  And(Not(Not(markSupported0)), mark0 < 0)\n]\n\nsolver = Solver()\nfor constraint in constraints:\n  solver.add(constraint)\n\nmodels = list(all_smt(solver))\nfor model in models: print(model)",
          "symPyProgram": "from sympy import Symbol\nfrom sympy import simplify\nfrom sympy.core.relational import Eq, Ne, StrictGreaterThan, StrictLessThan, LessThan, GreaterThan\nfrom sympy.printing import ccode\n\nmarkSupported = Symbol('markSupported')\nmark = Symbol('mark', integer=True)\npath_conjunction = ((~((~(markSupported)))) & (StrictLessThan(mark, 0)))\nprint(ccode(simplify(path_conjunction)))",
          "soundSymbolic": true,
          "soundBackwards": true,
          "maybe": false,
          "line": 254,
          "throwingLine": 259,
          "isStatic": false,
          "targetOnlyArguments": false
        },
        {
          "qualifiedSignature": "org.apache.commons.io.input.NullInputStream.reset()",
          "exception": "throw new IOException(\"Marked position [\" + mark + \"] is no longer valid - passed the read limit [\" + readlimit + \"]\");",
          "pathCojunction": "(!(!markSupported)) && (!(mark < 0)) && (position > mark + readlimit)",
          "symbolicPathConjunction": "(!(!markSupported)) && (!(mark < 0)) && (position > mark + readlimit)",
          "backwardsPathConjunction": "(!(!markSupported)) && (!(mark < 0)) && (position > mark + readlimit)",
          "simplifiedPathConjunction": "markSupported && mark >= 0 && mark < position - readlimit",
          "z3Inputs": "[position0 = 0,\n readlimit0 = -1,\n mark0 = 0,\n markSupported0 = True]\n[position0 = -1,\n readlimit0 = -3,\n mark0 = 1,\n markSupported0 = True]\n[position0 = -2,\n readlimit0 = -3,\n mark0 = 0,\n markSupported0 = True]\n[position0 = -3,\n readlimit0 = -4,\n mark0 = 0,\n markSupported0 = True]\n[position0 = -4,\n readlimit0 = -5,\n mark0 = 0,\n markSupported0 = True]\n[position0 = -5,\n readlimit0 = -6,\n mark0 = 0,\n markSupported0 = True]\n[position0 = -6,\n readlimit0 = -7,\n mark0 = 0,\n markSupported0 = True]\n[position0 = -7,\n readlimit0 = -8,\n mark0 = 0,\n markSupported0 = True]\n[position0 = -8,\n readlimit0 = -9,\n mark0 = 0,\n markSupported0 = True]\n[position0 = -9,\n readlimit0 = -10,\n mark0 = 0,\n markSupported0 = True]\n",
          "z3Program": "from z3 import *\nfrom z3_all_models import *\n\nmarkSupported0 = Bool('markSupported0')\nmark0 = Int('mark0')\nposition0 = Int('position0')\nreadlimit0 = Int('readlimit0')\n\nconstraints = [\n  position0 >= -9223372036854775808, position0 <= 9223372036854775807, # implicit\n  readlimit0 >= -9223372036854775808, readlimit0 <= 9223372036854775807, # implicit\n  And(And(Not(Not(markSupported0)), Not(mark0 < 0)), position0 > mark0 + readlimit0)\n]\n\nsolver = Solver()\nfor constraint in constraints:\n  solver.add(constraint)\n\nmodels = list(all_smt(solver))\nfor model in models: print(model)",
          "symPyProgram": "from sympy import Symbol\nfrom sympy import simplify\nfrom sympy.core.relational import Eq, Ne, StrictGreaterThan, StrictLessThan, LessThan, GreaterThan\nfrom sympy.printing import ccode\n\nmarkSupported = Symbol('markSupported')\nmark = Symbol('mark', integer=True)\nposition = Symbol('position')\nreadlimit = Symbol('readlimit')\npath_conjunction = (((~((~(markSupported)))) & (~((StrictLessThan(mark, 0))))) & (StrictGreaterThan(position, (mark + readlimit))))\nprint(ccode(simplify(path_conjunction)))",
          "soundSymbolic": true,
          "soundBackwards": true,
          "maybe": false,
          "line": 254,
          "throwingLine": 262,
          "isStatic": false,
          "targetOnlyArguments": false
        },
        {
          "qualifiedSignature": "org.apache.commons.io.input.NullInputStream.skip(long)",
          "exception": "throw new IOException(\"Skip after end of file\");",
          "pathCojunction": "(eof)",
          "symbolicPathConjunction": "(eof)",
          "backwardsPathConjunction": "(eof)",
          "simplifiedPathConjunction": "eof",
          "z3Inputs": "[numberOfBytes0 = -9223372036854775808, eof0 = True]\n[eof0 = True, numberOfBytes0 = 0]\n[eof0 = True, numberOfBytes0 = -1]\n[eof0 = True, numberOfBytes0 = -2]\n[eof0 = True, numberOfBytes0 = -3]\n[eof0 = True, numberOfBytes0 = -4]\n[eof0 = True, numberOfBytes0 = -5]\n[eof0 = True, numberOfBytes0 = -6]\n[eof0 = True, numberOfBytes0 = -7]\n[eof0 = True, numberOfBytes0 = -8]\n",
          "z3Program": "from z3 import *\nfrom z3_all_models import *\n\nnumberOfBytes0 = Int('numberOfBytes0')\neof0 = Bool('eof0')\n\nconstraints = [\n  numberOfBytes0 >= -9223372036854775808, numberOfBytes0 <= 9223372036854775807, # implicit\n  eof0\n]\n\nsolver = Solver()\nfor constraint in constraints:\n  solver.add(constraint)\n\nmodels = list(all_smt(solver))\nfor model in models: print(model)",
          "symPyProgram": "from sympy import Symbol\nfrom sympy import simplify\nfrom sympy.core.relational import Eq, Ne, StrictGreaterThan, StrictLessThan, LessThan, GreaterThan\nfrom sympy.printing import ccode\n\neof = Symbol('eof')\npath_conjunction = eof\nprint(ccode(simplify(path_conjunction)))",
          "soundSymbolic": true,
          "soundBackwards": true,
          "maybe": false,
          "line": 282,
          "throwingLine": 284,
          "isStatic": false,
          "targetOnlyArguments": false
        },
        {
          "qualifiedSignature": "org.apache.commons.io.input.NullInputStream.skip(long)",
          "exception": "throw new EOFException();",
          "pathCojunction": "(!(eof)) && (position == size) && (throwEofException)",
          "symbolicPathConjunction": "(!(eof)) && (position == size) && (throwEofException)",
          "backwardsPathConjunction": "(!(eof)) && (position == size) && (throwEofException)",
          "simplifiedPathConjunction": "throwEofException && position == size && !eof",
          "z3Inputs": "[numberOfBytes0 = 0,\n size0 = 0,\n throwEofException0 = True,\n position0 = 0,\n eof0 = False]\n[eof0 = False,\n numberOfBytes0 = -1,\n throwEofException0 = True,\n position0 = -1,\n size0 = -1]\n[eof0 = False,\n numberOfBytes0 = -2,\n throwEofException0 = True,\n position0 = -2,\n size0 = -2]\n[eof0 = False,\n numberOfBytes0 = -3,\n throwEofException0 = True,\n position0 = -3,\n size0 = -3]\n[eof0 = False,\n numberOfBytes0 = -4,\n throwEofException0 = True,\n position0 = -4,\n size0 = -4]\n[eof0 = False,\n numberOfBytes0 = -5,\n throwEofException0 = True,\n position0 = -5,\n size0 = -5]\n[eof0 = False,\n numberOfBytes0 = -6,\n throwEofException0 = True,\n position0 = -6,\n size0 = -6]\n[eof0 = False,\n numberOfBytes0 = -7,\n throwEofException0 = True,\n position0 = -7,\n size0 = -7]\n[eof0 = False,\n numberOfBytes0 = -8,\n throwEofException0 = True,\n position0 = -8,\n size0 = -8]\n[eof0 = False,\n numberOfBytes0 = -9,\n throwEofException0 = True,\n position0 = -9,\n size0 = -9]\n",
          "z3Program": "from z3 import *\nfrom z3_all_models import *\n\nnumberOfBytes0 = Int('numberOfBytes0')\neof0 = Bool('eof0')\nposition0 = Int('position0')\nsize0 = Int('size0')\nthrowEofException0 = Bool('throwEofException0')\n\nconstraints = [\n  numberOfBytes0 >= -9223372036854775808, numberOfBytes0 <= 9223372036854775807, # implicit\n  position0 >= -9223372036854775808, position0 <= 9223372036854775807, # implicit\n  size0 >= -9223372036854775808, size0 <= 9223372036854775807, # implicit\n  And(And(Not(eof0), position0 == size0), throwEofException0)\n]\n\nsolver = Solver()\nfor constraint in constraints:\n  solver.add(constraint)\n\nmodels = list(all_smt(solver))\nfor model in models: print(model)",
          "symPyProgram": "from sympy import Symbol\nfrom sympy import simplify\nfrom sympy.core.relational import Eq, Ne, StrictGreaterThan, StrictLessThan, LessThan, GreaterThan\nfrom sympy.printing import ccode\n\neof = Symbol('eof')\nposition = Symbol('position')\nsize = Symbol('size')\nthrowEofException = Symbol('throwEofException')\npath_conjunction = (((~(eof)) & (Eq(position, size))) & throwEofException)\nprint(ccode(simplify(path_conjunction)))",
          "soundSymbolic": true,
          "soundBackwards": true,
          "maybe": false,
          "line": 282,
          "throwingLine": 287,
          "isStatic": false,
          "targetOnlyArguments": false
        }
      ]
    },
    {
      "path": "/home/yanghengqin/commons-io-commons-io-2.6/src/main/java/org/apache/commons/io/ByteOrderParser.java",
      "methods": [
        {
          "qualifiedSignature": "org.apache.commons.io.ByteOrderParser.parseByteOrder(java.lang.String)",
          "exception": "throw new IllegalArgumentException(\"Unsupported byte order setting: \" + value + \", expeced one of \" + ByteOrder.LITTLE_ENDIAN + \", \" + ByteOrder.BIG_ENDIAN);",
          "pathCojunction": "(!(ByteOrder.BIG_ENDIAN.toString().equals(value))) && (!(ByteOrder.LITTLE_ENDIAN.toString().equals(value)))",
          "symbolicPathConjunction": "(!(ByteOrder.BIG_ENDIAN.toString().equals(value))) && (!(ByteOrder.LITTLE_ENDIAN.toString().equals(value)))",
          "backwardsPathConjunction": "(!(ByteOrder.BIG_ENDIAN.toString().equals(value))) && (!(ByteOrder.LITTLE_ENDIAN.toString().equals(value)))",
          "z3Program": "from z3 import *\nfrom z3_all_models import *\n\nvalue0 = String('value0')\n\nconstraints = [\n  And(Not(ByteOrder.BIG_ENDIAN.toString().equals(value0)), Not(ByteOrder_LITTLE_ENDIAN0.toString().equals(value0)))\n]\n\nsolver = Solver()\nfor constraint in constraints:\n  solver.add(constraint)\n\nmodels = list(all_smt(solver))\nfor model in models: print(model)",
          "symPyProgram": "from sympy import Symbol\nfrom sympy import simplify\nfrom sympy.core.relational import Eq, Ne, StrictGreaterThan, StrictLessThan, LessThan, GreaterThan\nfrom sympy.printing import ccode\n\nvalue = Symbol('value')\nBUG_IN_SIMPLIFICATION\npath_conjunction = ((~(ByteOrder.BIG_ENDIAN_toString_equals)) & (~(ByteOrder.LITTLE_ENDIAN_toString_equals)))\nprint(ccode(simplify(path_conjunction)))",
          "soundSymbolic": false,
          "soundBackwards": false,
          "maybe": true,
          "line": 55,
          "throwingLine": 62,
          "isStatic": true,
          "targetOnlyArguments": false
        }
      ]
    },
    {
      "path": "/home/yanghengqin/commons-io-commons-io-2.6/src/main/java/org/apache/commons/io/input/SwappedDataInputStream.java",
      "methods": [
        {
          "qualifiedSignature": "org.apache.commons.io.input.SwappedDataInputStream.readFully(byte[])",
          "exception": "throw new EOFException()",
          "pathCojunction": "(length > 0) && (EOF == read(data, location, remaining))",
          "symbolicPathConjunction": "(readFully(data, 0, data.length))",
          "backwardsPathConjunction": "(length > 0) && (EOF == read(data, offset + length - length, length))",
          "z3Program": "from z3 import *\nfrom z3_all_models import *\n\nlength0 = Int('length0')\nlocation0 = Int('location0')\nremaining0 = Int('remaining0')\n\nconstraints = [\n  location0 == offset + length0 - remaining,\n  remaining0 == length0,\n  And(length0 > 0, EOF == read(data0, location0, remaining0))\n]\n\nsolver = Solver()\nfor constraint in constraints:\n  solver.add(constraint)\n\nmodels = list(all_smt(solver))\nfor model in models: print(model)",
          "symPyProgram": "from sympy import Symbol\nfrom sympy import simplify\nfrom sympy.core.relational import Eq, Ne, StrictGreaterThan, StrictLessThan, LessThan, GreaterThan\nfrom sympy.printing import ccode\n\ndata = Symbol('data')\nlength = Symbol('length', integer=True)\n_read = Symbol('_read')\npath_conjunction = ((StrictGreaterThan(length, 0)) & (Eq(EOF, _read)))\nprint(ccode(simplify(path_conjunction)))",
          "soundSymbolic": true,
          "soundBackwards": false,
          "maybe": true,
          "line": 125,
          "throwingLine": 126,
          "isStatic": false,
          "targetOnlyArguments": false
        },
        {
          "qualifiedSignature": "org.apache.commons.io.input.SwappedDataInputStream.readFully(byte[], int, int)",
          "exception": "throw new EOFException();",
          "pathCojunction": "(remaining > 0) && (EOF == count)",
          "symbolicPathConjunction": "(remaining > 0) && (EOF == count)",
          "backwardsPathConjunction": "(length > 0) && (EOF == read(data, offset + length - remaining, length))",
          "z3Program": "from z3 import *\nfrom z3_all_models import *\n\noffset0 = Int('offset0')\nlength0 = Int('length0')\nremaining0 = Int('remaining0')\nlocation0 = Int('location0')\ncount0 = Int('count0')\n\nconstraints = [\n  remaining0 == length0,\n  location0 == offset0 + length0 - remaining0,\n  count0 == read(data0, location0, remaining0),\n  And(remaining0 > 0, EOF == count0)\n]\n\nsolver = Solver()\nfor constraint in constraints:\n  solver.add(constraint)\n\nmodels = list(all_smt(solver))\nfor model in models: print(model)",
          "symPyProgram": "from sympy import Symbol\nfrom sympy import simplify\nfrom sympy.core.relational import Eq, Ne, StrictGreaterThan, StrictLessThan, LessThan, GreaterThan\nfrom sympy.printing import ccode\n\ndata = Symbol('data')\noffset = Symbol('offset', integer=True)\nlength = Symbol('length', integer=True)\n_read = Symbol('_read')\npath_conjunction = ((StrictGreaterThan(length, 0)) & (Eq(EOF, _read)))\nprint(ccode(simplify(path_conjunction)))",
          "soundSymbolic": false,
          "soundBackwards": false,
          "maybe": true,
          "line": 142,
          "throwingLine": 152,
          "isStatic": false,
          "targetOnlyArguments": false
        },
        {
          "qualifiedSignature": "org.apache.commons.io.input.SwappedDataInputStream.readLine()",
          "exception": "throw new UnsupportedOperationException(\"Operation not supported: readLine()\");",
          "pathCojunction": "true",
          "backwardsPathConjunction": "true",
          "simplifiedPathConjunction": "true",
          "soundSymbolic": false,
          "soundBackwards": true,
          "maybe": false,
          "line": 181,
          "throwingLine": 182,
          "isStatic": false,
          "targetOnlyArguments": true
        },
        {
          "qualifiedSignature": "org.apache.commons.io.input.SwappedDataInputStream.readUTF()",
          "exception": "throw new UnsupportedOperationException(\"Operation not supported: readUTF()\");",
          "pathCojunction": "true",
          "backwardsPathConjunction": "true",
          "simplifiedPathConjunction": "true",
          "soundSymbolic": false,
          "soundBackwards": true,
          "maybe": false,
          "line": 247,
          "throwingLine": 248,
          "isStatic": false,
          "targetOnlyArguments": true
        }
      ]
    },
    {
      "path": "/home/yanghengqin/commons-io-commons-io-2.6/src/main/java/org/apache/commons/io/input/CharSequenceInputStream.java",
      "methods": [
        {
          "qualifiedSignature": "org.apache.commons.io.input.CharSequenceInputStream.read(byte[], int, int)",
          "exception": "throw new IndexOutOfBoundsException(\"Array Size=\" + b.length + \", offset=\" + off + \", length=\" + len);",
          "pathCojunction": "(!(b == null)) && (len < 0 || (off + len) > b.length)",
          "symbolicPathConjunction": "(!(b == null)) && (len < 0 || (off + len) > b.length)",
          "backwardsPathConjunction": "(!(b == null)) && (len < 0 || (off + len) > b.length)",
          "simplifiedPathConjunction": "(b.length < len + off || len < 0) && b != null",
          "z3Inputs": "[len0 = -1, b0_length = 0, off0 = 1, b0_isNull = False]\n[off0 = 0, b0_isNull = False, b0_length = 1, len0 = -1]\n[off0 = -1, b0_isNull = False, b0_length = 0, len0 = -1]\n[b0_isNull = False, b0_length = 0, len0 = -2]\n[b0_isNull = False, b0_length = 0, len0 = -3]\n[b0_isNull = False, b0_length = 0, len0 = -4]\n[b0_isNull = False, b0_length = 0, len0 = -5]\n[b0_isNull = False, b0_length = 0, len0 = -6]\n[off0 = -2, b0_isNull = False, b0_length = 0, len0 = -7]\n[off0 = -3, b0_isNull = False, b0_length = 0, len0 = -8]\n",
          "z3Program": "from z3 import *\nfrom z3_all_models import *\n\noff0 = Int('off0')\nlen0 = Int('len0')\nb0_isNull = Bool('b0_isNull')\nb0_length = Int('b0_length')\n\nconstraints = [\n  b0_length >= 0, # implicit\n  And(Not(b0_isNull), Or(len0 < 0, off0 + len0 > b0_length))\n]\n\nsolver = Solver()\nfor constraint in constraints:\n  solver.add(constraint)\n\nmodels = list(all_smt(solver))\nfor model in models: print(model)",
          "symPyProgram": "from sympy import Symbol\nfrom sympy import simplify\nfrom sympy.core.relational import Eq, Ne, StrictGreaterThan, StrictLessThan, LessThan, GreaterThan\nfrom sympy.printing import ccode\n\nb = Symbol('b')\noff = Symbol('off', integer=True)\nlen = Symbol('len', integer=True)\nb_length = Symbol('b_length', integer=True)\nnull = Symbol('null')\npath_conjunction = ((~((Eq(b, null)))) & ((StrictLessThan(len, 0)) | (StrictGreaterThan((off + len), b_length))))\nprint(ccode(simplify(path_conjunction)))",
          "soundSymbolic": true,
          "soundBackwards": true,
          "maybe": false,
          "line": 131,
          "throwingLine": 136,
          "isStatic": false,
          "targetOnlyArguments": true
        },
        {
          "qualifiedSignature": "org.apache.commons.io.input.CharSequenceInputStream.read(byte[], int, int)",
          "exception": "throw new NullPointerException(\"Byte array is null\");",
          "pathCojunction": "(b == null)",
          "symbolicPathConjunction": "(b == null)",
          "backwardsPathConjunction": "(b == null)",
          "simplifiedPathConjunction": "b == null",
          "z3Inputs": "[b0_isNull = True]\n",
          "z3Program": "from z3 import *\nfrom z3_all_models import *\n\noff0 = Int('off0')\nlen0 = Int('len0')\nb0_isNull = Bool('b0_isNull')\n\nconstraints = [\n  b0_isNull\n]\n\nsolver = Solver()\nfor constraint in constraints:\n  solver.add(constraint)\n\nmodels = list(all_smt(solver))\nfor model in models: print(model)",
          "symPyProgram": "from sympy import Symbol\nfrom sympy import simplify\nfrom sympy.core.relational import Eq, Ne, StrictGreaterThan, StrictLessThan, LessThan, GreaterThan\nfrom sympy.printing import ccode\n\nb = Symbol('b')\nnull = Symbol('null')\npath_conjunction = (Eq(b, null))\nprint(ccode(simplify(path_conjunction)))",
          "soundSymbolic": true,
          "soundBackwards": true,
          "maybe": false,
          "line": 131,
          "throwingLine": 133,
          "isStatic": false,
          "targetOnlyArguments": true
        },
        {
          "qualifiedSignature": "org.apache.commons.io.input.CharSequenceInputStream.read(byte[])",
          "exception": "throw new NullPointerException(\"Byte array is null\")",
          "pathCojunction": "(b == null)",
          "symbolicPathConjunction": "(read(b, 0, b.length))",
          "backwardsPathConjunction": "(b == null)",
          "simplifiedPathConjunction": "b == null",
          "z3Inputs": "[b0_isNull = True]\n",
          "z3Program": "from z3 import *\nfrom z3_all_models import *\n\nb0_isNull = Bool('b0_isNull')\n\nconstraints = [\n  b0_isNull\n]\n\nsolver = Solver()\nfor constraint in constraints:\n  solver.add(constraint)\n\nmodels = list(all_smt(solver))\nfor model in models: print(model)",
          "symPyProgram": "from sympy import Symbol\nfrom sympy import simplify\nfrom sympy.core.relational import Eq, Ne, StrictGreaterThan, StrictLessThan, LessThan, GreaterThan\nfrom sympy.printing import ccode\n\nb = Symbol('b')\nnull = Symbol('null')\npath_conjunction = (Eq(b, null))\nprint(ccode(simplify(path_conjunction)))",
          "soundSymbolic": true,
          "soundBackwards": true,
          "maybe": false,
          "line": 177,
          "throwingLine": 178,
          "isStatic": false,
          "targetOnlyArguments": true
        },
        {
          "qualifiedSignature": "org.apache.commons.io.input.CharSequenceInputStream.reset()",
          "exception": "throw new IllegalStateException(\"Unexpected CharBuffer postion: actual=\" + cbuf.position() + \" \" + \"expected=\" + this.mark_cbuf);",
          "pathCojunction": "(this.mark_cbuf != NO_MARK) && (this.cbuf.position() != 0) && (this.cbuf.position() < this.mark_cbuf) && (!(this.encoder.encode(this.cbuf, this.bbuf, true).isError())) && (!(this.cbuf.position() < this.mark_cbuf)) && (this.cbuf.position() != this.mark_cbuf)",
          "symbolicPathConjunction": "(this.mark_cbuf != NO_MARK) && (this.cbuf.position() != 0) && (this.cbuf.position() < this.mark_cbuf) && (!(this.encoder.encode(this.cbuf, this.bbuf, true).isError())) && (!(this.cbuf.position() < this.mark_cbuf)) && (this.cbuf.position() != this.mark_cbuf)",
          "backwardsPathConjunction": "(this.mark_cbuf != NO_MARK) && (this.cbuf.position() != 0) && (this.cbuf.position() < this.mark_cbuf) && (!(this.encoder.encode(this.cbuf, this.bbuf, true).isError())) && (!(this.cbuf.position() < this.mark_cbuf)) && (this.cbuf.position() != this.mark_cbuf)",
          "z3Program": "from z3 import *\nfrom z3_all_models import *\n\nthis_mark_cbuf0 = Int('this_mark_cbuf0')\nNO_MARK0 = Int('NO_MARK0')\n\nconstraints = [\n  NO_MARK0 == -1,\n  And(And(And(And(And(this_mark_cbuf0 != NO_MARK0, this_cbuf0.position() != 0), this_cbuf0.position() < this_mark_cbuf0), Not(this.encoder.encode(this_cbuf0, this.bbuf, true).isError())), Not(this_cbuf0.position() < this_mark_cbuf0)), this_cbuf0.position() != this_mark_cbuf0)\n]\n\nsolver = Solver()\nfor constraint in constraints:\n  solver.add(constraint)\n\nmodels = list(all_smt(solver))\nfor model in models: print(model)",
          "soundSymbolic": false,
          "soundBackwards": true,
          "maybe": true,
          "line": 229,
          "throwingLine": 255,
          "isStatic": false,
          "targetOnlyArguments": false
        },
        {
          "qualifiedSignature": "org.apache.commons.io.input.CharSequenceInputStream.reset()",
          "exception": "throw new IllegalStateException(\"Unexpected CharBuffer postion: actual=\" + cbuf.position() + \" \" + \"expected=\" + this.mark_cbuf);",
          "pathCojunction": "(this.mark_cbuf != NO_MARK) && (this.cbuf.position() != 0) && (!(this.cbuf.position() < this.mark_cbuf)) && (this.cbuf.position() != this.mark_cbuf)",
          "symbolicPathConjunction": "(this.mark_cbuf != NO_MARK) && (this.cbuf.position() != 0) && (!(this.cbuf.position() < this.mark_cbuf)) && (this.cbuf.position() != this.mark_cbuf)",
          "backwardsPathConjunction": "(this.mark_cbuf != NO_MARK) && (this.cbuf.position() != 0) && (!(this.cbuf.position() < this.mark_cbuf)) && (this.cbuf.position() != this.mark_cbuf)",
          "z3Program": "from z3 import *\nfrom z3_all_models import *\n\nthis_mark_cbuf0 = Int('this_mark_cbuf0')\nNO_MARK0 = Int('NO_MARK0')\n\nconstraints = [\n  NO_MARK0 == -1,\n  And(And(And(this_mark_cbuf0 != NO_MARK0, this_cbuf0.position() != 0), Not(this_cbuf0.position() < this_mark_cbuf0)), this_cbuf0.position() != this_mark_cbuf0)\n]\n\nsolver = Solver()\nfor constraint in constraints:\n  solver.add(constraint)\n\nmodels = list(all_smt(solver))\nfor model in models: print(model)",
          "soundSymbolic": false,
          "soundBackwards": true,
          "maybe": true,
          "line": 229,
          "throwingLine": 255,
          "isStatic": false,
          "targetOnlyArguments": false
        },
        {
          "qualifiedSignature": "org.apache.commons.io.input.CharSequenceInputStream.reset()",
          "exception": "throw new IllegalStateException(\"Unexpected CharBuffer postion: actual=\" + cbuf.position() + \" \" + \"expected=\" + this.mark_cbuf);",
          "pathCojunction": "(this.mark_cbuf != NO_MARK) && (!(this.cbuf.position() != 0)) && (this.cbuf.position() != this.mark_cbuf)",
          "symbolicPathConjunction": "(this.mark_cbuf != NO_MARK) && (!(this.cbuf.position() != 0)) && (this.cbuf.position() != this.mark_cbuf)",
          "backwardsPathConjunction": "(this.mark_cbuf != NO_MARK) && (!(this.cbuf.position() != 0)) && (this.cbuf.position() != this.mark_cbuf)",
          "z3Program": "from z3 import *\nfrom z3_all_models import *\n\nthis_mark_cbuf0 = Int('this_mark_cbuf0')\nNO_MARK0 = Int('NO_MARK0')\n\nconstraints = [\n  NO_MARK0 == -1,\n  And(And(this_mark_cbuf0 != NO_MARK0, Not(this_cbuf0.position() != 0)), this_cbuf0.position() != this_mark_cbuf0)\n]\n\nsolver = Solver()\nfor constraint in constraints:\n  solver.add(constraint)\n\nmodels = list(all_smt(solver))\nfor model in models: print(model)",
          "soundSymbolic": false,
          "soundBackwards": true,
          "maybe": true,
          "line": 229,
          "throwingLine": 255,
          "isStatic": false,
          "targetOnlyArguments": false
        },
        {
          "qualifiedSignature": "org.apache.commons.io.input.CharSequenceInputStream.reset()",
          "exception": "throw new IllegalStateException(\"Unexpected CharBuffer postion: actual=\" + cbuf.position() + \" \" + \"expected=\" + this.mark_cbuf);",
          "pathCojunction": "(this.mark_cbuf != NO_MARK) && (this.cbuf.position() != 0) && (this.cbuf.position() < this.mark_cbuf) && (this.encoder.encode(this.cbuf, this.bbuf, true).isError()) && (!(this.cbuf.position() < this.mark_cbuf)) && (this.cbuf.position() != this.mark_cbuf)",
          "symbolicPathConjunction": "(this.mark_cbuf != NO_MARK) && (this.cbuf.position() != 0) && (this.cbuf.position() < this.mark_cbuf) && (this.encoder.encode(this.cbuf, this.bbuf, true).isError()) && (!(this.cbuf.position() < this.mark_cbuf)) && (this.cbuf.position() != this.mark_cbuf)",
          "backwardsPathConjunction": "(this.mark_cbuf != NO_MARK) && (this.cbuf.position() != 0) && (this.cbuf.position() < this.mark_cbuf) && (this.encoder.encode(this.cbuf, this.bbuf, true).isError()) && (!(this.cbuf.position() < this.mark_cbuf)) && (this.cbuf.position() != this.mark_cbuf)",
          "z3Program": "from z3 import *\nfrom z3_all_models import *\n\nthis_mark_cbuf0 = Int('this_mark_cbuf0')\nNO_MARK0 = Int('NO_MARK0')\n\nconstraints = [\n  NO_MARK0 == -1,\n  And(And(And(And(And(this_mark_cbuf0 != NO_MARK0, this_cbuf0.position() != 0), this_cbuf0.position() < this_mark_cbuf0), this.encoder.encode(this_cbuf0, this.bbuf, true).isError()), Not(this_cbuf0.position() < this_mark_cbuf0)), this_cbuf0.position() != this_mark_cbuf0)\n]\n\nsolver = Solver()\nfor constraint in constraints:\n  solver.add(constraint)\n\nmodels = list(all_smt(solver))\nfor model in models: print(model)",
          "soundSymbolic": false,
          "soundBackwards": true,
          "maybe": true,
          "line": 229,
          "throwingLine": 255,
          "isStatic": false,
          "targetOnlyArguments": false
        }
      ]
    },
    {
      "path": "/home/yanghengqin/commons-io-commons-io-2.6/src/main/java/org/apache/commons/io/output/ClosedOutputStream.java",
      "methods": [
        {
          "qualifiedSignature": "org.apache.commons.io.output.ClosedOutputStream.write(int)",
          "exception": "throw new IOException(\"write(\" + b + \") failed: stream is closed\");",
          "pathCojunction": "true",
          "backwardsPathConjunction": "true",
          "simplifiedPathConjunction": "true",
          "z3Program": "from z3 import *\nfrom z3_all_models import *\n\nb0 = Int('b0')\n\nconstraints = [\n  True\n]\n\nsolver = Solver()\nfor constraint in constraints:\n  solver.add(constraint)\n\nmodels = list(all_smt(solver))\nfor model in models: print(model)",
          "soundSymbolic": false,
          "soundBackwards": true,
          "maybe": false,
          "line": 46,
          "throwingLine": 47,
          "isStatic": false,
          "targetOnlyArguments": true
        },
        {
          "qualifiedSignature": "org.apache.commons.io.output.ClosedOutputStream.flush()",
          "exception": "throw new IOException(\"flush() failed: stream is closed\");",
          "pathCojunction": "true",
          "backwardsPathConjunction": "true",
          "simplifiedPathConjunction": "true",
          "soundSymbolic": false,
          "soundBackwards": true,
          "maybe": false,
          "line": 56,
          "throwingLine": 57,
          "isStatic": false,
          "targetOnlyArguments": true
        }
      ]
    },
    {
      "path": "/home/yanghengqin/commons-io-commons-io-2.6/src/main/java/org/apache/commons/io/LineIterator.java",
      "methods": [
        {
          "qualifiedSignature": "org.apache.commons.io.LineIterator.remove()",
          "exception": "throw new UnsupportedOperationException(\"Remove unsupported on LineIterator\");",
          "pathCojunction": "true",
          "backwardsPathConjunction": "true",
          "simplifiedPathConjunction": "true",
          "soundSymbolic": false,
          "soundBackwards": true,
          "maybe": false,
          "line": 176,
          "throwingLine": 177,
          "isStatic": false,
          "targetOnlyArguments": true
        }
      ]
    },
    {
      "path": "/home/yanghengqin/commons-io-commons-io-2.6/src/main/java/org/apache/commons/io/filefilter/FileFilterUtils.java",
      "methods": [
        {
          "qualifiedSignature": "org.apache.commons.io.filefilter.FileFilterUtils.and(org.apache.commons.io.filefilter.IOFileFilter...)",
          "exception": "throw new IllegalArgumentException(\"The filters must not be null\");",
          "pathCojunction": "(filters == null)",
          "symbolicPathConjunction": "(toList(filters))",
          "backwardsPathConjunction": "(filters == null)",
          "simplifiedPathConjunction": "filters == null",
          "z3Inputs": "[filters0_isNull = True]\n",
          "z3Program": "from z3 import *\nfrom z3_all_models import *\n\nfilters0_isNull = Bool('filters0_isNull')\n\nconstraints = [\n  filters0_isNull\n]\n\nsolver = Solver()\nfor constraint in constraints:\n  solver.add(constraint)\n\nmodels = list(all_smt(solver))\nfor model in models: print(model)",
          "symPyProgram": "from sympy import Symbol\nfrom sympy import simplify\nfrom sympy.core.relational import Eq, Ne, StrictGreaterThan, StrictLessThan, LessThan, GreaterThan\nfrom sympy.printing import ccode\n\nfilters = Symbol('filters')\nnull = Symbol('null')\npath_conjunction = (Eq(filters, null))\nprint(ccode(simplify(path_conjunction)))",
          "soundSymbolic": true,
          "soundBackwards": true,
          "maybe": false,
          "line": 420,
          "throwingLine": 421,
          "isStatic": true,
          "targetOnlyArguments": true
        },
        {
          "qualifiedSignature": "org.apache.commons.io.filefilter.FileFilterUtils.or(org.apache.commons.io.filefilter.IOFileFilter...)",
          "exception": "throw new IllegalArgumentException(\"The filters must not be null\");",
          "pathCojunction": "(filters == null)",
          "symbolicPathConjunction": "(toList(filters))",
          "backwardsPathConjunction": "(filters == null)",
          "simplifiedPathConjunction": "filters == null",
          "z3Inputs": "[filters0_isNull = True]\n",
          "z3Program": "from z3 import *\nfrom z3_all_models import *\n\nfilters0_isNull = Bool('filters0_isNull')\n\nconstraints = [\n  filters0_isNull\n]\n\nsolver = Solver()\nfor constraint in constraints:\n  solver.add(constraint)\n\nmodels = list(all_smt(solver))\nfor model in models: print(model)",
          "symPyProgram": "from sympy import Symbol\nfrom sympy import simplify\nfrom sympy.core.relational import Eq, Ne, StrictGreaterThan, StrictLessThan, LessThan, GreaterThan\nfrom sympy.printing import ccode\n\nfilters = Symbol('filters')\nnull = Symbol('null')\npath_conjunction = (Eq(filters, null))\nprint(ccode(simplify(path_conjunction)))",
          "soundSymbolic": true,
          "soundBackwards": true,
          "maybe": false,
          "line": 435,
          "throwingLine": 436,
          "isStatic": true,
          "targetOnlyArguments": true
        },
        {
          "qualifiedSignature": "org.apache.commons.io.filefilter.FileFilterUtils.toList(org.apache.commons.io.filefilter.IOFileFilter...)",
          "exception": "throw new IllegalArgumentException(\"The filters must not be null\");",
          "pathCojunction": "(filters == null)",
          "symbolicPathConjunction": "(filters == null)",
          "backwardsPathConjunction": "(filters == null)",
          "simplifiedPathConjunction": "filters == null",
          "z3Inputs": "[filters0_isNull = True]\n",
          "z3Program": "from z3 import *\nfrom z3_all_models import *\n\nfilters0_isNull = Bool('filters0_isNull')\n\nconstraints = [\n  filters0_isNull\n]\n\nsolver = Solver()\nfor constraint in constraints:\n  solver.add(constraint)\n\nmodels = list(all_smt(solver))\nfor model in models: print(model)",
          "symPyProgram": "from sympy import Symbol\nfrom sympy import simplify\nfrom sympy.core.relational import Eq, Ne, StrictGreaterThan, StrictLessThan, LessThan, GreaterThan\nfrom sympy.printing import ccode\n\nfilters = Symbol('filters')\nnull = Symbol('null')\npath_conjunction = (Eq(filters, null))\nprint(ccode(simplify(path_conjunction)))",
          "soundSymbolic": true,
          "soundBackwards": true,
          "maybe": false,
          "line": 448,
          "throwingLine": 450,
          "isStatic": true,
          "targetOnlyArguments": true
        }
      ]
    },
    {
      "path": "/home/yanghengqin/commons-io-commons-io-2.6/src/main/java/org/apache/commons/io/output/CountingOutputStream.java",
      "methods": [
        {
          "qualifiedSignature": "org.apache.commons.io.output.CountingOutputStream.getCount()",
          "exception": "throw new ArithmeticException(\"The byte count \" + result + \" is too large to be converted to an int\");",
          "pathCojunction": "(result > Integer.MAX_VALUE)",
          "symbolicPathConjunction": "(getByteCount()) && (result > Integer.MAX_VALUE)",
          "backwardsPathConjunction": "(this.count > Integer.MAX_VALUE)",
          "z3Program": "from z3 import *\nfrom z3_all_models import *\n\nresult0 = Int('result0')\n\nconstraints = [\n  result0 == this.count,\n  result0 >= -9223372036854775808, result0 <= 9223372036854775807, # implicit\n  result0 > 2147483647\n]\n\nsolver = Solver()\nfor constraint in constraints:\n  solver.add(constraint)\n\nmodels = list(all_smt(solver))\nfor model in models: print(model)",
          "soundSymbolic": true,
          "soundBackwards": false,
          "maybe": true,
          "line": 67,
          "throwingLine": 70,
          "isStatic": false,
          "targetOnlyArguments": false
        },
        {
          "qualifiedSignature": "org.apache.commons.io.output.CountingOutputStream.resetCount()",
          "exception": "throw new ArithmeticException(\"The byte count \" + result + \" is too large to be converted to an int\");",
          "pathCojunction": "(result > Integer.MAX_VALUE)",
          "symbolicPathConjunction": "(resetByteCount()) && (result > Integer.MAX_VALUE)",
          "backwardsPathConjunction": "(tmp > Integer.MAX_VALUE)",
          "z3Program": "from z3 import *\nfrom z3_all_models import *\n\ntmp0 = Int('tmp0')\nresult0 = Int('result0')\n\nconstraints = [\n  tmp0 == this.count,\n  result0 == tmp0,\n  tmp0 >= -9223372036854775808, tmp0 <= 9223372036854775807, # implicit\n  result0 >= -9223372036854775808, result0 <= 9223372036854775807, # implicit\n  result0 > 2147483647\n]\n\nsolver = Solver()\nfor constraint in constraints:\n  solver.add(constraint)\n\nmodels = list(all_smt(solver))\nfor model in models: print(model)",
          "symPyProgram": "from sympy import Symbol\nfrom sympy import simplify\nfrom sympy.core.relational import Eq, Ne, StrictGreaterThan, StrictLessThan, LessThan, GreaterThan\nfrom sympy.printing import ccode\n\nInteger_MAX_VALUE = Symbol('Integer_MAX_VALUE', integer=True)\nInteger_MAX_VALUE = Symbol('Integer_MAX_VALUE', integer=True)\npath_conjunction = (StrictGreaterThan(tmp, Integer_MAX_VALUE))\nprint(ccode(simplify(path_conjunction)))",
          "soundSymbolic": true,
          "soundBackwards": false,
          "maybe": true,
          "line": 85,
          "throwingLine": 88,
          "isStatic": false,
          "targetOnlyArguments": false
        }
      ]
    },
    {
      "path": "/home/yanghengqin/commons-io-commons-io-2.6/src/main/java/org/apache/commons/io/input/WindowsLineEndingInputStream.java",
      "methods": [
        {
          "qualifiedSignature": "org.apache.commons.io.input.WindowsLineEndingInputStream.mark(int)",
          "exception": "throw new UnsupportedOperationException(\"Mark not supported\");",
          "pathCojunction": "true",
          "backwardsPathConjunction": "true",
          "simplifiedPathConjunction": "true",
          "z3Program": "from z3 import *\nfrom z3_all_models import *\n\nreadlimit0 = Int('readlimit0')\n\nconstraints = [\n  True\n]\n\nsolver = Solver()\nfor constraint in constraints:\n  solver.add(constraint)\n\nmodels = list(all_smt(solver))\nfor model in models: print(model)",
          "soundSymbolic": false,
          "soundBackwards": true,
          "maybe": false,
          "line": 131,
          "throwingLine": 132,
          "isStatic": false,
          "targetOnlyArguments": true
        }
      ]
    },
    {
      "path": "/home/yanghengqin/commons-io-commons-io-2.6/src/main/java/org/apache/commons/io/IOUtils.java",
      "methods": [
        {
          "qualifiedSignature": "org.apache.commons.io.IOUtils.buffer(java.io.OutputStream)",
          "exception": "throw new NullPointerException();",
          "pathCojunction": "(outputStream == null)",
          "symbolicPathConjunction": "(outputStream == null)",
          "backwardsPathConjunction": "(outputStream == null)",
          "simplifiedPathConjunction": "null == outputStream",
          "z3Inputs": "[outputStream0_isNull = True]\n",
          "z3Program": "from z3 import *\nfrom z3_all_models import *\n\noutputStream0_isNull = Bool('outputStream0_isNull')\n\nconstraints = [\n  outputStream0_isNull\n]\n\nsolver = Solver()\nfor constraint in constraints:\n  solver.add(constraint)\n\nmodels = list(all_smt(solver))\nfor model in models: print(model)",
          "symPyProgram": "from sympy import Symbol\nfrom sympy import simplify\nfrom sympy.core.relational import Eq, Ne, StrictGreaterThan, StrictLessThan, LessThan, GreaterThan\nfrom sympy.printing import ccode\n\noutputStream = Symbol('outputStream')\nnull = Symbol('null')\npath_conjunction = (Eq(outputStream, null))\nprint(ccode(simplify(path_conjunction)))",
          "soundSymbolic": true,
          "soundBackwards": true,
          "maybe": false,
          "line": 684,
          "throwingLine": 687,
          "isStatic": true,
          "targetOnlyArguments": true
        },
        {
          "qualifiedSignature": "org.apache.commons.io.IOUtils.buffer(java.io.OutputStream, int)",
          "exception": "throw new NullPointerException();",
          "pathCojunction": "(outputStream == null)",
          "symbolicPathConjunction": "(outputStream == null)",
          "backwardsPathConjunction": "(outputStream == null)",
          "simplifiedPathConjunction": "null == outputStream",
          "z3Inputs": "[outputStream0_isNull = True]\n",
          "z3Program": "from z3 import *\nfrom z3_all_models import *\n\nsize0 = Int('size0')\noutputStream0_isNull = Bool('outputStream0_isNull')\n\nconstraints = [\n  outputStream0_isNull\n]\n\nsolver = Solver()\nfor constraint in constraints:\n  solver.add(constraint)\n\nmodels = list(all_smt(solver))\nfor model in models: print(model)",
          "symPyProgram": "from sympy import Symbol\nfrom sympy import simplify\nfrom sympy.core.relational import Eq, Ne, StrictGreaterThan, StrictLessThan, LessThan, GreaterThan\nfrom sympy.printing import ccode\n\noutputStream = Symbol('outputStream')\nnull = Symbol('null')\npath_conjunction = (Eq(outputStream, null))\nprint(ccode(simplify(path_conjunction)))",
          "soundSymbolic": true,
          "soundBackwards": true,
          "maybe": false,
          "line": 703,
          "throwingLine": 706,
          "isStatic": true,
          "targetOnlyArguments": true
        },
        {
          "qualifiedSignature": "org.apache.commons.io.IOUtils.buffer(java.io.InputStream)",
          "exception": "throw new NullPointerException();",
          "pathCojunction": "(inputStream == null)",
          "symbolicPathConjunction": "(inputStream == null)",
          "backwardsPathConjunction": "(inputStream == null)",
          "simplifiedPathConjunction": "inputStream == null",
          "z3Inputs": "[inputStream0_isNull = True]\n",
          "z3Program": "from z3 import *\nfrom z3_all_models import *\n\ninputStream0_isNull = Bool('inputStream0_isNull')\n\nconstraints = [\n  inputStream0_isNull\n]\n\nsolver = Solver()\nfor constraint in constraints:\n  solver.add(constraint)\n\nmodels = list(all_smt(solver))\nfor model in models: print(model)",
          "symPyProgram": "from sympy import Symbol\nfrom sympy import simplify\nfrom sympy.core.relational import Eq, Ne, StrictGreaterThan, StrictLessThan, LessThan, GreaterThan\nfrom sympy.printing import ccode\n\ninputStream = Symbol('inputStream')\nnull = Symbol('null')\npath_conjunction = (Eq(inputStream, null))\nprint(ccode(simplify(path_conjunction)))",
          "soundSymbolic": true,
          "soundBackwards": true,
          "maybe": false,
          "line": 721,
          "throwingLine": 724,
          "isStatic": true,
          "targetOnlyArguments": true
        },
        {
          "qualifiedSignature": "org.apache.commons.io.IOUtils.buffer(java.io.InputStream, int)",
          "exception": "throw new NullPointerException();",
          "pathCojunction": "(inputStream == null)",
          "symbolicPathConjunction": "(inputStream == null)",
          "backwardsPathConjunction": "(inputStream == null)",
          "simplifiedPathConjunction": "inputStream == null",
          "z3Inputs": "[inputStream0_isNull = True]\n",
          "z3Program": "from z3 import *\nfrom z3_all_models import *\n\nsize0 = Int('size0')\ninputStream0_isNull = Bool('inputStream0_isNull')\n\nconstraints = [\n  inputStream0_isNull\n]\n\nsolver = Solver()\nfor constraint in constraints:\n  solver.add(constraint)\n\nmodels = list(all_smt(solver))\nfor model in models: print(model)",
          "symPyProgram": "from sympy import Symbol\nfrom sympy import simplify\nfrom sympy.core.relational import Eq, Ne, StrictGreaterThan, StrictLessThan, LessThan, GreaterThan\nfrom sympy.printing import ccode\n\ninputStream = Symbol('inputStream')\nnull = Symbol('null')\npath_conjunction = (Eq(inputStream, null))\nprint(ccode(simplify(path_conjunction)))",
          "soundSymbolic": true,
          "soundBackwards": true,
          "maybe": false,
          "line": 740,
          "throwingLine": 743,
          "isStatic": true,
          "targetOnlyArguments": true
        },
        {
          "qualifiedSignature": "org.apache.commons.io.IOUtils.toByteArray(java.io.InputStream, long)",
          "exception": "throw new IllegalArgumentException(\"Size must be equal or greater than zero: \" + (int) size)",
          "pathCojunction": "(!(size > Integer.MAX_VALUE)) && ((int) size < 0)",
          "symbolicPathConjunction": "(!(size > Integer.MAX_VALUE)) && (toByteArray(input, (int) size))",
          "backwardsPathConjunction": "(!(size > Integer.MAX_VALUE)) && ((int) size < 0)",
          "simplifiedPathConjunction": "Integer.MAX_VALUE >= size && size < 0",
          "z3Inputs": "[size0 = -9223372036854775808]\n[size0 = -1]\n[size0 = -2]\n[size0 = -3]\n[size0 = -4]\n[size0 = -5]\n[size0 = -6]\n[size0 = -7]\n[size0 = -8]\n[size0 = -9]\n",
          "z3Program": "from z3 import *\nfrom z3_all_models import *\n\nsize0 = Int('size0')\n\nconstraints = [\n  size0 >= -9223372036854775808, size0 <= 9223372036854775807, # implicit\n  And(Not(size0 > 2147483647), size0 < 0)\n]\n\nsolver = Solver()\nfor constraint in constraints:\n  solver.add(constraint)\n\nmodels = list(all_smt(solver))\nfor model in models: print(model)",
          "symPyProgram": "from sympy import Symbol\nfrom sympy import simplify\nfrom sympy.core.relational import Eq, Ne, StrictGreaterThan, StrictLessThan, LessThan, GreaterThan\nfrom sympy.printing import ccode\n\nsize = Symbol('size')\nInteger_MAX_VALUE = Symbol('Integer_MAX_VALUE', integer=True)\nInteger_MAX_VALUE = Symbol('Integer_MAX_VALUE', integer=True)\npath_conjunction = ((~((StrictGreaterThan(size, Integer_MAX_VALUE)))) & (StrictLessThan(size, 0)))\nprint(ccode(simplify(path_conjunction)))",
          "soundSymbolic": true,
          "soundBackwards": false,
          "maybe": true,
          "line": 787,
          "throwingLine": 793,
          "isStatic": true,
          "targetOnlyArguments": false
        },
        {
          "qualifiedSignature": "org.apache.commons.io.IOUtils.toByteArray(java.io.InputStream, long)",
          "exception": "throw new IllegalArgumentException(\"Size cannot be greater than Integer max value: \" + size);",
          "pathCojunction": "(size > Integer.MAX_VALUE)",
          "symbolicPathConjunction": "(size > Integer.MAX_VALUE)",
          "backwardsPathConjunction": "(size > Integer.MAX_VALUE)",
          "simplifiedPathConjunction": "Integer.MAX_VALUE < size",
          "z3Inputs": "[size0 = 2147483648]\n[size0 = 2147483649]\n[size0 = 2147483650]\n[size0 = 2147483651]\n[size0 = 2147483652]\n[size0 = 2147483653]\n[size0 = 2147483654]\n[size0 = 2147483655]\n[size0 = 2147483656]\n[size0 = 2147483657]\n",
          "z3Program": "from z3 import *\nfrom z3_all_models import *\n\nsize0 = Int('size0')\n\nconstraints = [\n  size0 >= -9223372036854775808, size0 <= 9223372036854775807, # implicit\n  size0 > 2147483647\n]\n\nsolver = Solver()\nfor constraint in constraints:\n  solver.add(constraint)\n\nmodels = list(all_smt(solver))\nfor model in models: print(model)",
          "symPyProgram": "from sympy import Symbol\nfrom sympy import simplify\nfrom sympy.core.relational import Eq, Ne, StrictGreaterThan, StrictLessThan, LessThan, GreaterThan\nfrom sympy.printing import ccode\n\nsize = Symbol('size')\nInteger_MAX_VALUE = Symbol('Integer_MAX_VALUE', integer=True)\nInteger_MAX_VALUE = Symbol('Integer_MAX_VALUE', integer=True)\npath_conjunction = (StrictGreaterThan(size, Integer_MAX_VALUE))\nprint(ccode(simplify(path_conjunction)))",
          "soundSymbolic": true,
          "soundBackwards": false,
          "maybe": true,
          "line": 787,
          "throwingLine": 790,
          "isStatic": true,
          "targetOnlyArguments": false
        },
        {
          "qualifiedSignature": "org.apache.commons.io.IOUtils.toByteArray(java.io.InputStream, int)",
          "exception": "throw new IllegalArgumentException(\"Size must be equal or greater than zero: \" + size);",
          "pathCojunction": "(size < 0)",
          "symbolicPathConjunction": "(size < 0)",
          "backwardsPathConjunction": "(size < 0)",
          "simplifiedPathConjunction": "size < 0",
          "z3Inputs": "[size0 = -1]\n[size0 = -2]\n[size0 = -3]\n[size0 = -4]\n[size0 = -5]\n[size0 = -6]\n[size0 = -7]\n[size0 = -8]\n[size0 = -9]\n[size0 = -10]\n",
          "z3Program": "from z3 import *\nfrom z3_all_models import *\n\nsize0 = Int('size0')\n\nconstraints = [\n  size0 < 0\n]\n\nsolver = Solver()\nfor constraint in constraints:\n  solver.add(constraint)\n\nmodels = list(all_smt(solver))\nfor model in models: print(model)",
          "symPyProgram": "from sympy import Symbol\nfrom sympy import simplify\nfrom sympy.core.relational import Eq, Ne, StrictGreaterThan, StrictLessThan, LessThan, GreaterThan\nfrom sympy.printing import ccode\n\nsize = Symbol('size', integer=True)\npath_conjunction = (StrictLessThan(size, 0))\nprint(ccode(simplify(path_conjunction)))",
          "soundSymbolic": true,
          "soundBackwards": true,
          "maybe": false,
          "line": 809,
          "throwingLine": 812,
          "isStatic": true,
          "targetOnlyArguments": true
        },
        {
          "qualifiedSignature": "org.apache.commons.io.IOUtils.copyLarge(java.io.InputStream, java.io.OutputStream, long, long)",
          "exception": "throw new EOFException(\"Bytes to skip: \" + inputOffset + \" actual: \" + skipped)",
          "pathCojunction": "(inputOffset > 0) && (!(inputOffset < 0)) && (!(inputOffset < 0)) && (!(SKIP_BYTE_BUFFER == null)) && (inputOffset > 0) && (input.read(SKIP_BYTE_BUFFER, 0, (int) Math.min(toSkip, 2048)) < 0) && (toSkip - toSkip != inputOffset)",
          "symbolicPathConjunction": "(copyLarge(input, output, inputOffset, length, new byte[DEFAULT_BUFFER_SIZE]))",
          "backwardsPathConjunction": "(inputOffset > 0) && (!(inputOffset < 0)) && (!(inputOffset < 0)) && (!(SKIP_BYTE_BUFFER == null)) && (inputOffset > 0) && (input.read(SKIP_BYTE_BUFFER, 0, (int) Math.min(toSkip, 2048)) < 0) && (toSkip - toSkip != inputOffset)",
          "simplifiedPathConjunction": "inputOffset > 0 && input.read(SKIP_BYTE_BUFFER, 0, Math.min(toSkip, 2048)) < 0 && SKIP_BYTE_BUFFER != null",
          "z3Program": "from z3 import *\nfrom z3_all_models import *\n\ninputOffset0 = Int('inputOffset0')\nlength0 = Int('length0')\nDEFAULT_BUFFER_SIZE0 = Int('DEFAULT_BUFFER_SIZE0')\ntoSkip0 = Int('toSkip0')\nSKIP_BYTE_BUFFER0_isNull = Bool('SKIP_BYTE_BUFFER0_isNull')\n\nconstraints = [\n  DEFAULT_BUFFER_SIZE0 == 1024 * 4,\n  inputOffset0 >= -9223372036854775808, inputOffset0 <= 9223372036854775807, # implicit\n  length0 >= -9223372036854775808, length0 <= 9223372036854775807, # implicit\n  toSkip0 >= -9223372036854775808, toSkip0 <= 9223372036854775807, # implicit\n  And(And(And(And(And(And(inputOffset0 > 0, Not(inputOffset0 < 0)), Not(inputOffset0 < 0)), Not(SKIP_BYTE_BUFFER0_isNull)), inputOffset0 > 0), input0.read(SKIP_BYTE_BUFFER0, 0, Math.min(toSkip0, 2048)) < 0), toSkip0 - toSkip0 != inputOffset0)\n]\n\nsolver = Solver()\nfor constraint in constraints:\n  solver.add(constraint)\n\nmodels = list(all_smt(solver))\nfor model in models: print(model)",
          "symPyProgram": "from sympy import Symbol\nfrom sympy import simplify\nfrom sympy.core.relational import Eq, Ne, StrictGreaterThan, StrictLessThan, LessThan, GreaterThan\nfrom sympy.printing import ccode\n\ninput = Symbol('input')\ninputOffset = Symbol('inputOffset')\nSKIP_BYTE_BUFFER = Symbol('SKIP_BYTE_BUFFER')\ntoSkip = Symbol('toSkip')\ninput_read = Symbol('input_read')\nMath_min = Symbol('Math_min')\nnull = Symbol('null')\npath_conjunction = (((((((StrictGreaterThan(inputOffset, 0)) & (~((StrictLessThan(inputOffset, 0))))) & (~((StrictLessThan(inputOffset, 0))))) & (~((Eq(SKIP_BYTE_BUFFER, null))))) & (StrictGreaterThan(inputOffset, 0))) & (StrictLessThan(input_read, 0))) & (Ne((toSkip - toSkip), inputOffset)))\nprint(ccode(simplify(path_conjunction)))",
          "soundSymbolic": true,
          "soundBackwards": false,
          "maybe": true,
          "line": 2346,
          "throwingLine": 2347,
          "isStatic": true,
          "targetOnlyArguments": false
        },
        {
          "qualifiedSignature": "org.apache.commons.io.IOUtils.copyLarge(java.io.InputStream, java.io.OutputStream, long, long)",
          "exception": "throw new EOFException(\"Bytes to skip: \" + inputOffset + \" actual: \" + skipped)",
          "pathCojunction": "(inputOffset > 0) && (!(inputOffset < 0)) && (!(inputOffset < 0)) && (!(SKIP_BYTE_BUFFER == null)) && (remain - n - input.read(SKIP_BYTE_BUFFER, 0, (int) Math.min(remain, SKIP_BUFFER_SIZE)) - input.read(SKIP_BYTE_BUFFER, 0, (int) Math.min(remain - n, 2048)) > 0) && (!(input.read(SKIP_BYTE_BUFFER, 0, (int) Math.min(remain - n - input.read(SKIP_BYTE_BUFFER, 0, (int) Math.min(remain, SKIP_BUFFER_SIZE)), 2048)) < 0)) && (!(remain - n - input.read(SKIP_BYTE_BUFFER, 0, (int) Math.min(remain, SKIP_BUFFER_SIZE)) - input.read(SKIP_BYTE_BUFFER, 0, (int) Math.min(remain - n, 2048)) > 0)) && (toSkip - remain - n - input.read(SKIP_BYTE_BUFFER, 0, (int) Math.min(remain, SKIP_BUFFER_SIZE)) != inputOffset)",
          "symbolicPathConjunction": "(copyLarge(input, output, inputOffset, length, new byte[DEFAULT_BUFFER_SIZE]))",
          "backwardsPathConjunction": "(inputOffset > 0) && (!(inputOffset < 0)) && (!(inputOffset < 0)) && (!(SKIP_BYTE_BUFFER == null)) && (remain - n - input.read(SKIP_BYTE_BUFFER, 0, (int) Math.min(remain, SKIP_BUFFER_SIZE)) - input.read(SKIP_BYTE_BUFFER, 0, (int) Math.min(remain, SKIP_BUFFER_SIZE)) - input.read(SKIP_BYTE_BUFFER, 0, (int) Math.min(remain - n - input.read(SKIP_BYTE_BUFFER, 0, (int) Math.min(remain, SKIP_BUFFER_SIZE)), SKIP_BUFFER_SIZE)) - input.read(SKIP_BYTE_BUFFER, 0, (int) Math.min(remain - n - input.read(SKIP_BYTE_BUFFER, 0, (int) Math.min(remain, SKIP_BUFFER_SIZE)) - input.read(SKIP_BYTE_BUFFER, 0, (int) Math.min(remain, SKIP_BUFFER_SIZE)), 2048)) > 0) && (!(input.read(SKIP_BYTE_BUFFER, 0, (int) Math.min(remain - n - input.read(SKIP_BYTE_BUFFER, 0, (int) Math.min(remain, SKIP_BUFFER_SIZE)) - input.read(SKIP_BYTE_BUFFER, 0, (int) Math.min(remain, SKIP_BUFFER_SIZE)) - input.read(SKIP_BYTE_BUFFER, 0, (int) Math.min(remain - n - input.read(SKIP_BYTE_BUFFER, 0, (int) Math.min(remain, SKIP_BUFFER_SIZE)), SKIP_BUFFER_SIZE)), 2048)) < 0)) && (!(remain - n - input.read(SKIP_BYTE_BUFFER, 0, (int) Math.min(remain, SKIP_BUFFER_SIZE)) - input.read(SKIP_BYTE_BUFFER, 0, (int) Math.min(remain, SKIP_BUFFER_SIZE)) - input.read(SKIP_BYTE_BUFFER, 0, (int) Math.min(remain - n - input.read(SKIP_BYTE_BUFFER, 0, (int) Math.min(remain, SKIP_BUFFER_SIZE)), SKIP_BUFFER_SIZE)) - input.read(SKIP_BYTE_BUFFER, 0, (int) Math.min(remain - n - input.read(SKIP_BYTE_BUFFER, 0, (int) Math.min(remain, SKIP_BUFFER_SIZE)) - input.read(SKIP_BYTE_BUFFER, 0, (int) Math.min(remain, SKIP_BUFFER_SIZE)), 2048)) > 0)) && (toSkip - remain - n - input.read(SKIP_BYTE_BUFFER, 0, (int) Math.min(remain, SKIP_BUFFER_SIZE)) - input.read(SKIP_BYTE_BUFFER, 0, (int) Math.min(remain, SKIP_BUFFER_SIZE)) - input.read(SKIP_BYTE_BUFFER, 0, (int) Math.min(remain - n - input.read(SKIP_BYTE_BUFFER, 0, (int) Math.min(remain, SKIP_BUFFER_SIZE)), SKIP_BUFFER_SIZE)) != inputOffset)",
          "z3Program": "from z3 import *\nfrom z3_all_models import *\n\ninputOffset0 = Int('inputOffset0')\nlength0 = Int('length0')\nDEFAULT_BUFFER_SIZE0 = Int('DEFAULT_BUFFER_SIZE0')\nremain0 = Int('remain0')\nn0 = Int('n0')\nSKIP_BUFFER_SIZE0 = Int('SKIP_BUFFER_SIZE0')\ntoSkip0 = Int('toSkip0')\nSKIP_BYTE_BUFFER0_isNull = Bool('SKIP_BYTE_BUFFER0_isNull')\n\nconstraints = [\n  DEFAULT_BUFFER_SIZE0 == 1024 * 4,\n  remain0 == remain - n,\n  n0 == input0.read(SKIP_BYTE_BUFFER0, 0, Math.min(remain0, SKIP_BUFFER_SIZE)),\n  SKIP_BUFFER_SIZE0 == 2048,\n  inputOffset0 >= -9223372036854775808, inputOffset0 <= 9223372036854775807, # implicit\n  length0 >= -9223372036854775808, length0 <= 9223372036854775807, # implicit\n  remain0 >= -9223372036854775808, remain0 <= 9223372036854775807, # implicit\n  n0 >= -9223372036854775808, n0 <= 9223372036854775807, # implicit\n  toSkip0 >= -9223372036854775808, toSkip0 <= 9223372036854775807, # implicit\n  And(And(And(And(And(And(And(inputOffset0 > 0, Not(inputOffset0 < 0)), Not(inputOffset0 < 0)), Not(SKIP_BYTE_BUFFER0_isNull)), remain0 - n0 - input0.read(SKIP_BYTE_BUFFER0, 0, Math.min(remain0, SKIP_BUFFER_SIZE0)) - input0.read(SKIP_BYTE_BUFFER0, 0, Math.min(remain0 - n0, 2048)) > 0), Not(input0.read(SKIP_BYTE_BUFFER0, 0, Math.min(remain0 - n0 - input0.read(SKIP_BYTE_BUFFER0, 0, Math.min(remain0, SKIP_BUFFER_SIZE0)), 2048)) < 0)), Not(remain0 - n0 - input0.read(SKIP_BYTE_BUFFER0, 0, Math.min(remain0, SKIP_BUFFER_SIZE0)) - input0.read(SKIP_BYTE_BUFFER0, 0, Math.min(remain0 - n0, 2048)) > 0)), toSkip0 - remain0 - n0 - input0.read(SKIP_BYTE_BUFFER0, 0, Math.min(remain0, SKIP_BUFFER_SIZE0)) != inputOffset0)\n]\n\nsolver = Solver()\nfor constraint in constraints:\n  solver.add(constraint)\n\nmodels = list(all_smt(solver))\nfor model in models: print(model)",
          "symPyProgram": "from sympy import Symbol\nfrom sympy import simplify\nfrom sympy.core.relational import Eq, Ne, StrictGreaterThan, StrictLessThan, LessThan, GreaterThan\nfrom sympy.printing import ccode\n\ninput = Symbol('input')\ninputOffset = Symbol('inputOffset')\nSKIP_BYTE_BUFFER = Symbol('SKIP_BYTE_BUFFER')\ntoSkip = Symbol('toSkip')\ninput_read = Symbol('input_read')\nMath_min = Symbol('Math_min')\nnull = Symbol('null')\npath_conjunction = ((((((((StrictGreaterThan(inputOffset, 0)) & (~((StrictLessThan(inputOffset, 0))))) & (~((StrictLessThan(inputOffset, 0))))) & (~((Eq(SKIP_BYTE_BUFFER, null))))) & (StrictGreaterThan((((((remain - n) - input_read) - input_read) - input_read) - input_read), 0))) & (~((StrictLessThan(input_read, 0))))) & (~((StrictGreaterThan((((((remain - n) - input_read) - input_read) - input_read) - input_read), 0))))) & (Ne((((((toSkip - remain) - n) - input_read) - input_read) - input_read), inputOffset)))\nprint(ccode(simplify(path_conjunction)))",
          "soundSymbolic": true,
          "soundBackwards": false,
          "maybe": true,
          "line": 2346,
          "throwingLine": 2347,
          "isStatic": true,
          "targetOnlyArguments": false
        },
        {
          "qualifiedSignature": "org.apache.commons.io.IOUtils.copyLarge(java.io.InputStream, java.io.OutputStream, long, long, byte[])",
          "exception": "throw new EOFException(\"Bytes to skip: \" + inputOffset + \" actual: \" + skipped)",
          "pathCojunction": "(inputOffset > 0) && (!(inputOffset < 0)) && (!(inputOffset < 0)) && (!(SKIP_BYTE_BUFFER == null)) && (remain - n - input.read(SKIP_BYTE_BUFFER, 0, (int) Math.min(remain, SKIP_BUFFER_SIZE)) > 0) && (!(input.read(SKIP_BYTE_BUFFER, 0, (int) Math.min(remain - n, 2048)) < 0)) && (!(remain - n - input.read(SKIP_BYTE_BUFFER, 0, (int) Math.min(remain, SKIP_BUFFER_SIZE)) > 0)) && (toSkip - remain - n != inputOffset)",
          "symbolicPathConjunction": "(inputOffset > 0) && (skipFully(input, inputOffset))",
          "backwardsPathConjunction": "(inputOffset > 0) && (!(inputOffset < 0)) && (!(inputOffset < 0)) && (!(SKIP_BYTE_BUFFER == null)) && (remain - n - input.read(SKIP_BYTE_BUFFER, 0, (int) Math.min(remain, SKIP_BUFFER_SIZE)) - input.read(SKIP_BYTE_BUFFER, 0, (int) Math.min(remain, SKIP_BUFFER_SIZE)) - input.read(SKIP_BYTE_BUFFER, 0, (int) Math.min(remain - n - input.read(SKIP_BYTE_BUFFER, 0, (int) Math.min(remain, SKIP_BUFFER_SIZE)), SKIP_BUFFER_SIZE)) > 0) && (!(input.read(SKIP_BYTE_BUFFER, 0, (int) Math.min(remain - n - input.read(SKIP_BYTE_BUFFER, 0, (int) Math.min(remain, SKIP_BUFFER_SIZE)) - input.read(SKIP_BYTE_BUFFER, 0, (int) Math.min(remain, SKIP_BUFFER_SIZE)), 2048)) < 0)) && (!(remain - n - input.read(SKIP_BYTE_BUFFER, 0, (int) Math.min(remain, SKIP_BUFFER_SIZE)) - input.read(SKIP_BYTE_BUFFER, 0, (int) Math.min(remain, SKIP_BUFFER_SIZE)) - input.read(SKIP_BYTE_BUFFER, 0, (int) Math.min(remain - n - input.read(SKIP_BYTE_BUFFER, 0, (int) Math.min(remain, SKIP_BUFFER_SIZE)), SKIP_BUFFER_SIZE)) > 0)) && (toSkip - remain - n - input.read(SKIP_BYTE_BUFFER, 0, (int) Math.min(remain, SKIP_BUFFER_SIZE)) - input.read(SKIP_BYTE_BUFFER, 0, (int) Math.min(remain, SKIP_BUFFER_SIZE)) != inputOffset)",
          "z3Program": "from z3 import *\nfrom z3_all_models import *\n\ninputOffset0 = Int('inputOffset0')\nlength0 = Int('length0')\nremain0 = Int('remain0')\nn0 = Int('n0')\nSKIP_BUFFER_SIZE0 = Int('SKIP_BUFFER_SIZE0')\ntoSkip0 = Int('toSkip0')\nSKIP_BYTE_BUFFER0_isNull = Bool('SKIP_BYTE_BUFFER0_isNull')\n\nconstraints = [\n  remain0 == remain - n,\n  n0 == input0.read(SKIP_BYTE_BUFFER0, 0, Math.min(remain0, SKIP_BUFFER_SIZE)),\n  SKIP_BUFFER_SIZE0 == 2048,\n  inputOffset0 >= -9223372036854775808, inputOffset0 <= 9223372036854775807, # implicit\n  length0 >= -9223372036854775808, length0 <= 9223372036854775807, # implicit\n  remain0 >= -9223372036854775808, remain0 <= 9223372036854775807, # implicit\n  n0 >= -9223372036854775808, n0 <= 9223372036854775807, # implicit\n  toSkip0 >= -9223372036854775808, toSkip0 <= 9223372036854775807, # implicit\n  And(And(And(And(And(And(And(inputOffset0 > 0, Not(inputOffset0 < 0)), Not(inputOffset0 < 0)), Not(SKIP_BYTE_BUFFER0_isNull)), remain0 - n0 - input0.read(SKIP_BYTE_BUFFER0, 0, Math.min(remain0, SKIP_BUFFER_SIZE0)) > 0), Not(input0.read(SKIP_BYTE_BUFFER0, 0, Math.min(remain0 - n0, 2048)) < 0)), Not(remain0 - n0 - input0.read(SKIP_BYTE_BUFFER0, 0, Math.min(remain0, SKIP_BUFFER_SIZE0)) > 0)), toSkip0 - remain0 - n0 != inputOffset0)\n]\n\nsolver = Solver()\nfor constraint in constraints:\n  solver.add(constraint)\n\nmodels = list(all_smt(solver))\nfor model in models: print(model)",
          "symPyProgram": "from sympy import Symbol\nfrom sympy import simplify\nfrom sympy.core.relational import Eq, Ne, StrictGreaterThan, StrictLessThan, LessThan, GreaterThan\nfrom sympy.printing import ccode\n\ninput = Symbol('input')\ninputOffset = Symbol('inputOffset')\nSKIP_BYTE_BUFFER = Symbol('SKIP_BYTE_BUFFER')\ntoSkip = Symbol('toSkip')\ninput_read = Symbol('input_read')\nMath_min = Symbol('Math_min')\nnull = Symbol('null')\npath_conjunction = ((((((((StrictGreaterThan(inputOffset, 0)) & (~((StrictLessThan(inputOffset, 0))))) & (~((StrictLessThan(inputOffset, 0))))) & (~((Eq(SKIP_BYTE_BUFFER, null))))) & (StrictGreaterThan(((((remain - n) - input_read) - input_read) - input_read), 0))) & (~((StrictLessThan(input_read, 0))))) & (~((StrictGreaterThan(((((remain - n) - input_read) - input_read) - input_read), 0))))) & (Ne(((((toSkip - remain) - n) - input_read) - input_read), inputOffset)))\nprint(ccode(simplify(path_conjunction)))",
          "soundSymbolic": true,
          "soundBackwards": false,
          "maybe": true,
          "line": 2375,
          "throwingLine": 2377,
          "isStatic": true,
          "targetOnlyArguments": false
        },
        {
          "qualifiedSignature": "org.apache.commons.io.IOUtils.copyLarge(java.io.InputStream, java.io.OutputStream, long, long, byte[])",
          "exception": "throw new EOFException(\"Bytes to skip: \" + inputOffset + \" actual: \" + skipped)",
          "pathCojunction": "(inputOffset > 0) && (!(inputOffset < 0)) && (!(inputOffset < 0)) && (!(SKIP_BYTE_BUFFER == null)) && (inputOffset > 0) && (input.read(SKIP_BYTE_BUFFER, 0, (int) Math.min(toSkip, 2048)) < 0) && (toSkip - toSkip != inputOffset)",
          "symbolicPathConjunction": "(inputOffset > 0) && (skipFully(input, inputOffset))",
          "backwardsPathConjunction": "(inputOffset > 0) && (!(inputOffset < 0)) && (!(inputOffset < 0)) && (!(SKIP_BYTE_BUFFER == null)) && (inputOffset > 0) && (input.read(SKIP_BYTE_BUFFER, 0, (int) Math.min(toSkip, 2048)) < 0) && (toSkip - toSkip != inputOffset)",
          "simplifiedPathConjunction": "inputOffset > 0 && input.read(SKIP_BYTE_BUFFER, 0, Math.min(toSkip, 2048)) < 0 && SKIP_BYTE_BUFFER != null",
          "z3Program": "from z3 import *\nfrom z3_all_models import *\n\ninputOffset0 = Int('inputOffset0')\nlength0 = Int('length0')\ntoSkip0 = Int('toSkip0')\nSKIP_BYTE_BUFFER0_isNull = Bool('SKIP_BYTE_BUFFER0_isNull')\n\nconstraints = [\n  inputOffset0 >= -9223372036854775808, inputOffset0 <= 9223372036854775807, # implicit\n  length0 >= -9223372036854775808, length0 <= 9223372036854775807, # implicit\n  toSkip0 >= -9223372036854775808, toSkip0 <= 9223372036854775807, # implicit\n  And(And(And(And(And(And(inputOffset0 > 0, Not(inputOffset0 < 0)), Not(inputOffset0 < 0)), Not(SKIP_BYTE_BUFFER0_isNull)), inputOffset0 > 0), input0.read(SKIP_BYTE_BUFFER0, 0, Math.min(toSkip0, 2048)) < 0), toSkip0 - toSkip0 != inputOffset0)\n]\n\nsolver = Solver()\nfor constraint in constraints:\n  solver.add(constraint)\n\nmodels = list(all_smt(solver))\nfor model in models: print(model)",
          "symPyProgram": "from sympy import Symbol\nfrom sympy import simplify\nfrom sympy.core.relational import Eq, Ne, StrictGreaterThan, StrictLessThan, LessThan, GreaterThan\nfrom sympy.printing import ccode\n\ninput = Symbol('input')\ninputOffset = Symbol('inputOffset')\nSKIP_BYTE_BUFFER = Symbol('SKIP_BYTE_BUFFER')\ntoSkip = Symbol('toSkip')\ninput_read = Symbol('input_read')\nMath_min = Symbol('Math_min')\nnull = Symbol('null')\npath_conjunction = (((((((StrictGreaterThan(inputOffset, 0)) & (~((StrictLessThan(inputOffset, 0))))) & (~((StrictLessThan(inputOffset, 0))))) & (~((Eq(SKIP_BYTE_BUFFER, null))))) & (StrictGreaterThan(inputOffset, 0))) & (StrictLessThan(input_read, 0))) & (Ne((toSkip - toSkip), inputOffset)))\nprint(ccode(simplify(path_conjunction)))",
          "soundSymbolic": true,
          "soundBackwards": false,
          "maybe": true,
          "line": 2375,
          "throwingLine": 2377,
          "isStatic": true,
          "targetOnlyArguments": false
        },
        {
          "qualifiedSignature": "org.apache.commons.io.IOUtils.copyLarge(java.io.Reader, java.io.Writer, long, long)",
          "exception": "throw new EOFException(\"Chars to skip: \" + inputOffset + \" actual: \" + skipped)",
          "pathCojunction": "(inputOffset > 0) && (!(inputOffset < 0)) && (!(SKIP_CHAR_BUFFER == null)) && (inputOffset > 0) && (input.read(SKIP_CHAR_BUFFER, 0, (int) Math.min(toSkip, 2048)) < 0) && (toSkip - toSkip != inputOffset)",
          "symbolicPathConjunction": "(copyLarge(input, output, inputOffset, length, new char[DEFAULT_BUFFER_SIZE]))",
          "backwardsPathConjunction": "(inputOffset > 0) && (!(inputOffset < 0)) && (!(SKIP_CHAR_BUFFER == null)) && (inputOffset > 0) && (input.read(SKIP_CHAR_BUFFER, 0, (int) Math.min(toSkip, 2048)) < 0) && (toSkip - toSkip != inputOffset)",
          "simplifiedPathConjunction": "inputOffset > 0 && input.read(SKIP_CHAR_BUFFER, 0, Math.min(toSkip, 2048)) < 0 && SKIP_CHAR_BUFFER != null",
          "z3Program": "from z3 import *\nfrom z3_all_models import *\n\ninputOffset0 = Int('inputOffset0')\nlength0 = Int('length0')\nDEFAULT_BUFFER_SIZE0 = Int('DEFAULT_BUFFER_SIZE0')\ntoSkip0 = Int('toSkip0')\nSKIP_CHAR_BUFFER0_isNull = Bool('SKIP_CHAR_BUFFER0_isNull')\n\nconstraints = [\n  DEFAULT_BUFFER_SIZE0 == 1024 * 4,\n  inputOffset0 >= -9223372036854775808, inputOffset0 <= 9223372036854775807, # implicit\n  length0 >= -9223372036854775808, length0 <= 9223372036854775807, # implicit\n  toSkip0 >= -9223372036854775808, toSkip0 <= 9223372036854775807, # implicit\n  And(And(And(And(And(inputOffset0 > 0, Not(inputOffset0 < 0)), Not(SKIP_CHAR_BUFFER0_isNull)), inputOffset0 > 0), input0.read(SKIP_CHAR_BUFFER0, 0, Math.min(toSkip0, 2048)) < 0), toSkip0 - toSkip0 != inputOffset0)\n]\n\nsolver = Solver()\nfor constraint in constraints:\n  solver.add(constraint)\n\nmodels = list(all_smt(solver))\nfor model in models: print(model)",
          "symPyProgram": "from sympy import Symbol\nfrom sympy import simplify\nfrom sympy.core.relational import Eq, Ne, StrictGreaterThan, StrictLessThan, LessThan, GreaterThan\nfrom sympy.printing import ccode\n\ninput = Symbol('input')\ninputOffset = Symbol('inputOffset')\nSKIP_CHAR_BUFFER = Symbol('SKIP_CHAR_BUFFER')\ntoSkip = Symbol('toSkip')\ninput_read = Symbol('input_read')\nMath_min = Symbol('Math_min')\nnull = Symbol('null')\npath_conjunction = ((((((StrictGreaterThan(inputOffset, 0)) & (~((StrictLessThan(inputOffset, 0))))) & (~((Eq(SKIP_CHAR_BUFFER, null))))) & (StrictGreaterThan(inputOffset, 0))) & (StrictLessThan(input_read, 0))) & (Ne((toSkip - toSkip), inputOffset)))\nprint(ccode(simplify(path_conjunction)))",
          "soundSymbolic": true,
          "soundBackwards": false,
          "maybe": true,
          "line": 2564,
          "throwingLine": 2565,
          "isStatic": true,
          "targetOnlyArguments": false
        },
        {
          "qualifiedSignature": "org.apache.commons.io.IOUtils.copyLarge(java.io.Reader, java.io.Writer, long, long)",
          "exception": "throw new EOFException(\"Chars to skip: \" + inputOffset + \" actual: \" + skipped)",
          "pathCojunction": "(inputOffset > 0) && (!(inputOffset < 0)) && (!(SKIP_CHAR_BUFFER == null)) && (remain - n - input.read(SKIP_CHAR_BUFFER, 0, (int) Math.min(remain, SKIP_BUFFER_SIZE)) - input.read(SKIP_CHAR_BUFFER, 0, (int) Math.min(remain - n, 2048)) > 0) && (!(input.read(SKIP_CHAR_BUFFER, 0, (int) Math.min(remain - n - input.read(SKIP_CHAR_BUFFER, 0, (int) Math.min(remain, SKIP_BUFFER_SIZE)), 2048)) < 0)) && (!(remain - n - input.read(SKIP_CHAR_BUFFER, 0, (int) Math.min(remain, SKIP_BUFFER_SIZE)) - input.read(SKIP_CHAR_BUFFER, 0, (int) Math.min(remain - n, 2048)) > 0)) && (toSkip - remain - n - input.read(SKIP_CHAR_BUFFER, 0, (int) Math.min(remain, SKIP_BUFFER_SIZE)) != inputOffset)",
          "symbolicPathConjunction": "(copyLarge(input, output, inputOffset, length, new char[DEFAULT_BUFFER_SIZE]))",
          "backwardsPathConjunction": "(inputOffset > 0) && (!(inputOffset < 0)) && (!(SKIP_CHAR_BUFFER == null)) && (remain - n - input.read(SKIP_CHAR_BUFFER, 0, (int) Math.min(remain, SKIP_BUFFER_SIZE)) - input.read(SKIP_CHAR_BUFFER, 0, (int) Math.min(remain, SKIP_BUFFER_SIZE)) - input.read(SKIP_CHAR_BUFFER, 0, (int) Math.min(remain - n - input.read(SKIP_CHAR_BUFFER, 0, (int) Math.min(remain, SKIP_BUFFER_SIZE)), SKIP_BUFFER_SIZE)) - input.read(SKIP_CHAR_BUFFER, 0, (int) Math.min(remain - n - input.read(SKIP_CHAR_BUFFER, 0, (int) Math.min(remain, SKIP_BUFFER_SIZE)) - input.read(SKIP_CHAR_BUFFER, 0, (int) Math.min(remain, SKIP_BUFFER_SIZE)), 2048)) > 0) && (!(input.read(SKIP_CHAR_BUFFER, 0, (int) Math.min(remain - n - input.read(SKIP_CHAR_BUFFER, 0, (int) Math.min(remain, SKIP_BUFFER_SIZE)) - input.read(SKIP_CHAR_BUFFER, 0, (int) Math.min(remain, SKIP_BUFFER_SIZE)) - input.read(SKIP_CHAR_BUFFER, 0, (int) Math.min(remain - n - input.read(SKIP_CHAR_BUFFER, 0, (int) Math.min(remain, SKIP_BUFFER_SIZE)), SKIP_BUFFER_SIZE)), 2048)) < 0)) && (!(remain - n - input.read(SKIP_CHAR_BUFFER, 0, (int) Math.min(remain, SKIP_BUFFER_SIZE)) - input.read(SKIP_CHAR_BUFFER, 0, (int) Math.min(remain, SKIP_BUFFER_SIZE)) - input.read(SKIP_CHAR_BUFFER, 0, (int) Math.min(remain - n - input.read(SKIP_CHAR_BUFFER, 0, (int) Math.min(remain, SKIP_BUFFER_SIZE)), SKIP_BUFFER_SIZE)) - input.read(SKIP_CHAR_BUFFER, 0, (int) Math.min(remain - n - input.read(SKIP_CHAR_BUFFER, 0, (int) Math.min(remain, SKIP_BUFFER_SIZE)) - input.read(SKIP_CHAR_BUFFER, 0, (int) Math.min(remain, SKIP_BUFFER_SIZE)), 2048)) > 0)) && (toSkip - remain - n - input.read(SKIP_CHAR_BUFFER, 0, (int) Math.min(remain, SKIP_BUFFER_SIZE)) - input.read(SKIP_CHAR_BUFFER, 0, (int) Math.min(remain, SKIP_BUFFER_SIZE)) - input.read(SKIP_CHAR_BUFFER, 0, (int) Math.min(remain - n - input.read(SKIP_CHAR_BUFFER, 0, (int) Math.min(remain, SKIP_BUFFER_SIZE)), SKIP_BUFFER_SIZE)) != inputOffset)",
          "z3Program": "from z3 import *\nfrom z3_all_models import *\n\ninputOffset0 = Int('inputOffset0')\nlength0 = Int('length0')\nDEFAULT_BUFFER_SIZE0 = Int('DEFAULT_BUFFER_SIZE0')\nremain0 = Int('remain0')\nn0 = Int('n0')\nSKIP_BUFFER_SIZE0 = Int('SKIP_BUFFER_SIZE0')\ntoSkip0 = Int('toSkip0')\nSKIP_CHAR_BUFFER0_isNull = Bool('SKIP_CHAR_BUFFER0_isNull')\n\nconstraints = [\n  DEFAULT_BUFFER_SIZE0 == 1024 * 4,\n  remain0 == remain - n,\n  n0 == input0.read(SKIP_CHAR_BUFFER0, 0, Math.min(remain0, SKIP_BUFFER_SIZE)),\n  SKIP_BUFFER_SIZE0 == 2048,\n  inputOffset0 >= -9223372036854775808, inputOffset0 <= 9223372036854775807, # implicit\n  length0 >= -9223372036854775808, length0 <= 9223372036854775807, # implicit\n  remain0 >= -9223372036854775808, remain0 <= 9223372036854775807, # implicit\n  n0 >= -9223372036854775808, n0 <= 9223372036854775807, # implicit\n  toSkip0 >= -9223372036854775808, toSkip0 <= 9223372036854775807, # implicit\n  And(And(And(And(And(And(inputOffset0 > 0, Not(inputOffset0 < 0)), Not(SKIP_CHAR_BUFFER0_isNull)), remain0 - n0 - input0.read(SKIP_CHAR_BUFFER0, 0, Math.min(remain0, SKIP_BUFFER_SIZE0)) - input0.read(SKIP_CHAR_BUFFER0, 0, Math.min(remain0 - n0, 2048)) > 0), Not(input0.read(SKIP_CHAR_BUFFER0, 0, Math.min(remain0 - n0 - input0.read(SKIP_CHAR_BUFFER0, 0, Math.min(remain0, SKIP_BUFFER_SIZE0)), 2048)) < 0)), Not(remain0 - n0 - input0.read(SKIP_CHAR_BUFFER0, 0, Math.min(remain0, SKIP_BUFFER_SIZE0)) - input0.read(SKIP_CHAR_BUFFER0, 0, Math.min(remain0 - n0, 2048)) > 0)), toSkip0 - remain0 - n0 - input0.read(SKIP_CHAR_BUFFER0, 0, Math.min(remain0, SKIP_BUFFER_SIZE0)) != inputOffset0)\n]\n\nsolver = Solver()\nfor constraint in constraints:\n  solver.add(constraint)\n\nmodels = list(all_smt(solver))\nfor model in models: print(model)",
          "symPyProgram": "from sympy import Symbol\nfrom sympy import simplify\nfrom sympy.core.relational import Eq, Ne, StrictGreaterThan, StrictLessThan, LessThan, GreaterThan\nfrom sympy.printing import ccode\n\ninput = Symbol('input')\ninputOffset = Symbol('inputOffset')\nSKIP_CHAR_BUFFER = Symbol('SKIP_CHAR_BUFFER')\ntoSkip = Symbol('toSkip')\ninput_read = Symbol('input_read')\nMath_min = Symbol('Math_min')\nnull = Symbol('null')\npath_conjunction = (((((((StrictGreaterThan(inputOffset, 0)) & (~((StrictLessThan(inputOffset, 0))))) & (~((Eq(SKIP_CHAR_BUFFER, null))))) & (StrictGreaterThan((((((remain - n) - input_read) - input_read) - input_read) - input_read), 0))) & (~((StrictLessThan(input_read, 0))))) & (~((StrictGreaterThan((((((remain - n) - input_read) - input_read) - input_read) - input_read), 0))))) & (Ne((((((toSkip - remain) - n) - input_read) - input_read) - input_read), inputOffset)))\nprint(ccode(simplify(path_conjunction)))",
          "soundSymbolic": true,
          "soundBackwards": false,
          "maybe": true,
          "line": 2564,
          "throwingLine": 2565,
          "isStatic": true,
          "targetOnlyArguments": false
        },
        {
          "qualifiedSignature": "org.apache.commons.io.IOUtils.copyLarge(java.io.Reader, java.io.Writer, long, long, char[])",
          "exception": "throw new EOFException(\"Chars to skip: \" + inputOffset + \" actual: \" + skipped)",
          "pathCojunction": "(inputOffset > 0) && (!(inputOffset < 0)) && (!(SKIP_CHAR_BUFFER == null)) && (remain - n - input.read(SKIP_CHAR_BUFFER, 0, (int) Math.min(remain, SKIP_BUFFER_SIZE)) > 0) && (!(input.read(SKIP_CHAR_BUFFER, 0, (int) Math.min(remain - n, 2048)) < 0)) && (!(remain - n - input.read(SKIP_CHAR_BUFFER, 0, (int) Math.min(remain, SKIP_BUFFER_SIZE)) > 0)) && (toSkip - remain - n != inputOffset)",
          "symbolicPathConjunction": "(inputOffset > 0) && (skipFully(input, inputOffset))",
          "backwardsPathConjunction": "(inputOffset > 0) && (!(inputOffset < 0)) && (!(SKIP_CHAR_BUFFER == null)) && (remain - n - input.read(SKIP_CHAR_BUFFER, 0, (int) Math.min(remain, SKIP_BUFFER_SIZE)) - input.read(SKIP_CHAR_BUFFER, 0, (int) Math.min(remain, SKIP_BUFFER_SIZE)) - input.read(SKIP_CHAR_BUFFER, 0, (int) Math.min(remain - n - input.read(SKIP_CHAR_BUFFER, 0, (int) Math.min(remain, SKIP_BUFFER_SIZE)), SKIP_BUFFER_SIZE)) > 0) && (!(input.read(SKIP_CHAR_BUFFER, 0, (int) Math.min(remain - n - input.read(SKIP_CHAR_BUFFER, 0, (int) Math.min(remain, SKIP_BUFFER_SIZE)) - input.read(SKIP_CHAR_BUFFER, 0, (int) Math.min(remain, SKIP_BUFFER_SIZE)), 2048)) < 0)) && (!(remain - n - input.read(SKIP_CHAR_BUFFER, 0, (int) Math.min(remain, SKIP_BUFFER_SIZE)) - input.read(SKIP_CHAR_BUFFER, 0, (int) Math.min(remain, SKIP_BUFFER_SIZE)) - input.read(SKIP_CHAR_BUFFER, 0, (int) Math.min(remain - n - input.read(SKIP_CHAR_BUFFER, 0, (int) Math.min(remain, SKIP_BUFFER_SIZE)), SKIP_BUFFER_SIZE)) > 0)) && (toSkip - remain - n - input.read(SKIP_CHAR_BUFFER, 0, (int) Math.min(remain, SKIP_BUFFER_SIZE)) - input.read(SKIP_CHAR_BUFFER, 0, (int) Math.min(remain, SKIP_BUFFER_SIZE)) != inputOffset)",
          "z3Program": "from z3 import *\nfrom z3_all_models import *\n\ninputOffset0 = Int('inputOffset0')\nlength0 = Int('length0')\nremain0 = Int('remain0')\nn0 = Int('n0')\nSKIP_BUFFER_SIZE0 = Int('SKIP_BUFFER_SIZE0')\ntoSkip0 = Int('toSkip0')\nSKIP_CHAR_BUFFER0_isNull = Bool('SKIP_CHAR_BUFFER0_isNull')\n\nconstraints = [\n  remain0 == remain - n,\n  n0 == input0.read(SKIP_CHAR_BUFFER0, 0, Math.min(remain0, SKIP_BUFFER_SIZE)),\n  SKIP_BUFFER_SIZE0 == 2048,\n  inputOffset0 >= -9223372036854775808, inputOffset0 <= 9223372036854775807, # implicit\n  length0 >= -9223372036854775808, length0 <= 9223372036854775807, # implicit\n  remain0 >= -9223372036854775808, remain0 <= 9223372036854775807, # implicit\n  n0 >= -9223372036854775808, n0 <= 9223372036854775807, # implicit\n  toSkip0 >= -9223372036854775808, toSkip0 <= 9223372036854775807, # implicit\n  And(And(And(And(And(And(inputOffset0 > 0, Not(inputOffset0 < 0)), Not(SKIP_CHAR_BUFFER0_isNull)), remain0 - n0 - input0.read(SKIP_CHAR_BUFFER0, 0, Math.min(remain0, SKIP_BUFFER_SIZE0)) > 0), Not(input0.read(SKIP_CHAR_BUFFER0, 0, Math.min(remain0 - n0, 2048)) < 0)), Not(remain0 - n0 - input0.read(SKIP_CHAR_BUFFER0, 0, Math.min(remain0, SKIP_BUFFER_SIZE0)) > 0)), toSkip0 - remain0 - n0 != inputOffset0)\n]\n\nsolver = Solver()\nfor constraint in constraints:\n  solver.add(constraint)\n\nmodels = list(all_smt(solver))\nfor model in models: print(model)",
          "symPyProgram": "from sympy import Symbol\nfrom sympy import simplify\nfrom sympy.core.relational import Eq, Ne, StrictGreaterThan, StrictLessThan, LessThan, GreaterThan\nfrom sympy.printing import ccode\n\ninput = Symbol('input')\ninputOffset = Symbol('inputOffset')\nSKIP_CHAR_BUFFER = Symbol('SKIP_CHAR_BUFFER')\ntoSkip = Symbol('toSkip')\ninput_read = Symbol('input_read')\nMath_min = Symbol('Math_min')\nnull = Symbol('null')\npath_conjunction = (((((((StrictGreaterThan(inputOffset, 0)) & (~((StrictLessThan(inputOffset, 0))))) & (~((Eq(SKIP_CHAR_BUFFER, null))))) & (StrictGreaterThan(((((remain - n) - input_read) - input_read) - input_read), 0))) & (~((StrictLessThan(input_read, 0))))) & (~((StrictGreaterThan(((((remain - n) - input_read) - input_read) - input_read), 0))))) & (Ne(((((toSkip - remain) - n) - input_read) - input_read), inputOffset)))\nprint(ccode(simplify(path_conjunction)))",
          "soundSymbolic": true,
          "soundBackwards": false,
          "maybe": true,
          "line": 2589,
          "throwingLine": 2591,
          "isStatic": true,
          "targetOnlyArguments": false
        },
        {
          "qualifiedSignature": "org.apache.commons.io.IOUtils.copyLarge(java.io.Reader, java.io.Writer, long, long, char[])",
          "exception": "throw new EOFException(\"Chars to skip: \" + inputOffset + \" actual: \" + skipped)",
          "pathCojunction": "(inputOffset > 0) && (!(inputOffset < 0)) && (!(SKIP_CHAR_BUFFER == null)) && (inputOffset > 0) && (input.read(SKIP_CHAR_BUFFER, 0, (int) Math.min(toSkip, 2048)) < 0) && (toSkip - toSkip != inputOffset)",
          "symbolicPathConjunction": "(inputOffset > 0) && (skipFully(input, inputOffset))",
          "backwardsPathConjunction": "(inputOffset > 0) && (!(inputOffset < 0)) && (!(SKIP_CHAR_BUFFER == null)) && (inputOffset > 0) && (input.read(SKIP_CHAR_BUFFER, 0, (int) Math.min(toSkip, 2048)) < 0) && (toSkip - toSkip != inputOffset)",
          "simplifiedPathConjunction": "inputOffset > 0 && input.read(SKIP_CHAR_BUFFER, 0, Math.min(toSkip, 2048)) < 0 && SKIP_CHAR_BUFFER != null",
          "z3Program": "from z3 import *\nfrom z3_all_models import *\n\ninputOffset0 = Int('inputOffset0')\nlength0 = Int('length0')\ntoSkip0 = Int('toSkip0')\nSKIP_CHAR_BUFFER0_isNull = Bool('SKIP_CHAR_BUFFER0_isNull')\n\nconstraints = [\n  inputOffset0 >= -9223372036854775808, inputOffset0 <= 9223372036854775807, # implicit\n  length0 >= -9223372036854775808, length0 <= 9223372036854775807, # implicit\n  toSkip0 >= -9223372036854775808, toSkip0 <= 9223372036854775807, # implicit\n  And(And(And(And(And(inputOffset0 > 0, Not(inputOffset0 < 0)), Not(SKIP_CHAR_BUFFER0_isNull)), inputOffset0 > 0), input0.read(SKIP_CHAR_BUFFER0, 0, Math.min(toSkip0, 2048)) < 0), toSkip0 - toSkip0 != inputOffset0)\n]\n\nsolver = Solver()\nfor constraint in constraints:\n  solver.add(constraint)\n\nmodels = list(all_smt(solver))\nfor model in models: print(model)",
          "symPyProgram": "from sympy import Symbol\nfrom sympy import simplify\nfrom sympy.core.relational import Eq, Ne, StrictGreaterThan, StrictLessThan, LessThan, GreaterThan\nfrom sympy.printing import ccode\n\ninput = Symbol('input')\ninputOffset = Symbol('inputOffset')\nSKIP_CHAR_BUFFER = Symbol('SKIP_CHAR_BUFFER')\ntoSkip = Symbol('toSkip')\ninput_read = Symbol('input_read')\nMath_min = Symbol('Math_min')\nnull = Symbol('null')\npath_conjunction = ((((((StrictGreaterThan(inputOffset, 0)) & (~((StrictLessThan(inputOffset, 0))))) & (~((Eq(SKIP_CHAR_BUFFER, null))))) & (StrictGreaterThan(inputOffset, 0))) & (StrictLessThan(input_read, 0))) & (Ne((toSkip - toSkip), inputOffset)))\nprint(ccode(simplify(path_conjunction)))",
          "soundSymbolic": true,
          "soundBackwards": false,
          "maybe": true,
          "line": 2589,
          "throwingLine": 2591,
          "isStatic": true,
          "targetOnlyArguments": false
        },
        {
          "qualifiedSignature": "org.apache.commons.io.IOUtils.skip(java.io.InputStream, long)",
          "exception": "throw new IllegalArgumentException(\"Skip count must be non-negative, actual: \" + toSkip);",
          "pathCojunction": "(toSkip < 0)",
          "symbolicPathConjunction": "(toSkip < 0)",
          "backwardsPathConjunction": "(toSkip < 0)",
          "simplifiedPathConjunction": "toSkip < 0",
          "z3Inputs": "[toSkip0 = -9223372036854775808]\n[toSkip0 = -1]\n[toSkip0 = -2]\n[toSkip0 = -3]\n[toSkip0 = -4]\n[toSkip0 = -5]\n[toSkip0 = -6]\n[toSkip0 = -7]\n[toSkip0 = -8]\n[toSkip0 = -9]\n",
          "z3Program": "from z3 import *\nfrom z3_all_models import *\n\ntoSkip0 = Int('toSkip0')\n\nconstraints = [\n  toSkip0 >= -9223372036854775808, toSkip0 <= 9223372036854775807, # implicit\n  toSkip0 < 0\n]\n\nsolver = Solver()\nfor constraint in constraints:\n  solver.add(constraint)\n\nmodels = list(all_smt(solver))\nfor model in models: print(model)",
          "symPyProgram": "from sympy import Symbol\nfrom sympy import simplify\nfrom sympy.core.relational import Eq, Ne, StrictGreaterThan, StrictLessThan, LessThan, GreaterThan\nfrom sympy.printing import ccode\n\ntoSkip = Symbol('toSkip')\npath_conjunction = (StrictLessThan(toSkip, 0))\nprint(ccode(simplify(path_conjunction)))",
          "soundSymbolic": true,
          "soundBackwards": true,
          "maybe": false,
          "line": 2833,
          "throwingLine": 2835,
          "isStatic": true,
          "targetOnlyArguments": true
        },
        {
          "qualifiedSignature": "org.apache.commons.io.IOUtils.skip(java.nio.channels.ReadableByteChannel, long)",
          "exception": "throw new IllegalArgumentException(\"Skip count must be non-negative, actual: \" + toSkip);",
          "pathCojunction": "(toSkip < 0)",
          "symbolicPathConjunction": "(toSkip < 0)",
          "backwardsPathConjunction": "(toSkip < 0)",
          "simplifiedPathConjunction": "toSkip < 0",
          "z3Inputs": "[toSkip0 = -9223372036854775808]\n[toSkip0 = -1]\n[toSkip0 = -2]\n[toSkip0 = -3]\n[toSkip0 = -4]\n[toSkip0 = -5]\n[toSkip0 = -6]\n[toSkip0 = -7]\n[toSkip0 = -8]\n[toSkip0 = -9]\n",
          "z3Program": "from z3 import *\nfrom z3_all_models import *\n\ntoSkip0 = Int('toSkip0')\n\nconstraints = [\n  toSkip0 >= -9223372036854775808, toSkip0 <= 9223372036854775807, # implicit\n  toSkip0 < 0\n]\n\nsolver = Solver()\nfor constraint in constraints:\n  solver.add(constraint)\n\nmodels = list(all_smt(solver))\nfor model in models: print(model)",
          "symPyProgram": "from sympy import Symbol\nfrom sympy import simplify\nfrom sympy.core.relational import Eq, Ne, StrictGreaterThan, StrictLessThan, LessThan, GreaterThan\nfrom sympy.printing import ccode\n\ntoSkip = Symbol('toSkip')\npath_conjunction = (StrictLessThan(toSkip, 0))\nprint(ccode(simplify(path_conjunction)))",
          "soundSymbolic": true,
          "soundBackwards": true,
          "maybe": false,
          "line": 2869,
          "throwingLine": 2871,
          "isStatic": true,
          "targetOnlyArguments": true
        },
        {
          "qualifiedSignature": "org.apache.commons.io.IOUtils.skip(java.io.Reader, long)",
          "exception": "throw new IllegalArgumentException(\"Skip count must be non-negative, actual: \" + toSkip);",
          "pathCojunction": "(toSkip < 0)",
          "symbolicPathConjunction": "(toSkip < 0)",
          "backwardsPathConjunction": "(toSkip < 0)",
          "simplifiedPathConjunction": "toSkip < 0",
          "z3Inputs": "[toSkip0 = -9223372036854775808]\n[toSkip0 = -1]\n[toSkip0 = -2]\n[toSkip0 = -3]\n[toSkip0 = -4]\n[toSkip0 = -5]\n[toSkip0 = -6]\n[toSkip0 = -7]\n[toSkip0 = -8]\n[toSkip0 = -9]\n",
          "z3Program": "from z3 import *\nfrom z3_all_models import *\n\ntoSkip0 = Int('toSkip0')\n\nconstraints = [\n  toSkip0 >= -9223372036854775808, toSkip0 <= 9223372036854775807, # implicit\n  toSkip0 < 0\n]\n\nsolver = Solver()\nfor constraint in constraints:\n  solver.add(constraint)\n\nmodels = list(all_smt(solver))\nfor model in models: print(model)",
          "symPyProgram": "from sympy import Symbol\nfrom sympy import simplify\nfrom sympy.core.relational import Eq, Ne, StrictGreaterThan, StrictLessThan, LessThan, GreaterThan\nfrom sympy.printing import ccode\n\ntoSkip = Symbol('toSkip')\npath_conjunction = (StrictLessThan(toSkip, 0))\nprint(ccode(simplify(path_conjunction)))",
          "soundSymbolic": true,
          "soundBackwards": true,
          "maybe": false,
          "line": 2908,
          "throwingLine": 2910,
          "isStatic": true,
          "targetOnlyArguments": true
        },
        {
          "qualifiedSignature": "org.apache.commons.io.IOUtils.skipFully(java.io.InputStream, long)",
          "exception": "throw new EOFException(\"Bytes to skip: \" + toSkip + \" actual: \" + skipped);",
          "pathCojunction": "(!(toSkip < 0)) && (!(toSkip < 0)) && (!(SKIP_BYTE_BUFFER == null)) && (remain - n > 0) && (!(input.read(SKIP_BYTE_BUFFER, 0, (int) Math.min(remain, SKIP_BUFFER_SIZE)) < 0)) && (!(remain - n > 0)) && (skipped != toSkip)",
          "symbolicPathConjunction": "(!(toSkip < 0)) && (skip(input, toSkip)) && (skipped != toSkip)",
          "backwardsPathConjunction": "(!(toSkip < 0)) && (!(toSkip < 0)) && (!(SKIP_BYTE_BUFFER == null)) && (remain - n - input.read(SKIP_BYTE_BUFFER, 0, (int) Math.min(remain, SKIP_BUFFER_SIZE)) - input.read(SKIP_BYTE_BUFFER, 0, (int) Math.min(remain, SKIP_BUFFER_SIZE)) > 0) && (!(input.read(SKIP_BYTE_BUFFER, 0, (int) Math.min(remain - n - input.read(SKIP_BYTE_BUFFER, 0, (int) Math.min(remain, SKIP_BUFFER_SIZE)), SKIP_BUFFER_SIZE)) < 0)) && (!(remain - n - input.read(SKIP_BYTE_BUFFER, 0, (int) Math.min(remain, SKIP_BUFFER_SIZE)) - input.read(SKIP_BYTE_BUFFER, 0, (int) Math.min(remain, SKIP_BUFFER_SIZE)) > 0)) && (toSkip - remain - input.read(SKIP_BYTE_BUFFER, 0, (int) Math.min(remain, SKIP_BUFFER_SIZE)) != toSkip)",
          "z3Program": "from z3 import *\nfrom z3_all_models import *\n\ntoSkip0 = Int('toSkip0')\nremain0 = Int('remain0')\nn0 = Int('n0')\nSKIP_BUFFER_SIZE0 = Int('SKIP_BUFFER_SIZE0')\nskipped0 = Int('skipped0')\nSKIP_BYTE_BUFFER0_isNull = Bool('SKIP_BYTE_BUFFER0_isNull')\n\nconstraints = [\n  remain0 == remain - n,\n  n0 == input0.read(SKIP_BYTE_BUFFER0, 0, Math.min(remain0, SKIP_BUFFER_SIZE)),\n  SKIP_BUFFER_SIZE0 == 2048,\n  skipped0 == toSkip0 - remain0 - n0,\n  toSkip0 >= -9223372036854775808, toSkip0 <= 9223372036854775807, # implicit\n  remain0 >= -9223372036854775808, remain0 <= 9223372036854775807, # implicit\n  n0 >= -9223372036854775808, n0 <= 9223372036854775807, # implicit\n  skipped0 >= -9223372036854775808, skipped0 <= 9223372036854775807, # implicit\n  And(And(And(And(And(And(Not(toSkip0 < 0), Not(toSkip0 < 0)), Not(SKIP_BYTE_BUFFER0_isNull)), remain0 - n0 > 0), Not(input0.read(SKIP_BYTE_BUFFER0, 0, Math.min(remain0, SKIP_BUFFER_SIZE0)) < 0)), Not(remain0 - n0 > 0)), skipped0 != toSkip0)\n]\n\nsolver = Solver()\nfor constraint in constraints:\n  solver.add(constraint)\n\nmodels = list(all_smt(solver))\nfor model in models: print(model)",
          "symPyProgram": "from sympy import Symbol\nfrom sympy import simplify\nfrom sympy.core.relational import Eq, Ne, StrictGreaterThan, StrictLessThan, LessThan, GreaterThan\nfrom sympy.printing import ccode\n\ninput = Symbol('input')\ntoSkip = Symbol('toSkip')\nSKIP_BYTE_BUFFER = Symbol('SKIP_BYTE_BUFFER')\ninput_read = Symbol('input_read')\nMath_min = Symbol('Math_min')\nnull = Symbol('null')\npath_conjunction = (((((((~((StrictLessThan(toSkip, 0)))) & (~((StrictLessThan(toSkip, 0))))) & (~((Eq(SKIP_BYTE_BUFFER, null))))) & (StrictGreaterThan((((remain - n) - input_read) - input_read), 0))) & (~((StrictLessThan(input_read, 0))))) & (~((StrictGreaterThan((((remain - n) - input_read) - input_read), 0))))) & (Ne(((toSkip - remain) - input_read), toSkip)))\nprint(ccode(simplify(path_conjunction)))",
          "soundSymbolic": true,
          "soundBackwards": false,
          "maybe": true,
          "line": 2951,
          "throwingLine": 2957,
          "isStatic": true,
          "targetOnlyArguments": false
        },
        {
          "qualifiedSignature": "org.apache.commons.io.IOUtils.skipFully(java.io.InputStream, long)",
          "exception": "throw new EOFException(\"Bytes to skip: \" + toSkip + \" actual: \" + skipped);",
          "pathCojunction": "(!(toSkip < 0)) && (!(toSkip < 0)) && (!(SKIP_BYTE_BUFFER == null)) && (toSkip > 0) && (input.read(SKIP_BYTE_BUFFER, 0, (int) Math.min(remain, SKIP_BUFFER_SIZE)) < 0) && (skipped != toSkip)",
          "symbolicPathConjunction": "(!(toSkip < 0)) && (skip(input, toSkip)) && (skipped != toSkip)",
          "backwardsPathConjunction": "(!(toSkip < 0)) && (!(toSkip < 0)) && (!(SKIP_BYTE_BUFFER == null)) && (toSkip > 0) && (input.read(SKIP_BYTE_BUFFER, 0, (int) Math.min(toSkip, SKIP_BUFFER_SIZE)) < 0) && (toSkip - toSkip != toSkip)",
          "simplifiedPathConjunction": "toSkip > 0 && input.read(SKIP_BYTE_BUFFER, 0, Math.min(toSkip, 2048)) < 0 && SKIP_BYTE_BUFFER != null",
          "z3Program": "from z3 import *\nfrom z3_all_models import *\n\ntoSkip0 = Int('toSkip0')\nremain0 = Int('remain0')\nSKIP_BUFFER_SIZE0 = Int('SKIP_BUFFER_SIZE0')\nskipped0 = Int('skipped0')\nSKIP_BYTE_BUFFER0_isNull = Bool('SKIP_BYTE_BUFFER0_isNull')\n\nconstraints = [\n  remain0 == toSkip0,\n  SKIP_BUFFER_SIZE0 == 2048,\n  skipped0 == toSkip0 - toSkip0,\n  toSkip0 >= -9223372036854775808, toSkip0 <= 9223372036854775807, # implicit\n  remain0 >= -9223372036854775808, remain0 <= 9223372036854775807, # implicit\n  skipped0 >= -9223372036854775808, skipped0 <= 9223372036854775807, # implicit\n  And(And(And(And(And(Not(toSkip0 < 0), Not(toSkip0 < 0)), Not(SKIP_BYTE_BUFFER0_isNull)), toSkip0 > 0), input0.read(SKIP_BYTE_BUFFER0, 0, Math.min(remain0, SKIP_BUFFER_SIZE0)) < 0), skipped0 != toSkip0)\n]\n\nsolver = Solver()\nfor constraint in constraints:\n  solver.add(constraint)\n\nmodels = list(all_smt(solver))\nfor model in models: print(model)",
          "symPyProgram": "from sympy import Symbol\nfrom sympy import simplify\nfrom sympy.core.relational import Eq, Ne, StrictGreaterThan, StrictLessThan, LessThan, GreaterThan\nfrom sympy.printing import ccode\n\ninput = Symbol('input')\ntoSkip = Symbol('toSkip')\nSKIP_BYTE_BUFFER = Symbol('SKIP_BYTE_BUFFER')\ninput_read = Symbol('input_read')\nMath_min = Symbol('Math_min')\nnull = Symbol('null')\npath_conjunction = ((((((~((StrictLessThan(toSkip, 0)))) & (~((StrictLessThan(toSkip, 0))))) & (~((Eq(SKIP_BYTE_BUFFER, null))))) & (StrictGreaterThan(toSkip, 0))) & (StrictLessThan(input_read, 0))) & (Ne((toSkip - toSkip), toSkip)))\nprint(ccode(simplify(path_conjunction)))",
          "soundSymbolic": true,
          "soundBackwards": false,
          "maybe": true,
          "line": 2951,
          "throwingLine": 2957,
          "isStatic": true,
          "targetOnlyArguments": false
        },
        {
          "qualifiedSignature": "org.apache.commons.io.IOUtils.skipFully(java.io.InputStream, long)",
          "exception": "throw new IllegalArgumentException(\"Bytes to skip must not be negative: \" + toSkip);",
          "pathCojunction": "(toSkip < 0)",
          "symbolicPathConjunction": "(toSkip < 0)",
          "backwardsPathConjunction": "(toSkip < 0)",
          "simplifiedPathConjunction": "toSkip < 0",
          "z3Inputs": "[toSkip0 = -9223372036854775808]\n[toSkip0 = -1]\n[toSkip0 = -2]\n[toSkip0 = -3]\n[toSkip0 = -4]\n[toSkip0 = -5]\n[toSkip0 = -6]\n[toSkip0 = -7]\n[toSkip0 = -8]\n[toSkip0 = -9]\n",
          "z3Program": "from z3 import *\nfrom z3_all_models import *\n\ntoSkip0 = Int('toSkip0')\n\nconstraints = [\n  toSkip0 >= -9223372036854775808, toSkip0 <= 9223372036854775807, # implicit\n  toSkip0 < 0\n]\n\nsolver = Solver()\nfor constraint in constraints:\n  solver.add(constraint)\n\nmodels = list(all_smt(solver))\nfor model in models: print(model)",
          "symPyProgram": "from sympy import Symbol\nfrom sympy import simplify\nfrom sympy.core.relational import Eq, Ne, StrictGreaterThan, StrictLessThan, LessThan, GreaterThan\nfrom sympy.printing import ccode\n\ntoSkip = Symbol('toSkip')\npath_conjunction = (StrictLessThan(toSkip, 0))\nprint(ccode(simplify(path_conjunction)))",
          "soundSymbolic": true,
          "soundBackwards": true,
          "maybe": false,
          "line": 2951,
          "throwingLine": 2953,
          "isStatic": true,
          "targetOnlyArguments": true
        },
        {
          "qualifiedSignature": "org.apache.commons.io.IOUtils.skipFully(java.nio.channels.ReadableByteChannel, long)",
          "exception": "throw new EOFException(\"Bytes to skip: \" + toSkip + \" actual: \" + skipped);",
          "pathCojunction": "(!(toSkip < 0)) && (!(toSkip < 0)) && (remain - n > 0) && (!(input.read(skipByteBuffer) == -1)) && (!(remain - n > 0)) && (skipped != toSkip)",
          "symbolicPathConjunction": "(!(toSkip < 0)) && (skip(input, toSkip)) && (skipped != toSkip)",
          "backwardsPathConjunction": "(!(toSkip < 0)) && (!(toSkip < 0)) && (remain - n - input.read(skipByteBuffer) - input.read(ByteBuffer.allocate((int) Math.min(toSkip, SKIP_BUFFER_SIZE))) > 0) && (!(input.read(ByteBuffer.allocate((int) Math.min(toSkip, SKIP_BUFFER_SIZE))) == -1)) && (!(remain - n - input.read(skipByteBuffer) - input.read(ByteBuffer.allocate((int) Math.min(toSkip, SKIP_BUFFER_SIZE))) > 0)) && (toSkip - remain - input.read(skipByteBuffer) != toSkip)",
          "z3Program": "from z3 import *\nfrom z3_all_models import *\n\ntoSkip0 = Int('toSkip0')\nremain0 = Int('remain0')\nn0 = Int('n0')\nskipped0 = Int('skipped0')\n\nconstraints = [\n  skipByteBuffer0 == ByteBuffer.allocate(Math.min(toSkip0, SKIP_BUFFER_SIZE)),\n  remain0 == remain - n,\n  n0 == input0.read(skipByteBuffer0),\n  skipped0 == toSkip0 - remain0 - n0,\n  toSkip0 >= -9223372036854775808, toSkip0 <= 9223372036854775807, # implicit\n  remain0 >= -9223372036854775808, remain0 <= 9223372036854775807, # implicit\n  skipped0 >= -9223372036854775808, skipped0 <= 9223372036854775807, # implicit\n  And(And(And(And(And(Not(toSkip0 < 0), Not(toSkip0 < 0)), remain0 - n0 > 0), Not(input0.read(skipByteBuffer0) == -1)), Not(remain0 - n0 > 0)), skipped0 != toSkip0)\n]\n\nsolver = Solver()\nfor constraint in constraints:\n  solver.add(constraint)\n\nmodels = list(all_smt(solver))\nfor model in models: print(model)",
          "symPyProgram": "from sympy import Symbol\nfrom sympy import simplify\nfrom sympy.core.relational import Eq, Ne, StrictGreaterThan, StrictLessThan, LessThan, GreaterThan\nfrom sympy.printing import ccode\n\ninput = Symbol('input')\ntoSkip = Symbol('toSkip')\ninput_read = Symbol('input_read')\nByteBuffer_allocate = Symbol('ByteBuffer_allocate')\nMath_min = Symbol('Math_min')\npath_conjunction = ((((((~((StrictLessThan(toSkip, 0)))) & (~((StrictLessThan(toSkip, 0))))) & (StrictGreaterThan((((remain - n) - input_read) - input_read), 0))) & (~((Eq(input_read, -1))))) & (~((StrictGreaterThan((((remain - n) - input_read) - input_read), 0))))) & (Ne(((toSkip - remain) - input_read), toSkip)))\nprint(ccode(simplify(path_conjunction)))",
          "soundSymbolic": true,
          "soundBackwards": false,
          "maybe": true,
          "line": 2971,
          "throwingLine": 2977,
          "isStatic": true,
          "targetOnlyArguments": false
        },
        {
          "qualifiedSignature": "org.apache.commons.io.IOUtils.skipFully(java.nio.channels.ReadableByteChannel, long)",
          "exception": "throw new IllegalArgumentException(\"Bytes to skip must not be negative: \" + toSkip);",
          "pathCojunction": "(toSkip < 0)",
          "symbolicPathConjunction": "(toSkip < 0)",
          "backwardsPathConjunction": "(toSkip < 0)",
          "simplifiedPathConjunction": "toSkip < 0",
          "z3Inputs": "[toSkip0 = -9223372036854775808]\n[toSkip0 = -1]\n[toSkip0 = -2]\n[toSkip0 = -3]\n[toSkip0 = -4]\n[toSkip0 = -5]\n[toSkip0 = -6]\n[toSkip0 = -7]\n[toSkip0 = -8]\n[toSkip0 = -9]\n",
          "z3Program": "from z3 import *\nfrom z3_all_models import *\n\ntoSkip0 = Int('toSkip0')\n\nconstraints = [\n  toSkip0 >= -9223372036854775808, toSkip0 <= 9223372036854775807, # implicit\n  toSkip0 < 0\n]\n\nsolver = Solver()\nfor constraint in constraints:\n  solver.add(constraint)\n\nmodels = list(all_smt(solver))\nfor model in models: print(model)",
          "symPyProgram": "from sympy import Symbol\nfrom sympy import simplify\nfrom sympy.core.relational import Eq, Ne, StrictGreaterThan, StrictLessThan, LessThan, GreaterThan\nfrom sympy.printing import ccode\n\ntoSkip = Symbol('toSkip')\npath_conjunction = (StrictLessThan(toSkip, 0))\nprint(ccode(simplify(path_conjunction)))",
          "soundSymbolic": true,
          "soundBackwards": true,
          "maybe": false,
          "line": 2971,
          "throwingLine": 2973,
          "isStatic": true,
          "targetOnlyArguments": true
        },
        {
          "qualifiedSignature": "org.apache.commons.io.IOUtils.skipFully(java.nio.channels.ReadableByteChannel, long)",
          "exception": "throw new EOFException(\"Bytes to skip: \" + toSkip + \" actual: \" + skipped);",
          "pathCojunction": "(!(toSkip < 0)) && (!(toSkip < 0)) && (toSkip > 0) && (input.read(skipByteBuffer) == -1) && (skipped != toSkip)",
          "symbolicPathConjunction": "(!(toSkip < 0)) && (skip(input, toSkip)) && (skipped != toSkip)",
          "backwardsPathConjunction": "(!(toSkip < 0)) && (!(toSkip < 0)) && (toSkip > 0) && (input.read(ByteBuffer.allocate((int) Math.min(toSkip, SKIP_BUFFER_SIZE))) == -1) && (toSkip - toSkip != toSkip)",
          "simplifiedPathConjunction": "input.read(ByteBuffer.allocate(Math.min(toSkip, SKIP_BUFFER_SIZE))) == -1 && toSkip > 0",
          "z3Program": "from z3 import *\nfrom z3_all_models import *\n\ntoSkip0 = Int('toSkip0')\nskipped0 = Int('skipped0')\n\nconstraints = [\n  skipByteBuffer0 == ByteBuffer.allocate(Math.min(toSkip0, SKIP_BUFFER_SIZE)),\n  skipped0 == toSkip0 - toSkip0,\n  toSkip0 >= -9223372036854775808, toSkip0 <= 9223372036854775807, # implicit\n  skipped0 >= -9223372036854775808, skipped0 <= 9223372036854775807, # implicit\n  And(And(And(And(Not(toSkip0 < 0), Not(toSkip0 < 0)), toSkip0 > 0), input0.read(skipByteBuffer0) == -1), skipped0 != toSkip0)\n]\n\nsolver = Solver()\nfor constraint in constraints:\n  solver.add(constraint)\n\nmodels = list(all_smt(solver))\nfor model in models: print(model)",
          "symPyProgram": "from sympy import Symbol\nfrom sympy import simplify\nfrom sympy.core.relational import Eq, Ne, StrictGreaterThan, StrictLessThan, LessThan, GreaterThan\nfrom sympy.printing import ccode\n\ninput = Symbol('input')\ntoSkip = Symbol('toSkip')\ninput_read = Symbol('input_read')\nByteBuffer_allocate = Symbol('ByteBuffer_allocate')\nMath_min = Symbol('Math_min')\npath_conjunction = (((((~((StrictLessThan(toSkip, 0)))) & (~((StrictLessThan(toSkip, 0))))) & (StrictGreaterThan(toSkip, 0))) & (Eq(input_read, -1))) & (Ne((toSkip - toSkip), toSkip)))\nprint(ccode(simplify(path_conjunction)))",
          "soundSymbolic": true,
          "soundBackwards": false,
          "maybe": true,
          "line": 2971,
          "throwingLine": 2977,
          "isStatic": true,
          "targetOnlyArguments": false
        },
        {
          "qualifiedSignature": "org.apache.commons.io.IOUtils.skipFully(java.io.Reader, long)",
          "exception": "throw new EOFException(\"Chars to skip: \" + toSkip + \" actual: \" + skipped);",
          "pathCojunction": "(!(toSkip < 0)) && (!(SKIP_CHAR_BUFFER == null)) && (remain - n > 0) && (!(input.read(SKIP_CHAR_BUFFER, 0, (int) Math.min(remain, SKIP_BUFFER_SIZE)) < 0)) && (!(remain - n > 0)) && (skipped != toSkip)",
          "symbolicPathConjunction": "(skip(input, toSkip)) && (skipped != toSkip)",
          "backwardsPathConjunction": "(!(toSkip < 0)) && (!(SKIP_CHAR_BUFFER == null)) && (remain - n - input.read(SKIP_CHAR_BUFFER, 0, (int) Math.min(remain, SKIP_BUFFER_SIZE)) - input.read(SKIP_CHAR_BUFFER, 0, (int) Math.min(remain, SKIP_BUFFER_SIZE)) > 0) && (!(input.read(SKIP_CHAR_BUFFER, 0, (int) Math.min(remain - n - input.read(SKIP_CHAR_BUFFER, 0, (int) Math.min(remain, SKIP_BUFFER_SIZE)), SKIP_BUFFER_SIZE)) < 0)) && (!(remain - n - input.read(SKIP_CHAR_BUFFER, 0, (int) Math.min(remain, SKIP_BUFFER_SIZE)) - input.read(SKIP_CHAR_BUFFER, 0, (int) Math.min(remain, SKIP_BUFFER_SIZE)) > 0)) && (toSkip - remain - input.read(SKIP_CHAR_BUFFER, 0, (int) Math.min(remain, SKIP_BUFFER_SIZE)) != toSkip)",
          "z3Program": "from z3 import *\nfrom z3_all_models import *\n\ntoSkip0 = Int('toSkip0')\nremain0 = Int('remain0')\nn0 = Int('n0')\nSKIP_BUFFER_SIZE0 = Int('SKIP_BUFFER_SIZE0')\nskipped0 = Int('skipped0')\nSKIP_CHAR_BUFFER0_isNull = Bool('SKIP_CHAR_BUFFER0_isNull')\n\nconstraints = [\n  remain0 == remain - n,\n  n0 == input0.read(SKIP_CHAR_BUFFER0, 0, Math.min(remain0, SKIP_BUFFER_SIZE)),\n  SKIP_BUFFER_SIZE0 == 2048,\n  skipped0 == toSkip0 - remain0 - n0,\n  toSkip0 >= -9223372036854775808, toSkip0 <= 9223372036854775807, # implicit\n  remain0 >= -9223372036854775808, remain0 <= 9223372036854775807, # implicit\n  n0 >= -9223372036854775808, n0 <= 9223372036854775807, # implicit\n  skipped0 >= -9223372036854775808, skipped0 <= 9223372036854775807, # implicit\n  And(And(And(And(And(Not(toSkip0 < 0), Not(SKIP_CHAR_BUFFER0_isNull)), remain0 - n0 > 0), Not(input0.read(SKIP_CHAR_BUFFER0, 0, Math.min(remain0, SKIP_BUFFER_SIZE0)) < 0)), Not(remain0 - n0 > 0)), skipped0 != toSkip0)\n]\n\nsolver = Solver()\nfor constraint in constraints:\n  solver.add(constraint)\n\nmodels = list(all_smt(solver))\nfor model in models: print(model)",
          "symPyProgram": "from sympy import Symbol\nfrom sympy import simplify\nfrom sympy.core.relational import Eq, Ne, StrictGreaterThan, StrictLessThan, LessThan, GreaterThan\nfrom sympy.printing import ccode\n\ninput = Symbol('input')\ntoSkip = Symbol('toSkip')\nSKIP_CHAR_BUFFER = Symbol('SKIP_CHAR_BUFFER')\ninput_read = Symbol('input_read')\nMath_min = Symbol('Math_min')\nnull = Symbol('null')\npath_conjunction = ((((((~((StrictLessThan(toSkip, 0)))) & (~((Eq(SKIP_CHAR_BUFFER, null))))) & (StrictGreaterThan((((remain - n) - input_read) - input_read), 0))) & (~((StrictLessThan(input_read, 0))))) & (~((StrictGreaterThan((((remain - n) - input_read) - input_read), 0))))) & (Ne(((toSkip - remain) - input_read), toSkip)))\nprint(ccode(simplify(path_conjunction)))",
          "soundSymbolic": true,
          "soundBackwards": false,
          "maybe": true,
          "line": 3000,
          "throwingLine": 3003,
          "isStatic": true,
          "targetOnlyArguments": false
        },
        {
          "qualifiedSignature": "org.apache.commons.io.IOUtils.skipFully(java.io.Reader, long)",
          "exception": "throw new EOFException(\"Chars to skip: \" + toSkip + \" actual: \" + skipped);",
          "pathCojunction": "(!(toSkip < 0)) && (!(SKIP_CHAR_BUFFER == null)) && (toSkip > 0) && (input.read(SKIP_CHAR_BUFFER, 0, (int) Math.min(remain, SKIP_BUFFER_SIZE)) < 0) && (skipped != toSkip)",
          "symbolicPathConjunction": "(skip(input, toSkip)) && (skipped != toSkip)",
          "backwardsPathConjunction": "(!(toSkip < 0)) && (!(SKIP_CHAR_BUFFER == null)) && (toSkip > 0) && (input.read(SKIP_CHAR_BUFFER, 0, (int) Math.min(toSkip, SKIP_BUFFER_SIZE)) < 0) && (toSkip - toSkip != toSkip)",
          "simplifiedPathConjunction": "toSkip > 0 && input.read(SKIP_CHAR_BUFFER, 0, Math.min(toSkip, 2048)) < 0 && SKIP_CHAR_BUFFER != null",
          "z3Program": "from z3 import *\nfrom z3_all_models import *\n\ntoSkip0 = Int('toSkip0')\nremain0 = Int('remain0')\nSKIP_BUFFER_SIZE0 = Int('SKIP_BUFFER_SIZE0')\nskipped0 = Int('skipped0')\nSKIP_CHAR_BUFFER0_isNull = Bool('SKIP_CHAR_BUFFER0_isNull')\n\nconstraints = [\n  remain0 == toSkip0,\n  SKIP_BUFFER_SIZE0 == 2048,\n  skipped0 == toSkip0 - toSkip0,\n  toSkip0 >= -9223372036854775808, toSkip0 <= 9223372036854775807, # implicit\n  remain0 >= -9223372036854775808, remain0 <= 9223372036854775807, # implicit\n  skipped0 >= -9223372036854775808, skipped0 <= 9223372036854775807, # implicit\n  And(And(And(And(Not(toSkip0 < 0), Not(SKIP_CHAR_BUFFER0_isNull)), toSkip0 > 0), input0.read(SKIP_CHAR_BUFFER0, 0, Math.min(remain0, SKIP_BUFFER_SIZE0)) < 0), skipped0 != toSkip0)\n]\n\nsolver = Solver()\nfor constraint in constraints:\n  solver.add(constraint)\n\nmodels = list(all_smt(solver))\nfor model in models: print(model)",
          "symPyProgram": "from sympy import Symbol\nfrom sympy import simplify\nfrom sympy.core.relational import Eq, Ne, StrictGreaterThan, StrictLessThan, LessThan, GreaterThan\nfrom sympy.printing import ccode\n\ninput = Symbol('input')\ntoSkip = Symbol('toSkip')\nSKIP_CHAR_BUFFER = Symbol('SKIP_CHAR_BUFFER')\ninput_read = Symbol('input_read')\nMath_min = Symbol('Math_min')\nnull = Symbol('null')\npath_conjunction = (((((~((StrictLessThan(toSkip, 0)))) & (~((Eq(SKIP_CHAR_BUFFER, null))))) & (StrictGreaterThan(toSkip, 0))) & (StrictLessThan(input_read, 0))) & (Ne((toSkip - toSkip), toSkip)))\nprint(ccode(simplify(path_conjunction)))",
          "soundSymbolic": true,
          "soundBackwards": false,
          "maybe": true,
          "line": 3000,
          "throwingLine": 3003,
          "isStatic": true,
          "targetOnlyArguments": false
        },
        {
          "qualifiedSignature": "org.apache.commons.io.IOUtils.skipFully(java.io.Reader, long)",
          "exception": "throw new IllegalArgumentException(\"Skip count must be non-negative, actual: \" + toSkip);",
          "pathCojunction": "(toSkip < 0)",
          "symbolicPathConjunction": "(skip(input, toSkip))",
          "backwardsPathConjunction": "(toSkip < 0)",
          "simplifiedPathConjunction": "toSkip < 0",
          "z3Inputs": "[toSkip0 = -9223372036854775808]\n[toSkip0 = -1]\n[toSkip0 = -2]\n[toSkip0 = -3]\n[toSkip0 = -4]\n[toSkip0 = -5]\n[toSkip0 = -6]\n[toSkip0 = -7]\n[toSkip0 = -8]\n[toSkip0 = -9]\n",
          "z3Program": "from z3 import *\nfrom z3_all_models import *\n\ntoSkip0 = Int('toSkip0')\n\nconstraints = [\n  toSkip0 >= -9223372036854775808, toSkip0 <= 9223372036854775807, # implicit\n  toSkip0 < 0\n]\n\nsolver = Solver()\nfor constraint in constraints:\n  solver.add(constraint)\n\nmodels = list(all_smt(solver))\nfor model in models: print(model)",
          "symPyProgram": "from sympy import Symbol\nfrom sympy import simplify\nfrom sympy.core.relational import Eq, Ne, StrictGreaterThan, StrictLessThan, LessThan, GreaterThan\nfrom sympy.printing import ccode\n\ntoSkip = Symbol('toSkip')\npath_conjunction = (StrictLessThan(toSkip, 0))\nprint(ccode(simplify(path_conjunction)))",
          "soundSymbolic": true,
          "soundBackwards": true,
          "maybe": false,
          "line": 3000,
          "throwingLine": 3001,
          "isStatic": true,
          "targetOnlyArguments": true
        },
        {
          "qualifiedSignature": "org.apache.commons.io.IOUtils.read(java.io.Reader, char[], int, int)",
          "exception": "throw new IllegalArgumentException(\"Length must not be negative: \" + length);",
          "pathCojunction": "(length < 0)",
          "symbolicPathConjunction": "(length < 0)",
          "backwardsPathConjunction": "(length < 0)",
          "simplifiedPathConjunction": "length < 0",
          "z3Inputs": "[length0 = -1]\n[length0 = -2]\n[length0 = -3]\n[length0 = -4]\n[length0 = -5]\n[length0 = -6]\n[length0 = -7]\n[length0 = -8]\n[length0 = -9]\n[length0 = -10]\n",
          "z3Program": "from z3 import *\nfrom z3_all_models import *\n\noffset0 = Int('offset0')\nlength0 = Int('length0')\n\nconstraints = [\n  length0 < 0\n]\n\nsolver = Solver()\nfor constraint in constraints:\n  solver.add(constraint)\n\nmodels = list(all_smt(solver))\nfor model in models: print(model)",
          "symPyProgram": "from sympy import Symbol\nfrom sympy import simplify\nfrom sympy.core.relational import Eq, Ne, StrictGreaterThan, StrictLessThan, LessThan, GreaterThan\nfrom sympy.printing import ccode\n\nlength = Symbol('length', integer=True)\npath_conjunction = (StrictLessThan(length, 0))\nprint(ccode(simplify(path_conjunction)))",
          "soundSymbolic": true,
          "soundBackwards": true,
          "maybe": false,
          "line": 3023,
          "throwingLine": 3025,
          "isStatic": true,
          "targetOnlyArguments": true
        },
        {
          "qualifiedSignature": "org.apache.commons.io.IOUtils.read(java.io.InputStream, byte[], int, int)",
          "exception": "throw new IllegalArgumentException(\"Length must not be negative: \" + length);",
          "pathCojunction": "(length < 0)",
          "symbolicPathConjunction": "(length < 0)",
          "backwardsPathConjunction": "(length < 0)",
          "simplifiedPathConjunction": "length < 0",
          "z3Inputs": "[length0 = -1]\n[length0 = -2]\n[length0 = -3]\n[length0 = -4]\n[length0 = -5]\n[length0 = -6]\n[length0 = -7]\n[length0 = -8]\n[length0 = -9]\n[length0 = -10]\n",
          "z3Program": "from z3 import *\nfrom z3_all_models import *\n\noffset0 = Int('offset0')\nlength0 = Int('length0')\n\nconstraints = [\n  length0 < 0\n]\n\nsolver = Solver()\nfor constraint in constraints:\n  solver.add(constraint)\n\nmodels = list(all_smt(solver))\nfor model in models: print(model)",
          "symPyProgram": "from sympy import Symbol\nfrom sympy import simplify\nfrom sympy.core.relational import Eq, Ne, StrictGreaterThan, StrictLessThan, LessThan, GreaterThan\nfrom sympy.printing import ccode\n\nlength = Symbol('length', integer=True)\npath_conjunction = (StrictLessThan(length, 0))\nprint(ccode(simplify(path_conjunction)))",
          "soundSymbolic": true,
          "soundBackwards": true,
          "maybe": false,
          "line": 3070,
          "throwingLine": 3072,
          "isStatic": true,
          "targetOnlyArguments": true
        },
        {
          "qualifiedSignature": "org.apache.commons.io.IOUtils.readFully(java.io.Reader, char[], int, int)",
          "exception": "throw new EOFException(\"Length to read: \" + length + \" actual: \" + actual);",
          "pathCojunction": "(!(length < 0)) && (length > 0) && (-1 == input.read(buffer, offset + location, remaining)) && (actual != length)",
          "symbolicPathConjunction": "(read(input, buffer, offset, length)) && (actual != length)",
          "backwardsPathConjunction": "(!(length < 0)) && (length > 0) && (-1 == input.read(buffer, offset + length - length, length)) && (length - length != length)",
          "simplifiedPathConjunction": "input.read(buffer, offset + length - length, length) == -1 && length > 0",
          "z3Program": "from z3 import *\nfrom z3_all_models import *\n\noffset0 = Int('offset0')\nlength0 = Int('length0')\nlocation0 = Int('location0')\nremaining0 = Int('remaining0')\nactual0 = Int('actual0')\n\nconstraints = [\n  location0 == length0 - remaining,\n  remaining0 == length0,\n  actual0 == length0 - length0,\n  And(And(And(Not(length0 < 0), length0 > 0), -1 == input0.read(buffer0, offset0 + location0, remaining0)), actual0 != length0)\n]\n\nsolver = Solver()\nfor constraint in constraints:\n  solver.add(constraint)\n\nmodels = list(all_smt(solver))\nfor model in models: print(model)",
          "symPyProgram": "from sympy import Symbol\nfrom sympy import simplify\nfrom sympy.core.relational import Eq, Ne, StrictGreaterThan, StrictLessThan, LessThan, GreaterThan\nfrom sympy.printing import ccode\n\ninput = Symbol('input')\nbuffer = Symbol('buffer')\noffset = Symbol('offset', integer=True)\nlength = Symbol('length', integer=True)\ninput_read = Symbol('input_read')\npath_conjunction = ((((~((StrictLessThan(length, 0)))) & (StrictGreaterThan(length, 0))) & (Eq(-1, input_read))) & (Ne((length - length), length)))\nprint(ccode(simplify(path_conjunction)))",
          "soundSymbolic": true,
          "soundBackwards": true,
          "maybe": true,
          "line": 3142,
          "throwingLine": 3145,
          "isStatic": true,
          "targetOnlyArguments": false
        },
        {
          "qualifiedSignature": "org.apache.commons.io.IOUtils.readFully(java.io.Reader, char[], int, int)",
          "exception": "throw new EOFException(\"Length to read: \" + length + \" actual: \" + actual);",
          "pathCojunction": "(!(length < 0)) && (remaining - count > 0) && (!(-1 == input.read(buffer, offset + location, remaining))) && (!(remaining - count > 0)) && (actual != length)",
          "symbolicPathConjunction": "(read(input, buffer, offset, length)) && (actual != length)",
          "backwardsPathConjunction": "(!(length < 0)) && (remaining - count - input.read(buffer, offset + location, remaining) - input.read(buffer, offset + location, remaining - count) > 0) && (!(-1 == input.read(buffer, offset + length - remaining - input.read(buffer, offset + location, remaining), remaining - count - input.read(buffer, offset + location, remaining)))) && (!(remaining - count - input.read(buffer, offset + location, remaining) - input.read(buffer, offset + location, remaining - count) > 0)) && (length - remaining - input.read(buffer, offset + location, remaining) != length)",
          "z3Program": "from z3 import *\nfrom z3_all_models import *\n\noffset0 = Int('offset0')\nlength0 = Int('length0')\ncount0 = Int('count0')\nlocation0 = Int('location0')\nremaining0 = Int('remaining0')\nactual0 = Int('actual0')\n\nconstraints = [\n  count0 == input0.read(buffer0, offset0 + location, remaining),\n  location0 == length0 - remaining,\n  remaining0 == remaining - count0,\n  actual0 == length0 - remaining0 - count0,\n  And(And(And(And(Not(length0 < 0), remaining0 - count0 > 0), Not(-1 == input0.read(buffer0, offset0 + location0, remaining0))), Not(remaining0 - count0 > 0)), actual0 != length0)\n]\n\nsolver = Solver()\nfor constraint in constraints:\n  solver.add(constraint)\n\nmodels = list(all_smt(solver))\nfor model in models: print(model)",
          "symPyProgram": "from sympy import Symbol\nfrom sympy import simplify\nfrom sympy.core.relational import Eq, Ne, StrictGreaterThan, StrictLessThan, LessThan, GreaterThan\nfrom sympy.printing import ccode\n\ninput = Symbol('input')\nbuffer = Symbol('buffer')\noffset = Symbol('offset', integer=True)\nlength = Symbol('length', integer=True)\ninput_read = Symbol('input_read')\npath_conjunction = (((((~((StrictLessThan(length, 0)))) & (StrictGreaterThan((((remaining - count) - input_read) - input_read), 0))) & (~((Eq(-1, input_read))))) & (~((StrictGreaterThan((((remaining - count) - input_read) - input_read), 0))))) & (Ne(((length - remaining) - input_read), length)))\nprint(ccode(simplify(path_conjunction)))",
          "soundSymbolic": true,
          "soundBackwards": false,
          "maybe": true,
          "line": 3142,
          "throwingLine": 3145,
          "isStatic": true,
          "targetOnlyArguments": false
        },
        {
          "qualifiedSignature": "org.apache.commons.io.IOUtils.readFully(java.io.Reader, char[], int, int)",
          "exception": "throw new IllegalArgumentException(\"Length must not be negative: \" + length);",
          "pathCojunction": "(length < 0)",
          "symbolicPathConjunction": "(read(input, buffer, offset, length))",
          "backwardsPathConjunction": "(length < 0)",
          "simplifiedPathConjunction": "length < 0",
          "z3Inputs": "[length0 = -1]\n[length0 = -2]\n[length0 = -3]\n[length0 = -4]\n[length0 = -5]\n[length0 = -6]\n[length0 = -7]\n[length0 = -8]\n[length0 = -9]\n[length0 = -10]\n",
          "z3Program": "from z3 import *\nfrom z3_all_models import *\n\noffset0 = Int('offset0')\nlength0 = Int('length0')\n\nconstraints = [\n  length0 < 0\n]\n\nsolver = Solver()\nfor constraint in constraints:\n  solver.add(constraint)\n\nmodels = list(all_smt(solver))\nfor model in models: print(model)",
          "symPyProgram": "from sympy import Symbol\nfrom sympy import simplify\nfrom sympy.core.relational import Eq, Ne, StrictGreaterThan, StrictLessThan, LessThan, GreaterThan\nfrom sympy.printing import ccode\n\nlength = Symbol('length', integer=True)\npath_conjunction = (StrictLessThan(length, 0))\nprint(ccode(simplify(path_conjunction)))",
          "soundSymbolic": true,
          "soundBackwards": true,
          "maybe": false,
          "line": 3142,
          "throwingLine": 3143,
          "isStatic": true,
          "targetOnlyArguments": true
        },
        {
          "qualifiedSignature": "org.apache.commons.io.IOUtils.readFully(java.io.Reader, char[])",
          "exception": "throw new EOFException(\"Length to read: \" + buffer.length + \" actual: \" + actual)",
          "pathCojunction": "(!(buffer.length < 0)) && (remaining - count - input.read(buffer, offset + location, remaining) > 0) && (!(-1 == input.read(buffer, 0 + length - remaining, remaining - count))) && (!(remaining - count - input.read(buffer, offset + location, remaining) > 0)) && (length - remaining - count != buffer.length)",
          "symbolicPathConjunction": "(readFully(input, buffer, 0, buffer.length))",
          "backwardsPathConjunction": "(!(buffer.length < 0)) && (remaining - count - input.read(buffer, offset + location, remaining) - input.read(buffer, offset + location, remaining - count) - input.read(buffer, offset + length - remaining - input.read(buffer, offset + location, remaining), remaining - count - input.read(buffer, offset + location, remaining)) > 0) && (!(-1 == input.read(buffer, 0 + length - remaining - count - input.read(buffer, offset + location, remaining), remaining - count - input.read(buffer, offset + location, remaining) - input.read(buffer, offset + location, remaining - count)))) && (!(remaining - count - input.read(buffer, offset + location, remaining) - input.read(buffer, offset + location, remaining - count) - input.read(buffer, offset + length - remaining - input.read(buffer, offset + location, remaining), remaining - count - input.read(buffer, offset + location, remaining)) > 0)) && (length - remaining - count - input.read(buffer, offset + location, remaining) - input.read(buffer, offset + location, remaining - count) != buffer.length)",
          "z3Program": "from z3 import *\nfrom z3_all_models import *\n\noffset0 = Int('offset0')\ncount0 = Int('count0')\nlength0 = Int('length0')\nlocation0 = Int('location0')\nremaining0 = Int('remaining0')\nbuffer0_length = Int('buffer0_length')\n\nconstraints = [\n  count0 == input0.read(buffer0, offset0 + location, remaining),\n  location0 == length0 - remaining,\n  remaining0 == remaining - count0,\n  buffer0_length >= 0, # implicit\n  And(And(And(And(Not(buffer0_length < 0), remaining0 - count0 - input0.read(buffer0, offset0 + location0, remaining0) > 0), Not(-1 == input0.read(buffer0, 0 + length0 - remaining0, remaining0 - count0))), Not(remaining0 - count0 - input0.read(buffer0, offset0 + location0, remaining0) > 0)), length0 - remaining0 - count0 != buffer0_length)\n]\n\nsolver = Solver()\nfor constraint in constraints:\n  solver.add(constraint)\n\nmodels = list(all_smt(solver))\nfor model in models: print(model)",
          "symPyProgram": "from sympy import Symbol\nfrom sympy import simplify\nfrom sympy.core.relational import Eq, Ne, StrictGreaterThan, StrictLessThan, LessThan, GreaterThan\nfrom sympy.printing import ccode\n\ninput = Symbol('input')\nbuffer = Symbol('buffer')\noffset = Symbol('offset', integer=True)\nlength = Symbol('length', integer=True)\nbuffer_length = Symbol('buffer_length', integer=True)\ninput_read = Symbol('input_read')\npath_conjunction = (((((~((StrictLessThan(buffer_length, 0)))) & (StrictGreaterThan(((((remaining - count) - input_read) - input_read) - input_read), 0))) & (~((Eq(-1, input_read))))) & (~((StrictGreaterThan(((((remaining - count) - input_read) - input_read) - input_read), 0))))) & (Ne(((((length - remaining) - count) - input_read) - input_read), buffer_length)))\nprint(ccode(simplify(path_conjunction)))",
          "soundSymbolic": true,
          "soundBackwards": false,
          "maybe": true,
          "line": 3162,
          "throwingLine": 3163,
          "isStatic": true,
          "targetOnlyArguments": false
        },
        {
          "qualifiedSignature": "org.apache.commons.io.IOUtils.readFully(java.io.Reader, char[])",
          "exception": "throw new EOFException(\"Length to read: \" + buffer.length + \" actual: \" + actual)",
          "pathCojunction": "(!(buffer.length < 0)) && (buffer.length > 0) && (-1 == input.read(buffer, 0 + length - remaining, length)) && (length - length != buffer.length)",
          "symbolicPathConjunction": "(readFully(input, buffer, 0, buffer.length))",
          "backwardsPathConjunction": "(!(buffer.length < 0)) && (buffer.length > 0) && (-1 == input.read(buffer, 0 + length - length, length)) && (length - length != buffer.length)",
          "simplifiedPathConjunction": "input.read(buffer, 0 + length - length, length) == -1 && buffer.length > 0",
          "z3Program": "from z3 import *\nfrom z3_all_models import *\n\nlength0 = Int('length0')\nremaining0 = Int('remaining0')\nbuffer0_length = Int('buffer0_length')\n\nconstraints = [\n  remaining0 == length0,\n  buffer0_length >= 0, # implicit\n  And(And(And(Not(buffer0_length < 0), buffer0_length > 0), -1 == input0.read(buffer0, 0 + length0 - remaining0, length0)), length0 - length0 != buffer0_length)\n]\n\nsolver = Solver()\nfor constraint in constraints:\n  solver.add(constraint)\n\nmodels = list(all_smt(solver))\nfor model in models: print(model)",
          "symPyProgram": "from sympy import Symbol\nfrom sympy import simplify\nfrom sympy.core.relational import Eq, Ne, StrictGreaterThan, StrictLessThan, LessThan, GreaterThan\nfrom sympy.printing import ccode\n\ninput = Symbol('input')\nbuffer = Symbol('buffer')\nlength = Symbol('length', integer=True)\nbuffer_length = Symbol('buffer_length', integer=True)\ninput_read = Symbol('input_read')\npath_conjunction = ((((~((StrictLessThan(buffer_length, 0)))) & (StrictGreaterThan(buffer_length, 0))) & (Eq(-1, input_read))) & (Ne((length - length), buffer_length)))\nprint(ccode(simplify(path_conjunction)))",
          "soundSymbolic": true,
          "soundBackwards": false,
          "maybe": true,
          "line": 3162,
          "throwingLine": 3163,
          "isStatic": true,
          "targetOnlyArguments": false
        },
        {
          "qualifiedSignature": "org.apache.commons.io.IOUtils.readFully(java.io.InputStream, byte[], int, int)",
          "exception": "throw new EOFException(\"Length to read: \" + length + \" actual: \" + actual);",
          "pathCojunction": "(!(length < 0)) && (length > 0) && (-1 == input.read(buffer, offset + location, remaining)) && (actual != length)",
          "symbolicPathConjunction": "(read(input, buffer, offset, length)) && (actual != length)",
          "backwardsPathConjunction": "(!(length < 0)) && (length > 0) && (-1 == input.read(buffer, offset + length - length, length)) && (length - length != length)",
          "simplifiedPathConjunction": "input.read(buffer, offset + length - length, length) == -1 && length > 0",
          "z3Program": "from z3 import *\nfrom z3_all_models import *\n\noffset0 = Int('offset0')\nlength0 = Int('length0')\nlocation0 = Int('location0')\nremaining0 = Int('remaining0')\nactual0 = Int('actual0')\n\nconstraints = [\n  location0 == length0 - remaining,\n  remaining0 == length0,\n  actual0 == length0 - length0,\n  And(And(And(Not(length0 < 0), length0 > 0), -1 == input0.read(buffer0, offset0 + location0, remaining0)), actual0 != length0)\n]\n\nsolver = Solver()\nfor constraint in constraints:\n  solver.add(constraint)\n\nmodels = list(all_smt(solver))\nfor model in models: print(model)",
          "symPyProgram": "from sympy import Symbol\nfrom sympy import simplify\nfrom sympy.core.relational import Eq, Ne, StrictGreaterThan, StrictLessThan, LessThan, GreaterThan\nfrom sympy.printing import ccode\n\ninput = Symbol('input')\nbuffer = Symbol('buffer')\noffset = Symbol('offset', integer=True)\nlength = Symbol('length', integer=True)\ninput_read = Symbol('input_read')\npath_conjunction = ((((~((StrictLessThan(length, 0)))) & (StrictGreaterThan(length, 0))) & (Eq(-1, input_read))) & (Ne((length - length), length)))\nprint(ccode(simplify(path_conjunction)))",
          "soundSymbolic": true,
          "soundBackwards": true,
          "maybe": true,
          "line": 3182,
          "throwingLine": 3185,
          "isStatic": true,
          "targetOnlyArguments": false
        },
        {
          "qualifiedSignature": "org.apache.commons.io.IOUtils.readFully(java.io.InputStream, byte[], int, int)",
          "exception": "throw new IllegalArgumentException(\"Length must not be negative: \" + length);",
          "pathCojunction": "(length < 0)",
          "symbolicPathConjunction": "(read(input, buffer, offset, length))",
          "backwardsPathConjunction": "(length < 0)",
          "simplifiedPathConjunction": "length < 0",
          "z3Inputs": "[length0 = -1]\n[length0 = -2]\n[length0 = -3]\n[length0 = -4]\n[length0 = -5]\n[length0 = -6]\n[length0 = -7]\n[length0 = -8]\n[length0 = -9]\n[length0 = -10]\n",
          "z3Program": "from z3 import *\nfrom z3_all_models import *\n\noffset0 = Int('offset0')\nlength0 = Int('length0')\n\nconstraints = [\n  length0 < 0\n]\n\nsolver = Solver()\nfor constraint in constraints:\n  solver.add(constraint)\n\nmodels = list(all_smt(solver))\nfor model in models: print(model)",
          "symPyProgram": "from sympy import Symbol\nfrom sympy import simplify\nfrom sympy.core.relational import Eq, Ne, StrictGreaterThan, StrictLessThan, LessThan, GreaterThan\nfrom sympy.printing import ccode\n\nlength = Symbol('length', integer=True)\npath_conjunction = (StrictLessThan(length, 0))\nprint(ccode(simplify(path_conjunction)))",
          "soundSymbolic": true,
          "soundBackwards": true,
          "maybe": false,
          "line": 3182,
          "throwingLine": 3183,
          "isStatic": true,
          "targetOnlyArguments": true
        },
        {
          "qualifiedSignature": "org.apache.commons.io.IOUtils.readFully(java.io.InputStream, byte[], int, int)",
          "exception": "throw new EOFException(\"Length to read: \" + length + \" actual: \" + actual);",
          "pathCojunction": "(!(length < 0)) && (remaining - count > 0) && (!(-1 == input.read(buffer, offset + location, remaining))) && (!(remaining - count > 0)) && (actual != length)",
          "symbolicPathConjunction": "(read(input, buffer, offset, length)) && (actual != length)",
          "backwardsPathConjunction": "(!(length < 0)) && (remaining - count - input.read(buffer, offset + location, remaining) - input.read(buffer, offset + location, remaining - count) > 0) && (!(-1 == input.read(buffer, offset + length - remaining - input.read(buffer, offset + location, remaining), remaining - count - input.read(buffer, offset + location, remaining)))) && (!(remaining - count - input.read(buffer, offset + location, remaining) - input.read(buffer, offset + location, remaining - count) > 0)) && (length - remaining - input.read(buffer, offset + location, remaining) != length)",
          "z3Program": "from z3 import *\nfrom z3_all_models import *\n\noffset0 = Int('offset0')\nlength0 = Int('length0')\ncount0 = Int('count0')\nlocation0 = Int('location0')\nremaining0 = Int('remaining0')\nactual0 = Int('actual0')\n\nconstraints = [\n  count0 == input0.read(buffer0, offset0 + location, remaining),\n  location0 == length0 - remaining,\n  remaining0 == remaining - count0,\n  actual0 == length0 - remaining0 - count0,\n  And(And(And(And(Not(length0 < 0), remaining0 - count0 > 0), Not(-1 == input0.read(buffer0, offset0 + location0, remaining0))), Not(remaining0 - count0 > 0)), actual0 != length0)\n]\n\nsolver = Solver()\nfor constraint in constraints:\n  solver.add(constraint)\n\nmodels = list(all_smt(solver))\nfor model in models: print(model)",
          "symPyProgram": "from sympy import Symbol\nfrom sympy import simplify\nfrom sympy.core.relational import Eq, Ne, StrictGreaterThan, StrictLessThan, LessThan, GreaterThan\nfrom sympy.printing import ccode\n\ninput = Symbol('input')\nbuffer = Symbol('buffer')\noffset = Symbol('offset', integer=True)\nlength = Symbol('length', integer=True)\ninput_read = Symbol('input_read')\npath_conjunction = (((((~((StrictLessThan(length, 0)))) & (StrictGreaterThan((((remaining - count) - input_read) - input_read), 0))) & (~((Eq(-1, input_read))))) & (~((StrictGreaterThan((((remaining - count) - input_read) - input_read), 0))))) & (Ne(((length - remaining) - input_read), length)))\nprint(ccode(simplify(path_conjunction)))",
          "soundSymbolic": true,
          "soundBackwards": false,
          "maybe": true,
          "line": 3182,
          "throwingLine": 3185,
          "isStatic": true,
          "targetOnlyArguments": false
        },
        {
          "qualifiedSignature": "org.apache.commons.io.IOUtils.readFully(java.io.InputStream, byte[])",
          "exception": "throw new EOFException(\"Length to read: \" + buffer.length + \" actual: \" + actual)",
          "pathCojunction": "(!(buffer.length < 0)) && (buffer.length > 0) && (-1 == input.read(buffer, 0 + length - remaining, length)) && (length - length != buffer.length)",
          "symbolicPathConjunction": "(readFully(input, buffer, 0, buffer.length))",
          "backwardsPathConjunction": "(!(buffer.length < 0)) && (buffer.length > 0) && (-1 == input.read(buffer, 0 + length - length, length)) && (length - length != buffer.length)",
          "simplifiedPathConjunction": "input.read(buffer, 0 + length - length, length) == -1 && buffer.length > 0",
          "z3Program": "from z3 import *\nfrom z3_all_models import *\n\nlength0 = Int('length0')\nremaining0 = Int('remaining0')\nbuffer0_length = Int('buffer0_length')\n\nconstraints = [\n  remaining0 == length0,\n  buffer0_length >= 0, # implicit\n  And(And(And(Not(buffer0_length < 0), buffer0_length > 0), -1 == input0.read(buffer0, 0 + length0 - remaining0, length0)), length0 - length0 != buffer0_length)\n]\n\nsolver = Solver()\nfor constraint in constraints:\n  solver.add(constraint)\n\nmodels = list(all_smt(solver))\nfor model in models: print(model)",
          "symPyProgram": "from sympy import Symbol\nfrom sympy import simplify\nfrom sympy.core.relational import Eq, Ne, StrictGreaterThan, StrictLessThan, LessThan, GreaterThan\nfrom sympy.printing import ccode\n\ninput = Symbol('input')\nbuffer = Symbol('buffer')\nlength = Symbol('length', integer=True)\nbuffer_length = Symbol('buffer_length', integer=True)\ninput_read = Symbol('input_read')\npath_conjunction = ((((~((StrictLessThan(buffer_length, 0)))) & (StrictGreaterThan(buffer_length, 0))) & (Eq(-1, input_read))) & (Ne((length - length), buffer_length)))\nprint(ccode(simplify(path_conjunction)))",
          "soundSymbolic": true,
          "soundBackwards": false,
          "maybe": true,
          "line": 3202,
          "throwingLine": 3203,
          "isStatic": true,
          "targetOnlyArguments": false
        },
        {
          "qualifiedSignature": "org.apache.commons.io.IOUtils.readFully(java.io.InputStream, byte[])",
          "exception": "throw new EOFException(\"Length to read: \" + buffer.length + \" actual: \" + actual)",
          "pathCojunction": "(!(buffer.length < 0)) && (remaining - count - input.read(buffer, offset + location, remaining) > 0) && (!(-1 == input.read(buffer, 0 + length - remaining, remaining - count))) && (!(remaining - count - input.read(buffer, offset + location, remaining) > 0)) && (length - remaining - count != buffer.length)",
          "symbolicPathConjunction": "(readFully(input, buffer, 0, buffer.length))",
          "backwardsPathConjunction": "(!(buffer.length < 0)) && (remaining - count - input.read(buffer, offset + location, remaining) - input.read(buffer, offset + location, remaining - count) - input.read(buffer, offset + length - remaining - input.read(buffer, offset + location, remaining), remaining - count - input.read(buffer, offset + location, remaining)) > 0) && (!(-1 == input.read(buffer, 0 + length - remaining - count - input.read(buffer, offset + location, remaining), remaining - count - input.read(buffer, offset + location, remaining) - input.read(buffer, offset + location, remaining - count)))) && (!(remaining - count - input.read(buffer, offset + location, remaining) - input.read(buffer, offset + location, remaining - count) - input.read(buffer, offset + length - remaining - input.read(buffer, offset + location, remaining), remaining - count - input.read(buffer, offset + location, remaining)) > 0)) && (length - remaining - count - input.read(buffer, offset + location, remaining) - input.read(buffer, offset + location, remaining - count) != buffer.length)",
          "z3Program": "from z3 import *\nfrom z3_all_models import *\n\noffset0 = Int('offset0')\ncount0 = Int('count0')\nlength0 = Int('length0')\nlocation0 = Int('location0')\nremaining0 = Int('remaining0')\nbuffer0_length = Int('buffer0_length')\n\nconstraints = [\n  count0 == input0.read(buffer0, offset0 + location, remaining),\n  location0 == length0 - remaining,\n  remaining0 == remaining - count0,\n  buffer0_length >= 0, # implicit\n  And(And(And(And(Not(buffer0_length < 0), remaining0 - count0 - input0.read(buffer0, offset0 + location0, remaining0) > 0), Not(-1 == input0.read(buffer0, 0 + length0 - remaining0, remaining0 - count0))), Not(remaining0 - count0 - input0.read(buffer0, offset0 + location0, remaining0) > 0)), length0 - remaining0 - count0 != buffer0_length)\n]\n\nsolver = Solver()\nfor constraint in constraints:\n  solver.add(constraint)\n\nmodels = list(all_smt(solver))\nfor model in models: print(model)",
          "symPyProgram": "from sympy import Symbol\nfrom sympy import simplify\nfrom sympy.core.relational import Eq, Ne, StrictGreaterThan, StrictLessThan, LessThan, GreaterThan\nfrom sympy.printing import ccode\n\ninput = Symbol('input')\nbuffer = Symbol('buffer')\noffset = Symbol('offset', integer=True)\nlength = Symbol('length', integer=True)\nbuffer_length = Symbol('buffer_length', integer=True)\ninput_read = Symbol('input_read')\npath_conjunction = (((((~((StrictLessThan(buffer_length, 0)))) & (StrictGreaterThan(((((remaining - count) - input_read) - input_read) - input_read), 0))) & (~((Eq(-1, input_read))))) & (~((StrictGreaterThan(((((remaining - count) - input_read) - input_read) - input_read), 0))))) & (Ne(((((length - remaining) - count) - input_read) - input_read), buffer_length)))\nprint(ccode(simplify(path_conjunction)))",
          "soundSymbolic": true,
          "soundBackwards": false,
          "maybe": true,
          "line": 3202,
          "throwingLine": 3203,
          "isStatic": true,
          "targetOnlyArguments": false
        },
        {
          "qualifiedSignature": "org.apache.commons.io.IOUtils.readFully(java.io.InputStream, int)",
          "exception": "throw new EOFException(\"Length to read: \" + buffer.length + \" actual: \" + actual)",
          "pathCojunction": "(!(buffer.length < 0)) && (remaining - count - input.read(buffer, offset + location, remaining) > 0) && (!(-1 == input.read(buffer, 0 + length - remaining, remaining - count))) && (!(remaining - count - input.read(buffer, offset + location, remaining) > 0)) && (length - remaining - count != buffer.length)",
          "symbolicPathConjunction": "(readFully(input, buffer, 0, buffer.length))",
          "backwardsPathConjunction": "(!(new byte[length].length < 0)) && (remaining - count - input.read(buffer, offset + location, remaining) - input.read(new byte[length], offset + location, remaining - count) - input.read(new byte[length], offset + length - remaining - input.read(buffer, offset + location, remaining), remaining - count - input.read(buffer, offset + location, remaining)) > 0) && (!(-1 == input.read(new byte[length], 0 + length - remaining - count - input.read(buffer, offset + location, remaining), remaining - count - input.read(buffer, offset + location, remaining) - input.read(new byte[length], offset + location, remaining - count)))) && (!(remaining - count - input.read(buffer, offset + location, remaining) - input.read(new byte[length], offset + location, remaining - count) - input.read(new byte[length], offset + length - remaining - input.read(buffer, offset + location, remaining), remaining - count - input.read(buffer, offset + location, remaining)) > 0)) && (length - remaining - count - input.read(buffer, offset + location, remaining) - input.read(new byte[length], offset + location, remaining - count) != new byte[length].length)",
          "z3Program": "from z3 import *\nfrom z3_all_models import *\n\nlength0 = Int('length0')\noffset0 = Int('offset0')\ncount0 = Int('count0')\nlocation0 = Int('location0')\nremaining0 = Int('remaining0')\nbuffer0_length = Int('buffer0_length')\n\nconstraints = [\n  buffer0 == new byte[length0],\n  count0 == input0.read(buffer0, offset0 + location, remaining),\n  location0 == length0 - remaining,\n  remaining0 == remaining - count0,\n  buffer0_length >= 0, # implicit\n  And(And(And(And(Not(buffer0_length < 0), remaining0 - count0 - input0.read(buffer0, offset0 + location0, remaining0) > 0), Not(-1 == input0.read(buffer0, 0 + length0 - remaining0, remaining0 - count0))), Not(remaining0 - count0 - input0.read(buffer0, offset0 + location0, remaining0) > 0)), length0 - remaining0 - count0 != buffer0_length)\n]\n\nsolver = Solver()\nfor constraint in constraints:\n  solver.add(constraint)\n\nmodels = list(all_smt(solver))\nfor model in models: print(model)",
          "soundSymbolic": true,
          "soundBackwards": false,
          "maybe": true,
          "line": 3220,
          "throwingLine": 3222,
          "isStatic": true,
          "targetOnlyArguments": false
        },
        {
          "qualifiedSignature": "org.apache.commons.io.IOUtils.readFully(java.io.InputStream, int)",
          "exception": "throw new EOFException(\"Length to read: \" + buffer.length + \" actual: \" + actual)",
          "pathCojunction": "(!(buffer.length < 0)) && (buffer.length > 0) && (-1 == input.read(buffer, 0 + length - remaining, length)) && (length - length != buffer.length)",
          "symbolicPathConjunction": "(readFully(input, buffer, 0, buffer.length))",
          "backwardsPathConjunction": "(!(new byte[length].length < 0)) && (new byte[length].length > 0) && (-1 == input.read(new byte[length], 0 + length - length, length)) && (length - length != new byte[length].length)",
          "z3Program": "from z3 import *\nfrom z3_all_models import *\n\nlength0 = Int('length0')\nremaining0 = Int('remaining0')\nbuffer0_length = Int('buffer0_length')\n\nconstraints = [\n  buffer0 == new byte[length0],\n  remaining0 == length0,\n  buffer0_length >= 0, # implicit\n  And(And(And(Not(buffer0_length < 0), buffer0_length > 0), -1 == input0.read(buffer0, 0 + length0 - remaining0, length0)), length0 - length0 != buffer0_length)\n]\n\nsolver = Solver()\nfor constraint in constraints:\n  solver.add(constraint)\n\nmodels = list(all_smt(solver))\nfor model in models: print(model)",
          "soundSymbolic": true,
          "soundBackwards": true,
          "maybe": true,
          "line": 3220,
          "throwingLine": 3222,
          "isStatic": true,
          "targetOnlyArguments": false
        },
        {
          "qualifiedSignature": "org.apache.commons.io.IOUtils.readFully(java.io.InputStream, int)",
          "exception": "throw new IllegalArgumentException(\"Length must not be negative: \" + buffer.length)",
          "pathCojunction": "(buffer.length < 0)",
          "symbolicPathConjunction": "(readFully(input, buffer, 0, buffer.length))",
          "backwardsPathConjunction": "(new byte[length].length < 0)",
          "z3Program": "from z3 import *\nfrom z3_all_models import *\n\nlength0 = Int('length0')\nbuffer0_length = Int('buffer0_length')\n\nconstraints = [\n  buffer0 == new byte[length0],\n  buffer0_length >= 0, # implicit\n  buffer0_length < 0\n]\n\nsolver = Solver()\nfor constraint in constraints:\n  solver.add(constraint)\n\nmodels = list(all_smt(solver))\nfor model in models: print(model)",
          "soundSymbolic": true,
          "soundBackwards": true,
          "maybe": true,
          "line": 3220,
          "throwingLine": 3222,
          "isStatic": true,
          "targetOnlyArguments": false
        },
        {
          "qualifiedSignature": "org.apache.commons.io.IOUtils.readFully(java.io.InputStream, int)",
          "exception": "throw new EOFException(\"Length to read: \" + buffer.length + \" actual: \" + actual)",
          "pathCojunction": "(!(buffer.length < 0)) && (!(buffer.length > 0)) && (length - length != buffer.length)",
          "symbolicPathConjunction": "(readFully(input, buffer, 0, buffer.length))",
          "backwardsPathConjunction": "(!(new byte[length].length < 0)) && (!(new byte[length].length > 0)) && (length - length != new byte[length].length)",
          "z3Program": "from z3 import *\nfrom z3_all_models import *\n\nlength0 = Int('length0')\nbuffer0_length = Int('buffer0_length')\n\nconstraints = [\n  buffer0 == new byte[length0],\n  buffer0_length >= 0, # implicit\n  And(And(Not(buffer0_length < 0), Not(buffer0_length > 0)), length0 - length0 != buffer0_length)\n]\n\nsolver = Solver()\nfor constraint in constraints:\n  solver.add(constraint)\n\nmodels = list(all_smt(solver))\nfor model in models: print(model)",
          "soundSymbolic": true,
          "soundBackwards": true,
          "maybe": true,
          "line": 3220,
          "throwingLine": 3222,
          "isStatic": true,
          "targetOnlyArguments": false
        },
        {
          "qualifiedSignature": "org.apache.commons.io.IOUtils.readFully(java.nio.channels.ReadableByteChannel, java.nio.ByteBuffer)",
          "exception": "throw new EOFException(\"Length to read: \" + expected + \" actual: \" + actual);",
          "pathCojunction": "(buffer.remaining() > 0) && (-1 == input.read(buffer)) && (actual != expected)",
          "symbolicPathConjunction": "(read(input, buffer)) && (actual != expected)",
          "backwardsPathConjunction": "(buffer.remaining() > 0) && (-1 == input.read(buffer)) && (buffer.remaining() - buffer.remaining() != buffer.remaining())",
          "simplifiedPathConjunction": "input.read(buffer) == -1 && buffer.remaining() > 0",
          "z3Program": "from z3 import *\nfrom z3_all_models import *\n\nexpected0 = Int('expected0')\nactual0 = Int('actual0')\n\nconstraints = [\n  expected0 == buffer0.remaining(),\n  actual0 == buffer0.remaining() - buffer0.remaining(),\n  And(And(buffer0.remaining() > 0, -1 == input0.read(buffer0)), actual0 != expected0)\n]\n\nsolver = Solver()\nfor constraint in constraints:\n  solver.add(constraint)\n\nmodels = list(all_smt(solver))\nfor model in models: print(model)",
          "symPyProgram": "from sympy import Symbol\nfrom sympy import simplify\nfrom sympy.core.relational import Eq, Ne, StrictGreaterThan, StrictLessThan, LessThan, GreaterThan\nfrom sympy.printing import ccode\n\ninput = Symbol('input')\nbuffer = Symbol('buffer')\nbuffer_remaining = Symbol('buffer_remaining')\ninput_read = Symbol('input_read')\npath_conjunction = (((StrictGreaterThan(buffer_remaining, 0)) & (Eq(-1, input_read))) & (Ne((buffer_remaining - buffer_remaining), buffer_remaining)))\nprint(ccode(simplify(path_conjunction)))",
          "soundSymbolic": false,
          "soundBackwards": true,
          "maybe": true,
          "line": 3238,
          "throwingLine": 3242,
          "isStatic": true,
          "targetOnlyArguments": false
        },
        {
          "qualifiedSignature": "org.apache.commons.io.IOUtils.readFully(java.nio.channels.ReadableByteChannel, java.nio.ByteBuffer)",
          "exception": "throw new EOFException(\"Length to read: \" + expected + \" actual: \" + actual);",
          "pathCojunction": "(!(buffer.remaining() > 0)) && (actual != expected)",
          "symbolicPathConjunction": "(read(input, buffer)) && (actual != expected)",
          "backwardsPathConjunction": "(!(buffer.remaining() > 0)) && (buffer.remaining() - buffer.remaining() != buffer.remaining())",
          "simplifiedPathConjunction": "buffer.remaining() < 0",
          "z3Program": "from z3 import *\nfrom z3_all_models import *\n\nexpected0 = Int('expected0')\nactual0 = Int('actual0')\n\nconstraints = [\n  expected0 == buffer0.remaining(),\n  actual0 == buffer0.remaining() - buffer0.remaining(),\n  And(Not(buffer0.remaining() > 0), actual0 != expected0)\n]\n\nsolver = Solver()\nfor constraint in constraints:\n  solver.add(constraint)\n\nmodels = list(all_smt(solver))\nfor model in models: print(model)",
          "symPyProgram": "from sympy import Symbol\nfrom sympy import simplify\nfrom sympy.core.relational import Eq, Ne, StrictGreaterThan, StrictLessThan, LessThan, GreaterThan\nfrom sympy.printing import ccode\n\nbuffer = Symbol('buffer')\nbuffer_remaining = Symbol('buffer_remaining')\npath_conjunction = ((~((StrictGreaterThan(buffer_remaining, 0)))) & (Ne((buffer_remaining - buffer_remaining), buffer_remaining)))\nprint(ccode(simplify(path_conjunction)))",
          "soundSymbolic": false,
          "soundBackwards": true,
          "maybe": true,
          "line": 3238,
          "throwingLine": 3242,
          "isStatic": true,
          "targetOnlyArguments": false
        }
      ]
    },
    {
      "path": "/home/yanghengqin/commons-io-commons-io-2.6/src/main/java/org/apache/commons/io/output/BrokenOutputStream.java",
      "methods": [
        {
          "qualifiedSignature": "org.apache.commons.io.output.BrokenOutputStream.write(int)",
          "exception": "throw exception;",
          "pathCojunction": "true",
          "backwardsPathConjunction": "true",
          "simplifiedPathConjunction": "true",
          "z3Program": "from z3 import *\nfrom z3_all_models import *\n\nb0 = Int('b0')\n\nconstraints = [\n  True\n]\n\nsolver = Solver()\nfor constraint in constraints:\n  solver.add(constraint)\n\nmodels = list(all_smt(solver))\nfor model in models: print(model)",
          "soundSymbolic": false,
          "soundBackwards": true,
          "maybe": false,
          "line": 61,
          "throwingLine": 62,
          "isStatic": false,
          "targetOnlyArguments": true
        },
        {
          "qualifiedSignature": "org.apache.commons.io.output.BrokenOutputStream.flush()",
          "exception": "throw exception;",
          "pathCojunction": "true",
          "backwardsPathConjunction": "true",
          "simplifiedPathConjunction": "true",
          "soundSymbolic": false,
          "soundBackwards": true,
          "maybe": false,
          "line": 71,
          "throwingLine": 72,
          "isStatic": false,
          "targetOnlyArguments": true
        },
        {
          "qualifiedSignature": "org.apache.commons.io.output.BrokenOutputStream.close()",
          "exception": "throw exception;",
          "pathCojunction": "true",
          "backwardsPathConjunction": "true",
          "simplifiedPathConjunction": "true",
          "soundSymbolic": false,
          "soundBackwards": true,
          "maybe": false,
          "line": 81,
          "throwingLine": 82,
          "isStatic": false,
          "targetOnlyArguments": true
        }
      ]
    },
    {
      "path": "/home/yanghengqin/commons-io-commons-io-2.6/src/main/java/org/apache/commons/io/FileDeleteStrategy.java",
      "methods": [
        {
          "qualifiedSignature": "org.apache.commons.io.FileDeleteStrategy.delete(java.io.File)",
          "exception": "throw new IOException(\"Deletion failed: \" + fileToDelete);",
          "pathCojunction": "(fileToDelete.exists() && fileToDelete.delete() == false)",
          "symbolicPathConjunction": "(fileToDelete.exists() && fileToDelete.delete() == false)",
          "backwardsPathConjunction": "(fileToDelete.exists() && fileToDelete.delete() == false)",
          "simplifiedPathConjunction": "fileToDelete.exists() && !fileToDelete.delete()",
          "z3Program": "from z3 import *\nfrom z3_all_models import *\n\n\nconstraints = [\n  And(fileToDelete0.exists(), fileToDelete0.delete() == False)\n]\n\nsolver = Solver()\nfor constraint in constraints:\n  solver.add(constraint)\n\nmodels = list(all_smt(solver))\nfor model in models: print(model)",
          "symPyProgram": "from sympy import Symbol\nfrom sympy import simplify\nfrom sympy.core.relational import Eq, Ne, StrictGreaterThan, StrictLessThan, LessThan, GreaterThan\nfrom sympy.printing import ccode\n\nfileToDelete = Symbol('fileToDelete')\nfileToDelete_exists = Symbol('fileToDelete_exists')\nfileToDelete_delete = Symbol('fileToDelete_delete')\npath_conjunction = (fileToDelete_exists & (~(fileToDelete_delete)))\nprint(ccode(simplify(path_conjunction)))",
          "soundSymbolic": false,
          "soundBackwards": true,
          "maybe": true,
          "line": 91,
          "throwingLine": 93,
          "isStatic": false,
          "targetOnlyArguments": true
        }
      ]
    }
  ]
}